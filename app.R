### Copyright (C) 2017-2025  Alvaro Santamaria-Gomez, 12 May 2017
### alvaro.santamaria@get.omp.eu
###
### This program is free software: you can redistribute it and/or modify
### it under the terms of the GNU General Public License as published by
### the Free Software Foundation, either version 3 of the License, or
### any later version.
###
### This program is distributed in the hope that it will be useful,
### but WITHOUT ANY WARRANTY; without even the implied warranty of
### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
### GNU General Public License for more details.
###
### You should have received a copy of the GNU General Public License
### along with this program. If not, see <https://www.gnu.org/licenses/>.

# Loading packages ####
suppressPackageStartupMessages(suppressMessages(suppressWarnings({
  library(data.table, verbose = F, quietly = T)
  library(dlm, verbose = F, quietly = T)
  library(fields, verbose = F, quietly = T)
  library(lubridate, verbose = F, quietly = T)
  library(magrittr, verbose = F, quietly = T)
  library(markdown, verbose = F, quietly = T)
  library(matrixStats, verbose = F, quietly = T)
  library(mnormt, verbose = F, quietly = T)
  library(numDeriv, verbose = F, quietly = T)
  library(pracma, verbose = F, quietly = T)
  library(psych, verbose = F, quietly = T)
  library(RColorBrewer, verbose = F, quietly = T)
  library(RCurl, verbose = F, quietly = T)
  library(XML, verbose = F, quietly = T)
  library(jsonlite, verbose = F, quietly = T)
  library(shinyBS, verbose = F, quietly = T)
  library(shinycssloaders, verbose = F, quietly = T)
  library(shinyjs, verbose = F, quietly = T)
  library(shinythemes, verbose = F, quietly = T)
  library(shiny, verbose = F, quietly = T)
  library(spectral, verbose = F, quietly = T)
  library(strucchange, verbose = F, quietly = T)
  library(tseries, verbose = F, quietly = T)
})))

# Function to check and load packages if installed
check_load <- function(packages) {
  for (package in packages) {
    if (package %in% rownames(installed.packages())) {
      suppressPackageStartupMessages(suppressMessages(suppressWarnings(do.call('library', list(package = package, verbose = F, quietly = T)))))
    }
  }
}

# Shinyapps & local version
# suppressPackageStartupMessages(suppressMessages(suppressWarnings({
#   library(mvcwt, verbose = F, quietly = T)
#   library(leaflet, verbose = F, quietly = T)
#   library(geojsonio, verbose = F, quietly = T)
#   library(Rcpp, verbose = F, quietly = T)
#   library(RcppArmadillo, verbose = F, quietly = T)
#   library(RcppEigen, verbose = F, quietly = T)
# })))
# GitHub version
optionalPackages <- c(
  "mvcwt",
  "leaflet",
  "geojsonio",
  "Rcpp",
  "RcppArmadillo",
  "RcppEigen"
)
check_load(optionalPackages)

# GUI addons ####

# Help popups (based on https://github.com/daattali/ddpcr/blob/master/inst/shiny/ui/helpers.R)
helpPopup <- function(content, title = NULL, anchor = NULL) {
  if (is.null(anchor)) {
    a(#href = "#",
      class = "popover-link",
      `data-toggle` = "popover",
      `data-title` = title,
      `data-content` = content,
      `data-html` = "true",
      `data-trigger` = "hover",
      `data-placement` = "auto right",
      `data-container` = "body",
      `data-animation` = "true",
      `data-delay` = "show: 100, hide: 500",
      icon("circle-question")
    )
  } else {
    a(href = paste0("about.html#",anchor), target = "_blank",
      class = "popover-link",
      `data-toggle` = "popover",
      `data-title` = title,
      `data-content` = content,
      `data-html` = "true",
      `data-trigger` = "hover",
      `data-placement` = "auto right",
      `data-container` = "body",
      `data-animation` = "true",
      `data-delay` = "show: 100, hide: 500",
      icon("circle-question")
    )
  }
}
helpPopupHeader <- function(content, title = NULL) {
  a(#href = "#",
    class = "popover-link",
    `data-toggle` = "popover",
    `data-title` = title,
    `data-content` = content,
    `data-html` = "true",
    `data-trigger` = "hover",
    `data-placement` = "auto right",
    `data-container` = "body",
    `data-animation` = "true",
    `data-delay` = "show: 100, hide: 500",
    icon("circle-question", class = "headerIcon")
  )
}

# Working spinner (based on https://github.com/daattali/advanced-shiny/blob/master/busy-indicator/helpers.R)
withBusyIndicatorUI <- function(button) {
  id <- button[['attribs']][['id']]
  div(
    shinyjs::useShinyjs(),
    singleton(tags$head(
      tags$style(withBusyIndicatorCSS)
    )),
    `data-for-btn` = id,
    button,
    span(
      class = "btn-loading-container",
      shinyjs::hidden(
        img(src = "ajax-loader-bar.gif", class = "btn-loading-indicator"),
        icon("check", class = "btn-done-indicator")
      )
    ),
    shinyjs::hidden(
      div(class = "btn-err",
          div(icon("circle-exclamation"),
              tags$b("Error: "),
              span(class = "btn-err-msg")
          )
      )
    )
  )
}

# CSS class for disabled tabs
withBusyIndicatorCSS <- "
  .btn-loading-container {
    margin-left: 10px;
    font-size: 1.2em;
  }
  .btn-done-indicator {
    color: #61D04F;
  }
  .btn-err {
    margin-top: 10px;
    color: #DF536B;
  }"

# Mobile detector (from https://g3rv4.com/2017/08/shiny-detect-mobile-browsers)
mobileDetect <- function(inputId, value = 0) {
  tagList(
    singleton(tags$head(tags$script(src = "mobile.js"))),
    tags$input(id = inputId,
               class = "mobile-element",
               type = "hidden")
  )
}

# Disable tab click (based on https://stackoverflow.com/questions/40741691/rshiny-disabling-tabs-adding-text-to-tabs)
css <- '
.disabled {
background: default !important;
cursor: not-allowed !important;
pointer-events: none;
color: gray62 !important;
}'

# show & check plotAll popup
showPopup <- "shinyjs.showPopup = function(file) { overview = window.open('' + file + '', 'plotAll', 'popup=yes, width=1000, height=800, menubar=no, resizable=yes, status=no, titlebar=no, toolbar=no'); }"
checkPopup <- "shinyjs.checkPopup = function() { var status = 'FALSE'; if (typeof overview === 'object') { status = !overview.closed; } Shiny.onInputChange('overview', status);}"

# force autocomplete off for Firefox (based on https://github.com/rstudio/shiny/issues/3763)
autoCompleteOff <- function(x) {
  tagAppendAttributes(x, .cssSelector = "input", autocomplete = "off")
}

# Update file names from URL/remote (based on https://stackoverflow.com/questions/62626901/r-shiny-change-text-fileinput-after-upload)
update_series <- "
Shiny.addCustomMessageHandler('filename', function(txt) {
  var target = $('#series').parent().parent().parent().find('input[type=text]');
  target.val(txt);
}); "
update_series2 <- "
Shiny.addCustomMessageHandler('filename2', function(txt) {
  var target = $('#series2').parent().parent().parent().find('input[type=text]');
  target.val(txt);
}); "
update_sitelog <- "
Shiny.addCustomMessageHandler('log', function(txt) {
  var target = $('#log').parent().parent().parent().find('input[type=text]');
  target.val(txt);
}); "
update_soln <- "
Shiny.addCustomMessageHandler('soln', function(txt) {
  var target = $('#soln').parent().parent().parent().find('input[type=text]');
  target.val(txt);
}); "
update_custom <- "
Shiny.addCustomMessageHandler('custom', function(txt) {
  var target = $('#custom').parent().parent().parent().find('input[type=text]');
  target.val(txt);
}); "
update_step <- "
Shiny.addCustomMessageHandler('step', function(txt) {
  var target = $('#step').parent().parent().parent().find('input[type=text]');
  target.val(txt);
}); "
update_step2 <- "
Shiny.addCustomMessageHandler('step2', function(txt) {
  var target = $('#step2').parent().parent().parent().find('input[type=text]');
  target.val(txt);
}); "
update_trendRef <- "
Shiny.addCustomMessageHandler('trendRef', function(txt) {
  var target = $('#trendRef').parent().parent().parent().find('input[type=text]');
  target.val(txt);
}); "

# Hide loading page splash, from https://stackoverflow.com/questions/35599470/shiny-dashboard-display-a-dedicated-loading-page-until-initial-loading-of
load_data <- function(seconds) {
  Sys.sleep(seconds)
  shinyjs::hide("loading_page")
  shinyjs::show("main_content")
}

# Setting the layout of the plots in the visualization panel
tabContents <- function(tabNum) {
  if (tabNum == 1) {
    tabName <- uiOutput("tabName1")
  } else if (tabNum == 2) {
    tabName <- uiOutput("tabName2")
  } else if (tabNum == 3) {
    tabName <- uiOutput("tabName3")
  }
  tabPanel(div(style = "font-size: 20px;",tabName), value = tabNum,
           tags$style(type = "text/css", "
                      body {padding-top: 60px;}
                      #side-panel,.navbar-nav {-webkit-user-select: none; -ms-user-select: none; user-select: none;}
                      .shiny-html-output {-webkit-user-select: text; -ms-user-select: text; user-select: text;}
                      "),
           hidden(div(id = paste0("zoomin",tabNum), style = "margin-bottom: -3em; margin-top: 2em; color: #DF536B; font-weight: bold; margin-right: 30px; font-size: 10px; text-align: right; position: relative; z-index: 1;", "Zoomed in")),
           withSpinner(
             plotOutput(paste0("plot",tabNum), click = "plot_1click", dblclick = dblclickOpts("plot_2click", delay = 1000), brush = brushOpts(id = "plot_brush", resetOnNew = T, fill = "#DF536B", stroke = "gray62", opacity = '0.5', clip = T)),
             type = getOption("spinner.type", default = 1),
             color = getOption("spinner.color", default = "#0080ff"),
             size = getOption("spinner.size", default = 2),
             color.background = getOption("spinner.color.background", default = "#ffffff"),
             hide.ui = F, proxy.height = if (grepl("height:\\s*\\d", "plot1")) NULL else "400px"
           ),
           conditionalPanel(
             condition = "output.run",
             withSpinner(
               plotOutput(paste0("res",tabNum), click = "plot_1click", dblclick = dblclickOpts("res_2click", delay = 1000), brush = brushOpts(id = "res_brush", resetOnNew = T, fill = "#2297E6", stroke = "gray62", opacity = '0.5', clip = T)),
               type = getOption("spinner.type", default = 1),
               color = getOption("spinner.color", default = "#0080ff"),
               size = getOption("spinner.size", default = 2),
               color.background = getOption("spinner.color.background", default = "#ffffff"),
               hide.ui = F, proxy.height = if (grepl("height:\\s*\\d", "res1")) NULL else "400px"
             )
           ),
           conditionalPanel(
             condition = "input.filter == true && input.low !== input.high && output.residuals == false && input.series2filter == 1",
             withSpinner(
               plotOutput(paste0("vondrak",tabNum), click = "plot_1click", dblclick = "res_2click", brush = brushOpts(id = "vondrak_brush", resetOnNew = T, fill = "#2297E6", stroke = "gray62", opacity = '0.5', clip = T)),
               type = getOption("spinner.type", default = 1),
               color = getOption("spinner.color", default = "#0080ff"),
               size = getOption("spinner.size", default = 2),
               color.background = getOption("spinner.color.background", default = "#ffffff"),
               hide.ui = F, proxy.height = if (grepl("height:\\s*\\d", "res1")) NULL else "400px"
             )
           ),
           verbatimTextOutput(paste0("plot",tabNum,"_info"), placeholder = F),
           conditionalPanel(
             condition = "output.rate",
             withSpinner(
               plotOutput(paste0("rate",tabNum), click = "plot_1click", dblclick = "rate_2click", brush = brushOpts(id = "rate_brush", resetOnNew = T, fill = "#2297E6", stroke = "gray62", opacity = '0.5', clip = T)),
               type = getOption("spinner.type", default = 1),
               color = getOption("spinner.color", default = "#0080ff"),
               size = getOption("spinner.size", default = 2),
               color.background = getOption("spinner.color.background", default = "#ffffff"),
               hide.ui = F, proxy.height = if (grepl("height:\\s*\\d", "res1")) NULL else "400px"
             )
           ),
           conditionalPanel(
             condition = "input.filter == true && input.low !== input.high && output.residuals == true && input.series2filter == 2",
             withSpinner(
               plotOutput(paste0("Vondrak",tabNum), click = "plot_1click", dblclick = "res_2click", brush = brushOpts(id = "vondrak_brush", resetOnNew = T, fill = "#2297E6", stroke = "gray62", opacity = '0.5', clip = T)),
               type = getOption("spinner.type", default = 1),
               color = getOption("spinner.color", default = "#0080ff"),
               size = getOption("spinner.size", default = 2),
               color.background = getOption("spinner.color.background", default = "#ffffff"),
               hide.ui = F, proxy.height = if (grepl("height:\\s*\\d", "res1")) NULL else "400px"
             )
           ),
           conditionalPanel(
             condition = "input.waveform == true && input.waveformPeriod.length > 0",
             withSpinner(
               plotOutput(paste0("waveform",tabNum), click = "plot_1click", dblclick = "waveform_2click", brush = brushOpts(id = "waveform_brush", resetOnNew = T, fill = "#2297E6", stroke = "gray62", opacity = '0.5', clip = T)),
               type = getOption("spinner.type", default = 1),
               color = getOption("spinner.color", default = "#0080ff"),
               size = getOption("spinner.size", default = 2),
               color.background = getOption("spinner.color.background", default = "#ffffff"),
               hide.ui = F, proxy.height = if (grepl("height:\\s*\\d", "res1")) NULL else "400px"
             )
           ),
           conditionalPanel(
             condition = "input.printLog == true",
             verbatimTextOutput(paste0("changes_ant",tabNum), placeholder = F),
             verbatimTextOutput(paste0("changes_rec",tabNum), placeholder = F)
           ),
           conditionalPanel(
             condition = "input.printSinfo == true",
             verbatimTextOutput(paste0("changes_ant",tabNum,"s"), placeholder = F),
             verbatimTextOutput(paste0("changes_rec",tabNum,"s"), placeholder = F)
           ),
           conditionalPanel(
             condition = "input.printSoln == true",
             verbatimTextOutput(paste0("changes_ant",tabNum,"so"), placeholder = F),
             verbatimTextOutput(paste0("changes_rec",tabNum,"so"), placeholder = F)
           ),
           conditionalPanel(
             condition = "input.printCustom == true",
             verbatimTextOutput(paste0("changes_ant",tabNum,"c"), placeholder = F),
             verbatimTextOutput(paste0("changes_rec",tabNum,"c"), placeholder = F)
           ),
           conditionalPanel(
             condition = "output.run && input.model.length > 0 || input.midas == true || input.entropy == true || output.pearson",
             htmlOutput(paste0("summary",tabNum))
           ),
           conditionalPanel(
             condition = "input.histogram == true && input.histogramType > 0",
             plotOutput(paste0("hist",tabNum)),
             verbatimTextOutput(paste0("stats",tabNum))
           ),
           conditionalPanel(
             condition = "input.midas == true",
             plotOutput(paste0("midas_hist",tabNum))
           ),
           div(id = paste0("lomb",tabNum), style = "margin-top: 1em",
               conditionalPanel(
                 condition = "input.spectrumOriginal == true || input.spectrumModel == true || input.spectrumResiduals == true || input.spectrumFilter == true || input.spectrumFilterRes == true",
                 withSpinner(
                   plotOutput(paste0("res",tabNum,"_espectral"), click = "lomb_1click", dblclick = dblclickOpts("lomb_2click", delay = 1000), brush = brushOpts(id = "lomb_brush", resetOnNew = T, fill = "#2297E6", stroke = "gray62", opacity = '0.5', clip = T, delay = 600)),
                   type = getOption("spinner.type", default = 1),
                   color = getOption("spinner.color", default = "#0080ff"),
                   size = getOption("spinner.size", default = 2),
                   color.background = getOption("spinner.color.background", default = "#ffffff"),
                   hide.ui = F, proxy.height = if (grepl("height:\\s*\\d", "res1")) NULL else "400px"
                 ),
                 div(style = "width: 15%; margin-left: 85%;",
                   downloadLink(paste0("downloadSpectrum",tabNum), div(id = paste0("downloadlink",tabNum), style = "margin-top:0em; margin-bottom:2em; font-size: 10px; text-align: right;","Get periodogram data"))
                 ),
                 verbatimTextOutput(paste0("lomb",tabNum,"_info"), placeholder = F)
               )
           ),
           div(id = paste0("wl",tabNum),
               conditionalPanel(
                 condition = "input.wavelet == true && input.waveletType.length > 0",
                 withSpinner(
                   plotOutput(paste0("wavelet",tabNum), click = "wavelet_1click"),
                   type = getOption("spinner.type", default = 1),
                   color = getOption("spinner.color", default = "#0080ff"),
                   size = getOption("spinner.size", default = 2),
                   color.background = getOption("spinner.color.background", default = "#ffffff"),
                   hide.ui = F, proxy.height = if (grepl("height:\\s*\\d", "res1")) NULL else "400px"
                 ),
                 verbatimTextOutput(paste0("wavelet",tabNum,"_info"), placeholder = F)
               )
           )
  )
}

# Setting the layout of the model and the residual series for all the components simultaneously
tab3Contents <- function(series) {
  if (series == "3D") {
    tabNum <- 4
    tabName <- uiOutput("tabName4")
  } else if (series == "residuals") {
    tabNum <- 5
    tabName <- uiOutput("tabName5")
  }
  tabPanel(div(style = "font-size: 20px;",tabName), value = tabNum,
           tags$style(type = "text/css", "
                      body {padding-top: 60px;}
                      #side-panel,.navbar-nav {-webkit-user-select: none; -ms-user-select: none; user-select: none;}
                      .shiny-html-output {-webkit-user-select: text; -ms-user-select: text; user-select: text;}
                      "),
           hidden(div(id = paste0("zoomin",tabNum), style = "margin-bottom: -3em; margin-top: 2em; color: #DF536B; font-weight: bold; margin-right: 30px; font-size: 10px; text-align: right; position: relative; z-index: 1;", "Zoomed in")),
           div(style = "margin: 2em 0em -4em 0em; font-weight: bold; font-size: 14px; text-align: left; position: relative; z-index: 1;", uiOutput(paste0("component",tabNum,"1"))),
           withSpinner(
             plotOutput(paste0("plot",tabNum,1), click = paste0("plot",tabNum,"1_1click"), dblclick = dblclickOpts(paste0("plot",tabNum,"1_2click"), delay = 1000), brush = brushOpts(id = paste0("plot",tabNum,"1_brush"), resetOnNew = T, fill = "#DF536B", stroke = "gray62", opacity = '0.5', clip = T)),
             type = getOption("spinner.type", default = 1),
             color = getOption("spinner.color", default = "#0080ff"),
             size = getOption("spinner.size", default = 2),
             color.background = getOption("spinner.color.background", default = "#ffffff"),
             hide.ui = F, proxy.height = if (grepl("height:\\s*\\d", "plot1")) NULL else "400px"
           ),
           div(style = "margin-top: 1.5em;",
               div(style = "margin: 0em 0em -4em 0em; font-weight: bold; font-size: 14px; text-align: left; position: relative; z-index: 1;", uiOutput(paste0("component",tabNum,"2"))),
               withSpinner(
                 plotOutput(paste0("plot",tabNum,2), click = paste0("plot",tabNum,"2_1click"), dblclick = dblclickOpts(paste0("plot",tabNum,"2_2click"), delay = 1000), brush = brushOpts(id = paste0("plot",tabNum,"2_brush"), resetOnNew = T, fill = "#DF536B", stroke = "gray62", opacity = '0.5', clip = T)),
                 type = getOption("spinner.type", default = 1),
                 color = getOption("spinner.color", default = "#0080ff"),
                 size = getOption("spinner.size", default = 2),
                 color.background = getOption("spinner.color.background", default = "#ffffff"),
                 hide.ui = F, proxy.height = if (grepl("height:\\s*\\d", "plot1")) NULL else "400px"
               )
           ),
           div(style = "margin-top: 1.5em;",
               div(style = "margin: 0em 0em -4em 0em; font-weight: bold; font-size: 14px; text-align: left; position: relative; z-index: 1;", uiOutput(paste0("component",tabNum,"3"))),
               withSpinner(
                 plotOutput(paste0("plot",tabNum,3), click = paste0("plot",tabNum,"3_1click"), dblclick = dblclickOpts(paste0("plot",tabNum,"3_2click"), delay = 1000), brush = brushOpts(id = paste0("plot",tabNum,"3_brush"), resetOnNew = T, fill = "#DF536B", stroke = "gray62", opacity = '0.5', clip = T)),
                 type = getOption("spinner.type", default = 1),
                 color = getOption("spinner.color", default = "#0080ff"),
                 size = getOption("spinner.size", default = 2),
                 color.background = getOption("spinner.color.background", default = "#ffffff"),
                 hide.ui = F, proxy.height = if (grepl("height:\\s*\\d", "plot1")) NULL else "400px"
               )
           ),
           verbatimTextOutput(paste0("plot",tabNum,"_info"), placeholder = F)
  )
}

# Source C++ functions on a Windows machine
if (all(c("Rcpp", "RcppArmadillo", "RcppEigen") %in% .packages()) && Sys.info()[['sysname']] == "Windows") {
  cat(file = stderr(), "Compiling C++ functions for Windows\n")
  sourceCpp('functions.cpp', verbose = F)
}

# Shiny/R general options ####
options(shiny.fullstacktrace = T, shiny.maxRequestSize = 60*1024^2, width = 280, max.print = 50)
options(shiny.trace = F)
devmode(F)
options(shiny.autoreload = F, shiny.autoreload.pattern = "app.R")
options(scipen = 4)
Sys.setlocale('LC_ALL','C')
options(shiny.reactlog = F)
Sys.setenv(TZ = "UTC")

# version ####
version <- "SARI septiembre 2025"

# UI ####
ui <- fluidPage(theme = shinytheme("spacelab"),
                mobileDetect('isMobile'),
                useShinyjs(),
                extendShinyjs(text = showPopup, functions = c("showPopup")),
                extendShinyjs(text = checkPopup, functions = c("checkPopup")),
                div( style = "text-align: center; display: flex; flex-direction: column; justify-content: space-between; margin: auto",
                  id = "loading_page",
                  h1(style = "text-align: center; color: #333333; font-weight: bold", "SARI session established."),
                  h1(style = "text-align: center; color: #333333; font-weight: bold", "Loading user interface ..."),
                  div( style = "margin: 0 auto",
                       img(src = "SARI_logo_animated.gif", width = "80%")
                  )
                ),

                # tracker analytics
                # tags$head(includeScript("matomo.js")),

                # bugfix for unsolicited scrolling to top of page when clicking on a fileInput button
                # from https://github.com/rstudio/shiny/issues/3327
                tags$script(
                  HTML(
                    'setTimeout(() => $(".shiny-bound-input[type=\'file\']").css("all","unset").css("display", "none"), 750);'
                  )
                ),

                # Getting the input elements that are solicited during execution
                tags$script(
                  "$(document).on('shiny:inputchanged', function(event) {
                      if (event.name !== 'changed') {
                        Shiny.setInputValue('changed', event.name);
                      }
                    });"
                ),

                # HTTP meta and style header tags
                tags$style(css),
                tags$head(
                  tags$script(src = "ddpcr.js"),
                  tags$head(tags$link(rel = "shortcut icon", href = "favicon.png")),
                  tags$meta(name = "application-name", content = "SARI"),
                  tags$meta(name = "description", content = "Interactive & online GNSS position time series analysis tool"),
                  tags$meta(name = "keywords", content = "SARI,sari,GNSS,gnss,GPS,gps,time,series,analysis"),
                  tags$meta(name = "author", content = "Alvaro Santamaria-Gomez"),
                  tags$meta(name = "viewport", content = "width=device-width, initial-scale=1.0"),
                  tags$html(lang = "en"),
                  tags$style(HTML("
                      .help {color: #2297E6; font-weight: bold;}
                      .UIoption {color: #F5C710; font-weight: bold;}
                      .warning {color: #DF536B; font-weight: bold;}
                      .popover {min-width: 21%; color: #ffffff; background-color: #474949; font-size: medium; position: absolute; z-index: 9999;}
                      .arrow { border-left-color: #8447cf; }
                      .navbar-nav { width: 98%;}
                      .navbar-nav li:nth-child(9) { float: right }
                      .navbar-nav li:nth-child(8) { float: right }
                      .navbar-nav li:nth-child(2) { width: 17%; }
                      .navbar-nav li:nth-child(1) { width: 17%; }
                      .tabbable > .nav > li[class=active] > a { background-color: #333333; color:white; }
                      .shiny-notification { word-break: break-word; color: #ffffff; background-color: #446e9b; font-size: large; font-weight: bold; border: 3px solid #333333; padding: 10px 8px 10px 10px; margin: 2px; }
                      .shiny-notification-warning { color: #ffffff; }
                      .shiny-notification-error { color: #F5C710; }
                      .shiny-notification-message { color: #ffffff; background-color: #446e9b; font-size: large; font-weight: bold; border: 3px solid #333333; padding: 10px 8px 10px 10px; margin: 2px; position:fixed; top: 0; left: calc(28%); width: 71%}
                      .shiny-notification-close:hover { color: #ffffff; }
                      .fa-caret-down { float: right; }
                      .headerIcon { color: #ffffff;}
                      /*.shiny-text-output { text-wrap-mode: wrap;}*/
                      #euler, #gia, #fitType { scroll-margin-top: 150px; }
                      ")
                  ),
                  tags$style(type = "text/css", "#inline label{ display: table-cell; text-align: left; vertical-align: middle; padding: 0px 20px;} #inline .form-group { display: table-row; padding: 0px 20px;}"),
                  tags$style(type = 'text/css', 'form.well { height: 96vh; overflow-y: auto; width: 100%}'),
                  tags$style(".modal-body {padding: 10px}
                     .modal-content  {-webkit-border-radius: 6px !important;-moz-border-radius: 6px !important;border-radius: 6px !important;}
                     .modal-dialog { width: 90%; max-width: 600px; vertical-align: center;}
                     .modal { color: #333333; font-weight: bold; text-align: center; padding-right:10px; padding-top: 24px;}"),

                  # Getting user screen size (from https://stackoverflow.com/questions/36995142/get-the-size-of-the-window-in-shiny)
                  # tags$script('
                  #               var size = [0, 0];
                  #               var tactile = 9;
                  #               $(document).on("shiny:connected", function(e) {
                  #                   size[0] = window.outerWidth;
                  #                   size[1] = window.outerHeight;
                  #                   tactile = navigator.maxTouchPoints;
                  #                   Shiny.onInputChange("tactile", tactile);
                  #                   Shiny.onInputChange("size", size);
                  #               });
                  #               $(window).resize(function(e) {
                  #                   size[0] = window.outerWidth;
                  #                   size[1] = window.outerHeight;
                  #                   Shiny.onInputChange("size", size);
                  #               });
                  #           '),

                  # scrolling a block of the left panel to the center of the screen when it is open
                  tags$script('
                                document.addEventListener("click", function(event) {
                                    if (event.target.parentElement) {
                                            if (event.target.parentElement.getAttribute("data-toggle") === "collapse") {
                                            const id = event.target.parentElement.href.split("#")[1];
                                            const target = document.getElementById(id);
                                            setTimeout(function() {
                                                target.scrollIntoView({ behavior: "smooth", block: "center" });
                                            }, 300);
                                        }
                                    }
                                });
                              '),

                  # closing the overview window if left open on exit
                  tags$script('
                              window.onbeforeunload = closingCode;
                              function closingCode(){
                                  if (typeof overview === "object") {
                                      if (!overview.closed) {
                                          overview.close();
                                      }
                                  }
                                  return null;
                              }
                              '),

                  # update fileInput file names from URL
                  tags$script(HTML(update_series)),
                  tags$script(HTML(update_series2)),
                  tags$script(HTML(update_sitelog)),
                  tags$script(HTML(update_soln)),
                  tags$script(HTML(update_custom)),
                  tags$script(HTML(update_step)),
                  tags$script(HTML(update_step2)),
                  tags$script(HTML(update_trendRef)),

                  # confirm click on refresh button
                  # uiOutput("refresh")

                ),

                hidden(
                  div(id = "main_content",

                      sidebarLayout(position = "left", fluid = T,
                                    div( id = "menu_all",

                                         # Sidebar menu ####
                                         sidebarPanel(
                                           width = 4,
                                           style = "position:fixed;width:inherit;",
                                           id = "side-panel",
                                           bsCollapse(id = "menu", open = c(1), multiple = T,

                                                      # Expandable/collapsible blocks

                                                      # * Input data and format ####
                                                      bsCollapsePanel(value = 1,
                                                                      tags$h4(style = "color:white;", icon("database", class = "headerIcon", lib = "font-awesome"), div(style = "color: white; display: inline; text-decoration-line: inherit;", "Input data and format"),
                                                                              div(style = "float: right; margin-right: 10px;",
                                                                                  helpPopupHeader("This block allows uploading and setting the series format, if necessary, before plotting.<br><br>
                                                                                                  Load a series from a local file using the <span class='UIoption'>browse file</span> button or from a remote file using the <span class='UIoption'>server</span>, <span class='UIoption'>product</span>, and <span class='UIoption'>station</span> options.<br><br>
                                                                                                  When loading a local file, ensure that the <span class='UIoption'>series format</span>, <span class='UIoption'>time units</span>, and <span class='UIoption'>series units</span> are correct before plotting.<br><br>
                                                                                                  Check the series format before plotting with the <span class='UIoption'>show series header</span> option.<br><br>
                                                                                                  Activate or deactivate the series error bars with the <span class='UIoption'>use error bars</span> option.<br><br>
                                                                                                  Reduce the sampling of the series with the <span class='UIoption'>reduce sampling</span> option.<br><br>
                                                                                                  Once the series is plotted, the <span class='UIoption'>show location map</span> will show the geographic location of the station if the coordinates are known or provided.<br><br>
                                                                                                  See more details in the </i><span class='help'>help</span> tab."))
                                                                      ),
                                                                      div(style = "padding: 0px 0px; margin-top:-2em",
                                                                          fluidRow(
                                                                            column(4,
                                                                                   br(),
                                                                                   div(style = "font-weight: bold", "Input series file"),
                                                                                   div(style = "margin-right: -1em", uiOutput("fileSeries1"))
                                                                            ),
                                                                            column(8,
                                                                                   fileInput(inputId = "series", label = "", multiple = F, buttonLabel = "Browse file ...", placeholder = "Empty")
                                                                            )
                                                                          )
                                                                      ),
                                                                      fluidRow(
                                                                        column(4,
                                                                               selectInput(inputId = "server1", label = "Input series server", choices = list("", "RENAG", "FORMATERRE", "SONEL", "IGS", "EUREF", "EPOS", "NGL", "JPL", "EARTHSCOPE", "SIRGAS", "DORIS", "EOSTLS", "PSMSL"), selected = "", multiple = F, selectize = T) |> autoCompleteOff()
                                                                        ),
                                                                        column(4,
                                                                               selectizeInput(inputId = "product1", label = "Product", choices = list(""), selected = "", multiple = F, options = list(maxItems = 1)) |> autoCompleteOff()
                                                                        ),
                                                                        column(4,
                                                                               withBusyIndicatorUI(
                                                                                 uiOutput("showStation1")
                                                                               )
                                                                        )
                                                                      ),
                                                                      conditionalPanel(
                                                                        condition = "output.series1",
                                                                        div(style = "padding: 0px 0px",
                                                                            fluidRow(
                                                                              column(3,
                                                                                     div(style = "font-weight: bold", "Series ID",
                                                                                         helpPopup("This text field shows the GNSS station ID(s) extracted from the file name(s) of the primary and secondary series.<br>
                                                                                                   The GNSS station ID(s) are used for extracting the corresponding metadata.<br>
                                                                                                   Edit the station ID(s) if necessary.", anchor = "series-id"))
                                                                              ),
                                                                              column(6,
                                                                                     textInput(inputId = "ids", label = NULL, value = "") |> autoCompleteOff()
                                                                              )
                                                                            )
                                                                        ),
                                                                        div(style = "padding: 0px 0px; margin-top: 1em",
                                                                            fluidRow(
                                                                              column(4,
                                                                                     div(style = "font-weight: bold", "Series format",
                                                                                         helpPopup("This option sets the series file format. Select 1D if the other file formats are unknown.", anchor = "format"))
                                                                              ),
                                                                              column(8,
                                                                                     radioButtons(inputId = "format", label = NULL, choices = list("NEU/ENU" = 1, "PBO" = 2, "NGL" = 3, "1D" = 4), selected = 1, inline = T, width = "auto") |> autoCompleteOff(),
                                                                              )
                                                                            )
                                                                        ),
                                                                        conditionalPanel(
                                                                          condition = "input.format == 4",
                                                                          fluidRow(
                                                                            column(6,
                                                                                   selectInput(inputId = "separator", label = "Column separation", choices = list("Blank/Tab" = 1, "Comma" = 2, "Semi-colon" = 3), selected = 1, multiple = F, selectize = T) |> autoCompleteOff()
                                                                            ),
                                                                            column(6,
                                                                                   div(style = "font-weight: bold", "Column selection",
                                                                                       helpPopup("Enter the column number for the epochs, data and error bars in the series file.", anchor = "format")
                                                                                   ),
                                                                                   div(style = "margin-top:-1em",
                                                                                       fluidRow(
                                                                                         column(4,
                                                                                                textInput(inputId = "epoch", label = "", value = "1") |> autoCompleteOff()
                                                                                         ),
                                                                                         column(4, offset = -2,
                                                                                                textInput(inputId = "variable", label = "", value = "2") |> autoCompleteOff()
                                                                                         ),
                                                                                         column(4, offset = -2,
                                                                                                textInput(inputId = "errorBar", label = "", value = "3") |> autoCompleteOff()
                                                                                         )
                                                                                       )
                                                                                   )
                                                                            )
                                                                          )
                                                                        ),
                                                                        div(style = "padding: 0px 0px; margin-top:-0em",
                                                                            fluidRow(
                                                                              column(5,
                                                                                     div(style = "margin-top:1em",
                                                                                         radioButtons(inputId = "tunits",
                                                                                                      div("Time units",
                                                                                                          helpPopup("This option sets the units of the time axis.<br>These units define the periods of time in several options.", anchor = "tunits")),
                                                                                                      choices = list("Days" = 1, "Weeks" = 2, "Years" = 3), selected = "", inline = F) |> autoCompleteOff()
                                                                                     ),
                                                                                     div(
                                                                                       radioButtons(inputId = "sunits",
                                                                                                    div("Series units",
                                                                                                        helpPopup("This option sets the units of the variable in the time series.<br>They are used to define the units of the estimated parameters.", anchor = "tunits")),
                                                                                                    choices = list("?" = 0, "m" = 1, "mm" = 2), selected = 0, inline = T) |> autoCompleteOff()
                                                                                     )
                                                                              ),
                                                                              column(6, offset = 1,
                                                                                     checkboxInput(inputId = "sigmas", label = "Use error bars", value = T) |> autoCompleteOff(),
                                                                                     checkboxInput(inputId = "header",
                                                                                                   div("Show series header",
                                                                                                       helpPopup("Before plotting the series, this option shows the first lines of the series file.<br>After plotting the series, this option shows the first lines of the series data in the plot.", anchor = "header")),
                                                                                                   value = F) |> autoCompleteOff(),
                                                                                     conditionalPanel(
                                                                                       condition = "input.header == true",
                                                                                       sliderInput(inputId = "lines", label = "Number of lines", min = 1, max = 50, value = 10)) |> autoCompleteOff()
                                                                              )
                                                                            )
                                                                        ),
                                                                        fluidRow(
                                                                          column(6,
                                                                                 checkboxInput(inputId = "average",
                                                                                               div("Reduce sampling",
                                                                                                   helpPopup("This option computes the moving average of the series for a given non-overlapping time pediod.<br>
                                                                                                             The new sampling period must have a value between the time series sampling and half the time series length.<br>
                                                                                                             The new sampling period must be given in the same units as the time axis of the series.<br>
                                                                                                             Expressions are allowed starting by <span class='UIoption'>=</span>,<br>
                                                                                                             as in <span class='UIoption'>=7/365.25</span>, for a week period in units of years.", anchor = "average")),
                                                                                               value = F) |> autoCompleteOff()
                                                                          ),
                                                                          column(6,
                                                                                 div(style = "padding: 0px 0px; margin-top:1em",
                                                                                     conditionalPanel(
                                                                                       condition = "input.average == true",
                                                                                       textInput(inputId = "step", label = "Averaging time period", value = "") |> autoCompleteOff()
                                                                                     )
                                                                                 )
                                                                          )
                                                                        ),
                                                                        conditionalPanel(
                                                                          condition = "output.data",
                                                                          div(style = "padding: 0px 0px; margin-top: -1em",
                                                                              tags$hr(style = "border-color: #333333; border-top: 1px solid #333333;")
                                                                          ),
                                                                          checkboxInput(inputId = "showmap",
                                                                                        div("Show location map",
                                                                                            helpPopup("If the series header contains the station coordinates, or they are included in a public database, or they are provided by the user in the 'Plate motion model' option, this option will show a map with the station's location together with the tectonic plate boundaries.", anchor = "map")),
                                                                                        value = F) |> autoCompleteOff(),
                                                                          conditionalPanel(
                                                                            condition = "input.showmap == false",
                                                                            div(style = "padding: 0px 0px; margin-top: -1em", htmlOutput("information2"))
                                                                          ),
                                                                          conditionalPanel(
                                                                            condition = "input.showmap == true",
                                                                            fluidRow(
                                                                              column(6,
                                                                                     div(style = "padding: 0px 0px; margin-top: -1em", htmlOutput("information1"))
                                                                              ),
                                                                              column(6,
                                                                                     div(style = "margin-top: -3em;",
                                                                                         withSpinner(
                                                                                           uiOutput("map"),
                                                                                           type = getOption("spinner.type", default = 1),
                                                                                           color = getOption("spinner.color", default = "#0080ff"),
                                                                                           size = getOption("spinner.size", default = 2),
                                                                                           color.background = getOption("spinner.color.background", default = "#ffffff"),
                                                                                           hide.ui = F, proxy.height = if (grepl("height:\\s*\\d", "plot1")) NULL else "175px"
                                                                                         )
                                                                                     )
                                                                              )
                                                                            )
                                                                          )
                                                                        )
                                                                      ),
                                                                      style = "primary"),

                                                      # * Plot controls ####
                                                      bsCollapsePanel(value = 2,
                                                                      tags$h4(style = "color:white;", icon("gamepad", class = "headerIcon", lib = "font-awesome"), div(style = "color: white; display: inline; text-decoration-line: inherit;", "Plot controls"),
                                                                         div(style = "float: right; margin-right: 10px;",
                                                                             helpPopupHeader("This block allows plotting/resetting the time series with the <span class='UIoption'>plot</span> and <span class='UIoption'>reset</span> buttons.<br><br>
                                                                                             The <span class='UIoption'>overview</span> button opens a new browser window containing a plot of the three coordinate components, if available.<br><br>
                                                                                             Outliers can be excluded manually or automatically with the <span class='UIoption'>toggle</span> and <span class='UIoption'>auto toggle</span> buttons.<br><br>
                                                                                             The removed outliers can be restored with the <span class='UIoption'>reset toggle</span> button.<br><br>
                                                                                             The <span class='UIoption'>truncate</span> option removes either the beginning and/or end of the series, or points above and/or below the limits.<br><br>
                                                                                             The <span class='UIoption'>remove period</span> option removes all the points between two provided epochs.<br><br>
                                                                                             The <span class='UIoption'>all components</span> option allows removing the outliers from all the components (if more than one) simultaneously or for each component individually.<br><br>
                                                                                             The <span class='UIoption'>permanent</span> option allows deleting permanently (i.e., not possible to be restored) the next outliers flagged to be toggled or truncated.<br><br>
                                                                                             The <span class='UIoption'>include in file</span> option keeps the excluded outliers in the downloaded results file as commented lines.<br><br>
                                                                                             The <span class='UIoption'>scrolling</span> option enables/disables the vertical scrolling of the left panel.<br><br>
                                                                                             See more details in the <span class='help'>help</span> tab."))
                                                                      ),
                                                                      fluidRow(
                                                                        column(2, style = 'padding:0px 1px 0px 10px;', align = "left",
                                                                               actionButton(inputId = "plot", label = "Plot", icon = icon("eye", class = NULL, lib = "font-awesome"), style = "font-size: small")
                                                                        ),
                                                                        column(2, style = 'padding:0px 1px 0px 1px;', align = "left",
                                                                               actionButton(inputId = "reset", label = "Reset", icon = icon("trash", class = NULL, lib = "font-awesome"), style = "font-size: small; color: #F5C710; font-weight: bold")
                                                                        ),
                                                                        column(3, style = 'padding:0px 1px 0px 1px;', align = "right",
                                                                               actionButton(inputId = "plotAll", label = "Overview", icon = icon("bars", class = NULL, lib = "font-awesome"), style = "font-size: small")
                                                                        ),
                                                                        column(2, style = 'padding:0px 1px 0px 1px;', align = "right",
                                                                               actionButton(inputId = "remove", label = "Toggle", icon =  icon("ban", class = NULL, lib = "font-awesome"), style = "font-size: small")
                                                                        ),
                                                                        column(3, style = 'padding:0px 10px 0px 0px;', align = "right",
                                                                               actionButton(inputId = "delete_excluded", label = "Reset toggle", icon = icon("backward", class = NULL, lib = "font-awesome"), style = "font-size: small")
                                                                        )
                                                                      ),
                                                                      div(style = "padding: 0px 0px; margin-top:1em",
                                                                          fluidRow(
                                                                            column(4,
                                                                                   checkboxInput(inputId = "cut",
                                                                                                 div("Truncate", style = "font-weight: bold",
                                                                                                     helpPopup("This option either reduces the time axis of the series by removing all points before and/or after the provided epochs, or removes points above and/or below the provided limits.", anchor = "cut")),
                                                                                                 value = F) |> autoCompleteOff()
                                                                            ),
                                                                            conditionalPanel(
                                                                              condition = "input.cut == true",
                                                                              column(4,
                                                                                     textInput(inputId = "cutStart", label = "Before", value = "") |> autoCompleteOff()
                                                                              ),
                                                                              column(4,
                                                                                     textInput(inputId = "cutEnd", label = "After", value = "") |> autoCompleteOff()
                                                                              )
                                                                            )
                                                                          ),
                                                                          conditionalPanel(
                                                                            condition = "input.cut == true",
                                                                            fluidRow(
                                                                              column(4, offset = 4,
                                                                                     textInput(inputId = "cutAbove", label = "Above", value = "") |> autoCompleteOff()
                                                                              ),
                                                                              column(4,
                                                                                     textInput(inputId = "cutBelow", label = "Below", value = "") |> autoCompleteOff()
                                                                              )
                                                                            )
                                                                          )
                                                                      ),
                                                                      fluidRow(
                                                                        column(4, style = "padding-right: 0;",
                                                                               checkboxInput(inputId = "strip",
                                                                                             div("Remove period", style = "font-weight: bold",
                                                                                                 helpPopup("This option removes all the points from the series between the provided epochs.", anchor = "strip")),
                                                                                             value = F) |> autoCompleteOff()
                                                                        ),
                                                                        conditionalPanel(
                                                                          condition = "input.strip == true",
                                                                          column(4,
                                                                                 textInput(inputId = "stripStart", label = "From", value = "") |> autoCompleteOff()
                                                                          ),
                                                                          column(4,
                                                                                 textInput(inputId = "stripEnd", label = "To", value = "") |> autoCompleteOff()
                                                                          )
                                                                        )
                                                                      ),
                                                                      div(style = "padding: 0px 0px; margin-top:1em",
                                                                          fluidRow(
                                                                            column(4,
                                                                                   textInput(inputId = "thresholdRes",
                                                                                             div("Residual",
                                                                                                 helpPopup("Enter the threshold to delete all the points with larger absolute residual.", anchor = "threshold")),
                                                                                             value = NULL) |> autoCompleteOff()
                                                                            ),
                                                                            column(4, style = "padding:0px 10px 0px 0px;", align = "left",
                                                                                   textInput(inputId = "thresholdResN",
                                                                                             div("Norm. residual",
                                                                                                 helpPopup("Enter the threshold to delete all the points with larger normalized absolute residual.<br>
                                                                                                           The residuals values are normalized by their error bars.", anchor = "threshold")),
                                                                                             value = NULL) |> autoCompleteOff()
                                                                            ),
                                                                            column(4, style = "padding:0px 10px 0px 0px; margin-top:1.75em", align = "right",
                                                                                   actionButton(inputId = "removeAuto", label = "Auto toggle", icon =  icon("car", class = NULL, lib = "font-awesome"), style = "font-size: small")
                                                                            )
                                                                          )
                                                                      ),
                                                                      fluidRow(
                                                                        column(3,
                                                                               div(style = "font-weight: bold", "Plot type")
                                                                        ),
                                                                        column(8,
                                                                               radioButtons(inputId = "symbol", label = NULL, choices = list("Points" = 0, "Lines" = 1, "Points & Lines" = 2), selected = 0, inline = T) |> autoCompleteOff()
                                                                        )
                                                                      ),
                                                                      div(style = "font-weight: bold", "Plot options"),
                                                                      fluidRow(
                                                                        column(4, style = "padding-right: 0;",
                                                                               checkboxInput(inputId = "remove3D",
                                                                                             div("All components", align = "right",
                                                                                                 helpPopup("This option allows toggling or deleting the points from all the coordinate components at the same time or separately.", anchor = "3d")),
                                                                                             value = T) |> autoCompleteOff()
                                                                        ),
                                                                        column(4,
                                                                               checkboxInput(inputId = "permanent",
                                                                                             div("Permanent", align = "right",
                                                                                                 helpPopup("This option deletes the points from the series permanently.<br>
                                                                                                           Deleted points cannot be restored, unless the series are reset and reloaded.", anchor = "permanent")),
                                                                                             value = F) |> autoCompleteOff()
                                                                        ),
                                                                        column(4,
                                                                               checkboxInput(inputId = "add_excluded",
                                                                                             div("Include in file", align = "right",
                                                                                                 helpPopup("This option includes the removed points in the downloaded file as commented lines.", anchor = "excluded")),
                                                                                             value = F) |> autoCompleteOff()
                                                                        )
                                                                      ),
                                                                      fluidRow(
                                                                        column(4,
                                                                               checkboxInput(inputId = "overflow",
                                                                                             div("Scrolling",
                                                                                                 helpPopup("This options enables or disables the vertical scrolling of the left panel.<br>
                                                                                                           When the scrolling is disabled, the user can take a screenshot of the full web page.", anchor = "scrolling")),
                                                                                             value = T) |> autoCompleteOff()
                                                                        )
                                                                      ),
                                                                      style = "primary"),

                                                      # * Ancillary information ####
                                                      bsCollapsePanel(value = 3,
                                                                      tags$h4(style = "color:white;", icon("upload", class = "headerIcon", lib = "font-awesome"), div(style = "color: white; display: inline; text-decoration-line: inherit;", "Ancillary information"),
                                                                              div(style = "float: right; margin-right: 10px;",
                                                                                  helpPopupHeader("This block allows for the uploading of files containing complementary information or metadata related to the analysis of the series.<br><br>
                                                                                                  The user can upload any of the following possibilities:<br>
                                                                                                  a <span class='UIoption'>SARI</span> file,<br>
                                                                                                  a GNSS <span class='UIoption'>sitelog</span>,<br>
                                                                                                  a GAMIT-like <span class='UIoption'>station.info</span> file,<br>
                                                                                                  an IGS-like <span class='UIoption'>soln</span> file,<br>
                                                                                                  a <span class='UIoption'>custom</span> offset file,<br>
                                                                                                  a <span class='UIoption'>secondary</span> series.<br>
                                                                                                  The secondary series can be <span class='UIoption'>shown</span> next to the primary series or used to either <span class='UIoption'>correct</span> the primary series, <span class='UIoption'>average</span> both the primary and secondary series or <span class='UIoption'>merge</span> both series into one.<br><br>
                                                                                                  Two model predictions can also be plotted or used to correct the primary series: a <span class='UIoption'>plate motion</span> model and a <span class='UIoption'>GIA</span> model.<br><br>
                                                                                                  See more details in the <span class='help'>help</span> tab."))
                                                                      ),

                                                                      ## % SARI model ####
                                                                      conditionalPanel(
                                                                        condition = "output.tab3D == true",
                                                                        div(style = "padding: 0px 0px; margin-top:0em",
                                                                            fluidRow(
                                                                              column(6,
                                                                                     div(style = "font-weight: bold", "Load SARI model",
                                                                                         helpPopup("This option allows loading a file with the model fitted in a previous analysis with SARI.", anchor = "ancillary-information")
                                                                                     )
                                                                              )
                                                                            )
                                                                        ),
                                                                        br(),
                                                                        div(style = "text-align: center;", "Select the tab of a coordinate component to enable this option."),
                                                                        br()
                                                                      ),
                                                                      conditionalPanel(
                                                                        condition = "output.tab3D == false",
                                                                        div(style = "padding: 0px 0px; margin-top:0em",
                                                                            fluidRow(
                                                                              column(6,
                                                                                     div(style = "font-weight: bold", "Load SARI model",
                                                                                         helpPopup("This option allows loading a file with the model fitted in a previous analysis with SARI.", anchor = "ancillary-information")
                                                                                     )
                                                                              )
                                                                            ),
                                                                            fluidRow(
                                                                              column(8,
                                                                                     fileInput(inputId = "loadSARI", label = NULL, multiple = F, buttonLabel = "Browse file ...", placeholder = "Empty")
                                                                              )
                                                                            )
                                                                        )
                                                                      ),

                                                                      ## % sitelog ####
                                                                      div(style = "padding: 0px 0px; margin-top:0em",
                                                                          fluidRow(
                                                                            column(6,
                                                                                   div(style = "font-weight: bold", "Input log file",
                                                                                       helpPopup("This option allows loading an IGS-like sitelog file.", anchor = "notes-on-the-equipment-change-logs")
                                                                                   )
                                                                            ),
                                                                            column(6, align = "right",
                                                                                   uiOutput("sitelog")
                                                                            )
                                                                          ),
                                                                          fluidRow(
                                                                            column(8,
                                                                                   fileInput(inputId = "log", label = NULL, multiple = F, buttonLabel = "Browse file ...", placeholder = "Empty")
                                                                            ),
                                                                            column(4,
                                                                                   div(style = "padding: 0px 0px; margin-top:0em",
                                                                                       conditionalPanel(
                                                                                         condition = "output.log",
                                                                                         checkboxInput(inputId = "traceLog", label = "Plot changes", value = F) |> autoCompleteOff(),
                                                                                         checkboxInput(inputId = "printLog", label = "List changes", value = F) |> autoCompleteOff()
                                                                                       )
                                                                                   )
                                                                            )
                                                                          )
                                                                      ),

                                                                      ## % station.info ####
                                                                      div(style = "padding: 0px 0px; margin-top:-1em",
                                                                          fluidRow(
                                                                            column(6,
                                                                                   div(style = "font-weight: bold", "Input station.info file",
                                                                                       helpPopup("This option allows loading a GAMIT/GLOBK station.info file.", anchor = "notes-on-the-equipment-change-logs")
                                                                                   )
                                                                            ),
                                                                            column(6, align = "right",
                                                                                   uiOutput("station.info")
                                                                            )
                                                                          ),
                                                                          fluidRow(
                                                                            column(8,
                                                                                   fileInput(inputId = "sinfo", label = NULL, multiple = F, buttonLabel = "Browse file ...", placeholder = "Empty")
                                                                            ),
                                                                            column(4,
                                                                                   div(style = "padding: 0px 0px; margin-top:0em",
                                                                                       conditionalPanel(
                                                                                         condition = "output.sinfo",
                                                                                         checkboxInput(inputId = "traceSinfo", label = "Plot changes", value = F) |> autoCompleteOff(),
                                                                                         checkboxInput(inputId = "printSinfo", label = "List changes", value = F) |> autoCompleteOff()
                                                                                       )
                                                                                   )
                                                                            )
                                                                          )
                                                                      ),

                                                                      ## % soln ####
                                                                      div(style = "padding: 0px 0px; margin-top:-1em",
                                                                          fluidRow(
                                                                            column(6,
                                                                                   div(style = "font-weight: bold", "Input soln file",
                                                                                       helpPopup("This option allows loading an IGS-like soln file.", anchor = "notes-on-the-equipment-change-logs")
                                                                                   )
                                                                            ),
                                                                            column(6, align = "right",
                                                                                   uiOutput("solnFile")
                                                                            )
                                                                          ),
                                                                          fluidRow(
                                                                            column(8,
                                                                                   fileInput(inputId = "soln", label = NULL, multiple = F, buttonLabel = "Browse file ...", placeholder = "Empty")
                                                                            ),
                                                                            column(4,
                                                                                   div(style = "padding: 0px 0px; margin-top:0em",
                                                                                       conditionalPanel(
                                                                                         condition = "output.soln",
                                                                                         checkboxInput(inputId = "traceSoln", label = "Plot changes", value = F) |> autoCompleteOff(),
                                                                                         checkboxInput(inputId = "printSoln", label = "List changes", value = F) |> autoCompleteOff()
                                                                                       )
                                                                                   )
                                                                            )
                                                                          )
                                                                      ),

                                                                      ## % Custom ####
                                                                      div(style = "padding: 0px 0px; margin-top:-1em",
                                                                          fluidRow(
                                                                            column(6,
                                                                                   div(style = "font-weight: bold", "Input custom offset file",
                                                                                       helpPopup("This option allows loading a user-defined offset list.", anchor = "notes-on-the-equipment-change-logs")
                                                                                   )
                                                                            ),
                                                                            column(6, align = "right",
                                                                                   uiOutput("customFile")
                                                                            )
                                                                          ),
                                                                          fluidRow(
                                                                            column(8,
                                                                                   fileInput(inputId = "custom", label = NULL, multiple = F, buttonLabel = "Browse file ...", placeholder = "Empty")
                                                                            ),
                                                                            column(4,
                                                                                   div(style = "padding: 0px 0px; margin-top:0em",
                                                                                       conditionalPanel(
                                                                                         condition = "output.custom",
                                                                                         checkboxInput(inputId = "traceCustom", label = "Plot changes", value = F) |> autoCompleteOff(),
                                                                                         checkboxInput(inputId = "printCustom", label = "List changes", value = F) |> autoCompleteOff()
                                                                                       )
                                                                                   )
                                                                            )
                                                                          )
                                                                      ),

                                                                      ## % Secondary series ####
                                                                      div(style = "padding: 0px 0px; margin-top:0em",
                                                                          fluidRow(
                                                                            column(8,
                                                                                   div(style = "margin-right:0; padding-right:0",
                                                                                       fileInput(inputId = "series2",
                                                                                                 div("Secondary series file",
                                                                                                     helpPopup("This option allows loading a secondary series to be shown next to, subtracted from or averaged with the primary series.", anchor = "notes-on-the-secondary-series")),
                                                                                                 multiple = T, buttonLabel = "Browse file ...", placeholder = "Empty")
                                                                                   )
                                                                            ),
                                                                            column(3, align = "left", offset = 1,
                                                                                   div(style = "padding: 0px 0px; margin-top:+1.9em",
                                                                                       actionButton(inputId = "swap", label = "Swap", icon = icon("refresh", class = NULL, lib = "font-awesome"), style = "font-size: small")
                                                                                   )
                                                                            )
                                                                          ),
                                                                          fluidRow(
                                                                            column(4,
                                                                                   div(style = "margin-bottom: -1em",
                                                                                       selectInput(inputId = "server2", label = "Secondary server", choices = list("", "RENAG", "FORMATERRE", "SONEL", "IGS", "EUREF", "EPOS", "NGL", "JPL", "EARTHSCOPE", "SIRGAS", "DORIS", "EOSTLS", "PSMSL"), selected = "", multiple = F, selectize = T) |> autoCompleteOff()
                                                                                   )
                                                                            ),
                                                                            column(4,
                                                                                   div(style = "margin-bottom: -1em",
                                                                                       selectizeInput(inputId = "product2", label = "Product", choices = list(""), selected = "", multiple = F, options = list(maxItems = 1)) |> autoCompleteOff()
                                                                                   )
                                                                            ),
                                                                            column(4,
                                                                                   withBusyIndicatorUI(
                                                                                     div(style = "margin-bottom: -1em",
                                                                                         uiOutput("showStation2")
                                                                                     )
                                                                                   )
                                                                            )
                                                                          ),
                                                                          conditionalPanel(
                                                                            condition = "output.series2",
                                                                            fluidRow(
                                                                              column(12,
                                                                                     radioButtons(inputId = "optionSecondary", 
                                                                                                  div("Secondary series option",
                                                                                                      helpPopup("None: hides the secondary series<br/>
                                                                                                                Show: plots the secondary series underneath the primary series, in green color on the right axis<br/>
                                                                                                                Correct: subtracts the secondary series from the primary series at common epochs<br/>
                                                                                                                Average: averages the secondary and primary series at common epochs<br/>
                                                                                                                Merge: adds the secondary series to the primary series at uncommon epochs.", anchor = "notes-on-the-secondary-series")),
                                                                                                  choices = list("None" = 0, "Show" = 1, "Correct" = 2, "Average" = 3, "Merge" = 4), selected = 0, inline = T, width = NULL) |> autoCompleteOff()
                                                                              )
                                                                            )
                                                                          ),
                                                                          conditionalPanel(
                                                                            condition = "output.series2",
                                                                            fluidRow(
                                                                              column(8,
                                                                                     # radioButtons(inputId = "typeSecondary", label = NULL, choices = list("Original" = 1, "Residual" = 2), selected = 1, inline = T) |> autoCompleteOff(),
                                                                                     radioButtons(inputId = "format2", label = "Secondary series format", choices = list("NEU/ENU" = 1, "PBO" = 2, "NGL" = 3, "1D" = 4), selected = 1, inline = T, width = "auto") |> autoCompleteOff(),
                                                                                     fluidRow(
                                                                                       column(6,
                                                                                              textInput(inputId = "scaleFactor",
                                                                                                        div("Scale factor",
                                                                                                            helpPopup("Enter the multiplicative coefficient to scale the y-axis of the secondary series.", anchor = "notes-on-the-secondary-series")),
                                                                                                        value = "1") |> autoCompleteOff()
                                                                                       ),
                                                                                       column(6,
                                                                                              div( # dummy div to avoid sendCustomMessage to update the previous scaleFactor and the next step2 values both at the same time (maybe a bug?)
                                                                                              textInput(inputId = "step2",
                                                                                                        div("Averaging",
                                                                                                            helpPopup("This option computes the moving average of the secondary series for a given non-overlapping time pediod between the time series sampling and half the time series length.<br>
                                                                                                                      The period must be given in the same units as the time axis in the series.<br>
                                                                                                                      Expressions are allowed starting by <span class='UIoption'>=</span>, as in <span class='UIoption'>=7/365.25</span>.", anchor = "notes-on-the-secondary-series")),
                                                                                                        value = "") |> autoCompleteOff()
                                                                                              )
                                                                                       )
                                                                                     ),
                                                                                     div(style = "margin-right: -1em", uiOutput("fileSeries2"))
                                                                              ),
                                                                              column(4,
                                                                                     div(style = "padding: 0px 0px; margin-top:1em",
                                                                                         checkboxInput(inputId = "fullSeries",
                                                                                                       div("Full series",
                                                                                                           helpPopup("This option shows the total length of the secondary series.<br>
                                                                                                                     By default, only the common time period with the primary series will be shown.", anchor = "notes-on-the-secondary-series")),
                                                                                                       value = F) |> autoCompleteOff(),
                                                                                         checkboxInput(inputId = "sameScale",
                                                                                                       div("Same scale",
                                                                                                           helpPopup("This option forces the y-axis of the secondary series on the right of the plot to have the same scale as the y-axis of the primary series on the left.", anchor = "notes-on-the-secondary-series")),
                                                                                                       value = F) |> autoCompleteOff(),
                                                                                         checkboxInput(inputId = "same_axis",
                                                                                                       div("Same axis",
                                                                                                           helpPopup("This option forces the y-axis of the secondary series on the right of the plot to be the same as the y-axis of the primary series on the left.", anchor = "notes-on-the-secondary-series")),
                                                                                                       value = F) |> autoCompleteOff(),
                                                                                         checkboxInput(inputId = "ne",
                                                                                                       div(HTML("N @ E"),
                                                                                                           helpPopup("This option swaps the columns of the North and East components of the secondary series to match those of the primary series.", anchor = "notes-on-the-secondary-series")),
                                                                                                       value = F) |> autoCompleteOff()
                                                                                     )
                                                                              )
                                                                            )
                                                                          ),
                                                                          fluidRow(
                                                                            conditionalPanel(
                                                                              condition = "input.format2 == 4 && output.series2 == true",
                                                                              column(6,
                                                                                     selectInput(inputId = "separator2", label = "Column separation", choices = list("Blank/Tab" = 1, "Comma" = 2, "Semi-colon" = 3), selected = 1, multiple = F, selectize = T) |> autoCompleteOff()
                                                                              ),
                                                                              column(6,
                                                                                     div(style = "font-weight: bold", "Column selection",
                                                                                         helpPopup("Enter the column number for the epochs, data and the errorbars, respectively, of the secondary series.", anchor = NULL)
                                                                                     ),
                                                                                     div(style = "margin-top:-1em",
                                                                                         fluidRow(
                                                                                           column(4,
                                                                                                  textInput(inputId = "epoch2", label = "", value = "1") |> autoCompleteOff()
                                                                                           ),
                                                                                           column(4, offset = -2,
                                                                                                  textInput(inputId = "variable2", label = "", value = "2") |> autoCompleteOff()
                                                                                           ),
                                                                                           column(4, offset = -2,
                                                                                                  textInput(inputId = "errorBar2", label = "", value = "3") |> autoCompleteOff()
                                                                                           )
                                                                                         )
                                                                                     )
                                                                              )
                                                                            )
                                                                          )
                                                                      ),

                                                                      div(style = "padding: 0px 0px; margin-top: -1em",
                                                                          tags$hr(style = "border-color: #333333; border-top: 1px solid #333333;")
                                                                      ),

                                                                      ## % Euler ####
                                                                      fluidRow(
                                                                        column(6,
                                                                               checkboxInput(inputId = "euler",
                                                                                             div(style = "font-weight: bold", "Plate motion model",
                                                                                                 helpPopup("This option shows or removes a plate motion model at the series location given the parameters of an Euler pole.", anchor = "notes-on-the-plate-motion-model")),
                                                                                             value = F) |> autoCompleteOff()
                                                                               ),
                                                                        column(6,
                                                                               conditionalPanel(
                                                                                 condition = "input.euler == true",
                                                                                 div(style = "margin-top: 0.75em",
                                                                                     radioButtons(inputId = "eulerType", label = NULL, choices = list("None" = 0, "Show" = 1, "Remove" = 2), selected = 0, inline = T, width = NULL, choiceNames = NULL,  choiceValues = NULL) |> autoCompleteOff()
                                                                                 )
                                                                               )
                                                                        )
                                                                      ),
                                                                      fluidRow(
                                                                        conditionalPanel(
                                                                          condition = "input.euler == true && input.format == 1",
                                                                          column(6,
                                                                                 div("Select NEU or ENU format:")
                                                                          ),
                                                                          column(6,
                                                                                 radioButtons(inputId = "neuenu", label = NULL, choices = list("ENU" = 1, "NEU" = 2), selected = 1, inline = T, width = NULL, choiceNames = NULL, choiceValues = NULL) |> autoCompleteOff()
                                                                          )
                                                                        ),
                                                                        conditionalPanel(
                                                                          condition = "input.euler == true && input.format == 4",
                                                                          column(6,
                                                                                 div("Select component of 1D series:")
                                                                          ),
                                                                          column(6,
                                                                                 radioButtons(inputId = "neu1D", label = NULL, choices = list("North" = 1, "East" = 2, "Up" = 3), selected = 1, inline = T, width = NULL, choiceNames = NULL, choiceValues = NULL) |> autoCompleteOff()
                                                                          )
                                                                        )
                                                                      ),
                                                                      conditionalPanel(
                                                                        condition = "input.euler == true",
                                                                        fluidRow(
                                                                          column(6,
                                                                                 selectInput(inputId = "plateModel", label = "Select a plate model", choices = list("", "ITRF2020", "NNR-MORVEL56", "NNR-GSRM"), selected = "", multiple = F, selectize = T) |> autoCompleteOff(),
                                                                                 div(style = "margin-top: -1em", uiOutput("pmm"))
                                                                          ),
                                                                          column(6,
                                                                                 selectizeInput(inputId = "plate", label = "Plate name", choices = list(""), selected = "", multiple = F, options = list(maxItems = 1)) |> autoCompleteOff()
                                                                          )
                                                                        ),
                                                                        fluidRow(
                                                                          div(style = "margin-top: 2em",
                                                                              column(8,
                                                                                     div(style = "font-weight: bold", "Upload a custom plate model",
                                                                                         helpPopup("This option allows loading a file with a list of station coordinates and their associated Euler poles.", anchor = "notes-on-the-plate-motion-model")
                                                                                     )
                                                                              ),
                                                                              column(4, align = "right",
                                                                                     tags$a(href = "euler.txt", "Show file example", target = "_blank")
                                                                              )
                                                                          )
                                                                        ),
                                                                        fileInput(inputId = "eulers", label = NULL, multiple = F, buttonLabel = "Browse file ...", placeholder = "Empty"),
                                                                        fluidRow(
                                                                          column(6,
                                                                                 div("Station coordinates", helpPopup("Option 1: Cartesian coordinates in the same units as the series.<br>
                                                                                                                      Option 2: geographic coordinates in decimal degrees.", anchor = "notes-on-the-plate-motion-model"))
                                                                          ),
                                                                          column(6, align = "right",
                                                                                 radioButtons(inputId = "station_coordinates", label = NULL, choices = list("Cartesian" = 1, "Geographic" = 2), selected = 1, inline = T, width = NULL, choiceNames = NULL,  choiceValues = NULL) |> autoCompleteOff()
                                                                          )
                                                                        ),
                                                                        fluidRow(
                                                                          conditionalPanel(
                                                                            condition = "input.station_coordinates == 1",
                                                                            column(4,
                                                                                   textInput(inputId = "station_x", label = "Station X", value = "") |> autoCompleteOff()
                                                                            ),
                                                                            column(4, offset = -2,
                                                                                   textInput(inputId = "station_y", label = "Station Y", value = "") |> autoCompleteOff()
                                                                            ),
                                                                            column(4, offset = -2,
                                                                                   textInput(inputId = "station_z", label = "Station Z", value = "") |> autoCompleteOff()
                                                                            )
                                                                          ),
                                                                          conditionalPanel(
                                                                            condition = "input.station_coordinates == 2",
                                                                            column(4,
                                                                                   textInput(inputId = "station_lat", label = "Station latitude", value = "") |> autoCompleteOff()
                                                                            ),
                                                                            column(4, offset = -2,
                                                                                   textInput(inputId = "station_lon", label = "Station longitude", value = "") |> autoCompleteOff()
                                                                            )
                                                                          )
                                                                        ),
                                                                        conditionalPanel(
                                                                          condition = "output.series2",
                                                                          fluidRow(
                                                                            column(6,
                                                                                   div("Secondary station coordinates", helpPopup("Option 1: Cartesian coordinates in the same units as the series.<br>
                                                                                                                                  Option 2: geographic coordinates in decimal degrees.", anchor = "notes-on-the-plate-motion-model"))
                                                                            ),
                                                                            column(6, align = "right",
                                                                                   radioButtons(inputId = "station_coordinates2", label = NULL, choices = list("Cartesian" = 1, "Geographic" = 2), selected = 1, inline = T, width = NULL, choiceNames = NULL,  choiceValues = NULL) |> autoCompleteOff()
                                                                            )
                                                                          ),
                                                                          fluidRow(
                                                                            conditionalPanel(
                                                                              condition = "input.station_coordinates2 == 1",
                                                                              column(4,
                                                                                     textInput(inputId = "station_x2", label = "Station X", value = "") |> autoCompleteOff()
                                                                              ),
                                                                              column(4, offset = -2,
                                                                                     textInput(inputId = "station_y2", label = "Station Y", value = "") |> autoCompleteOff()
                                                                              ),
                                                                              column(4, offset = -2,
                                                                                     textInput(inputId = "station_z2", label = "Station Z", value = "") |> autoCompleteOff()
                                                                              )
                                                                            ),
                                                                            conditionalPanel(
                                                                              condition = "input.station_coordinates2 == 2",
                                                                              column(4,
                                                                                     textInput(inputId = "station_lat2", label = "Station latitude", value = "") |> autoCompleteOff()
                                                                              ),
                                                                              column(4, offset = -2,
                                                                                     textInput(inputId = "station_lon2", label = "Station longitude", value = "") |> autoCompleteOff()
                                                                              )
                                                                            )
                                                                          )
                                                                        ),
                                                                        fluidRow(
                                                                          column(6,
                                                                                 div("Euler's pole", helpPopup("Option 1: Cartesian rotation rates in decimal degrees/Ma.<br>
                                                                                                               Option 2: geographic pole position in decimal degrees and rotation rate in decimal degrees/Ma.", anchor = "notes-on-the-plate-motion-model"))
                                                                          ),
                                                                          column(6, align = "right",
                                                                                 radioButtons(inputId = "pole_coordinates", label = NULL, choices = list("Cartesian" = 1, "Geographic" = 2), selected = 1, inline = T, width = NULL, choiceNames = NULL,  choiceValues = NULL) |> autoCompleteOff()
                                                                          )
                                                                        ),
                                                                        fluidRow(
                                                                          conditionalPanel(
                                                                            condition = "input.pole_coordinates == 1",
                                                                            column(4,
                                                                                   textInput(inputId = "pole_x", label = "Pole rotation X", value = "") |> autoCompleteOff()
                                                                            ),
                                                                            column(4, offset = -2,
                                                                                   textInput(inputId = "pole_y", label = "Pole rotation Y", value = "") |> autoCompleteOff()
                                                                            ),
                                                                            column(4, offset = -2,
                                                                                   textInput(inputId = "pole_z", label = "Pole rotation Z", value = "") |> autoCompleteOff()
                                                                            )
                                                                          ),
                                                                          conditionalPanel(
                                                                            condition = "input.pole_coordinates == 2",
                                                                            column(4,
                                                                                   textInput(inputId = "pole_lat", label = "Pole latitude", value = "") |> autoCompleteOff()
                                                                            ),
                                                                            column(4, offset = -2,
                                                                                   textInput(inputId = "pole_lon", label = "Pole longitude", value = "") |> autoCompleteOff()
                                                                            ),
                                                                            column(4, offset = -2,
                                                                                   textInput(inputId = "pole_rot", label = "Pole rotation", value = "") |> autoCompleteOff()
                                                                            )
                                                                          )
                                                                        )
                                                                      ),

                                                                      ## % GIA ####
                                                                      fluidRow(
                                                                        column(4,
                                                                               checkboxInput(inputId = "gia",
                                                                                             div(style = "font-weight: bold", "GIA",
                                                                                                 helpPopup("This option shows or removes the vertical land motion predicted by a Glacial Isostatic Adjustment model at the series location.", anchor = "notes-on-the-gia-model")),
                                                                                             value = F) |> autoCompleteOff()
                                                                        )
                                                                      ),
                                                                      conditionalPanel(
                                                                        condition = "input.gia == true",
                                                                        fluidRow(
                                                                          column(6,
                                                                                 selectInput(inputId = "giaModel", label = "Select a GIA model", choices = list("", "Caron & Ivins", "ICE-6G-VM5a", "ICE-6G-ANU"), selected = "", multiple = F, selectize = T) |> autoCompleteOff()
                                                                          ),
                                                                          column(6,
                                                                                 conditionalPanel(
                                                                                   condition = "input.gia == true",
                                                                                   div(style = "margin-top: 2em",
                                                                                       radioButtons(inputId = "giaType", label = NULL, choices = list("None" = 0, "Show" = 1, "Remove" = 2), selected = 0, inline = T, width = NULL, choiceNames = NULL,  choiceValues = NULL) |> autoCompleteOff()
                                                                                   )
                                                                                 )
                                                                          )
                                                                        )
                                                                      ),
                                                                      conditionalPanel(
                                                                        condition = "input.gia == true",
                                                                        fluidRow(
                                                                          column(6,
                                                                                 textInput(inputId = "giaTrend",
                                                                                           div(style = "font-weight: bold", "Vertical land motion trend",
                                                                                               helpPopup("This text field shows the vertical land motion trend in the same units as the series.<br>
                                                                                                         Modify the value of the VLM trend if necessary.", anchor = "notes-on-the-gia-model")),
                                                                                           value = "") |> autoCompleteOff()
                                                                          ),
                                                                          conditionalPanel(
                                                                            condition = "output.series2",
                                                                            column(6,
                                                                                   textInput(inputId = "giaTrend2", "Secondary", value = "") |> autoCompleteOff()
                                                                            )
                                                                          )
                                                                        )
                                                                      ),

                                                                      style = "primary"),

                                                      # * Fit controls ####
                                                      bsCollapsePanel(value = 4,
                                                                      tags$h4(style = "color:white;", icon("wand-magic-sparkles", class = "headerIcon", lib = "font-awesome"), div(style = "color: white; display: inline; text-decoration-line: inherit;", "Fit controls"),
                                                                              div(style = "float: right; margin-right: 10px;",
                                                                                  helpPopupHeader("This block allows fitting a model to the time series using:<br>
                                                                                                  Weighted <span class='UIoption'>least squares</span> (LS)<br>
                                                                                                  <span class='UIoption'>Extended Kalman filter</span> (EKF)<br>
                                                                                                  <span class='UIoption'>Unscented Kalman filter</span> (UKF)<br><br>
                                                                                                  The fitted model may include any combination of <span class='UIoption'>linear</span> trend, higher-degree <span class='UIoption'>polynomial</span>, <span class='UIoption'>offsets</span>, <span class='UIoption'>sinusoidal</span> periodic signals, <span class='UIoption'>exponential</span> and <span class='UIoption'>logarithmic</span> decays.<br><br>
                                                                                                  The <span class='UIoption'>segmented model</span> option allows fitting the selected model components to different segments of the series separated by break epochs.<br><br>
                                                                                                  The <span class='UIoption'>click & collect</span> option automatically adds the points clicked on the series plots to the list of offset epochs.<br><br>
                                                                                                  The <span class='UIoption'>search discontinuities</span> button provides an automatic guesstimate of the location of probable discontinuities in the series.<br><span class='warning'>WARNING</span>: long computation time.<br><br>
                                                                                                  The <span class='UIoption'>check offsets</span> option checks the significance of the offset magnitudes with respect to colored noise.<br><br>
                                                                                                  See more details in the <span class='help'>help</span> tab."))
                                                                      ),
                                                                      conditionalPanel(
                                                                        condition = "output.tab3D == true",
                                                                        br(),
                                                                        div(style = "text-align: center;", "Select the tab of a coordinate component to enable the fitting options.")
                                                                      ),
                                                                      conditionalPanel(
                                                                        condition = "output.tab3D == false",
                                                                        div(style = "padding: 0px 0px; margin-top:0em",
                                                                            fluidRow(
                                                                              column(3,
                                                                                     div(style = "font-weight: bold", "Fit type")
                                                                              ),
                                                                              column(8,
                                                                                     radioButtons(inputId = "fitType", label = NULL, choices = list("None" = 0, "LS" = 1, "KF" = 2), selected = 0, inline = T) |> autoCompleteOff()
                                                                              )
                                                                            ),
                                                                            conditionalPanel(
                                                                              condition = "input.fitType == 2",
                                                                              fluidRow(
                                                                                column(3,
                                                                                       div(style = "font-weight: bold", "KF type")
                                                                                ),
                                                                                column(5,
                                                                                       radioButtons(inputId = "kf", label = NULL, choices = list("EKF" = 1, "UKF" = 2), selected = 2, inline = T) |> autoCompleteOff()
                                                                                ),
                                                                                column(width = 4, offset = 0, style = "margin-top:-2em; padding: 0px 40px 0px 0px", align = "right",
                                                                                       withBusyIndicatorUI(
                                                                                         actionButton(inputId = "runKF", label = " Run KF", icon = icon("filter", class = NULL, lib = "font-awesome"), style = "font-size: small")
                                                                                       )
                                                                                )
                                                                              ),
                                                                              checkboxInput(inputId = "errorm",
                                                                                            div("Optimize measurement noise",
                                                                                                helpPopup("This option estimates the measurement noise within the given bounds and with respect to the provided process noise.<br>
                                                                                                        <span class='warning'>WARNING</span>: several iterations of the KF fit.", anchor = "notes-on-the-kalman-filter")),
                                                                                            value = F) |> autoCompleteOff(),
                                                                              fluidRow(
                                                                                column(4,
                                                                                       textInput(inputId = "ObsError",
                                                                                                 div("Measurement noise",
                                                                                                     helpPopup("Enter the measurement standard deviation in the same units as the series.<br>
                                                                                                             If left empty, an approximate value will be used.", anchor = "notes-on-the-kalman-filter")),
                                                                                                 value = "") |> autoCompleteOff()
                                                                                ),
                                                                                conditionalPanel(
                                                                                  condition = "input.errorm == true",
                                                                                  column(4, align = "left",
                                                                                         textInput(inputId = "min_optirange",
                                                                                                   div("Min bound",
                                                                                                       helpPopup("Lower & upper bounds of the measurement standard deviation in the same units as the series.", anchor = "notes-on-the-kalman-filter")),
                                                                                                   value = "") |> autoCompleteOff()
                                                                                  ),
                                                                                  column(4,
                                                                                         textInput(inputId = "max_optirange", label = "Max bound", value = "") |> autoCompleteOff()
                                                                                  )
                                                                                )
                                                                              )
                                                                            )
                                                                        ),
                                                                        conditionalPanel(
                                                                          condition = "input.fitType == 1 || input.fitType == 2",
                                                                          div(style = "padding: 0px 0px; margin-top:0.0em",
                                                                              tags$div(class = "header", checked = NA,
                                                                                       tags$h4(icon("puzzle-piece", class = NULL, lib = "font-awesome"), "Select model components")
                                                                              )
                                                                          ),
                                                                          div(style = "padding: 0px 0px; margin-top:-1em",
                                                                              checkboxGroupInput(inputId = "model", label = "", choices = list("Linear","Polynomial","Sinusoidal","Offset","Exponential","Logarithmic"), selected = NULL, inline = T) |> autoCompleteOff()
                                                                          ),
                                                                          conditionalPanel(
                                                                            condition = "input.fitType == 1",
                                                                            div(style = "margin-top:1.5em",
                                                                                checkboxInput(inputId = "breaking",
                                                                                              div("Segmented model",
                                                                                                  helpPopup("This option enables the fit of a segmented or 'broken-stick' model.", anchor = "notes-on-the-model-breaks")),
                                                                                              value = F) |> autoCompleteOff()
                                                                            )
                                                                          ),
                                                                          conditionalPanel(
                                                                            condition = "input.fitType == 1 && input.breaking == true",
                                                                            fluidRow(
                                                                              column(12,
                                                                                     textInput(inputId = "breakEpoch",
                                                                                               div("Break epochs",
                                                                                                   helpPopup("Enter a comma-separated list of break epochs in the same time units as the series.", anchor = "notes-on-the-model-breaks")),
                                                                                               value = "") |> autoCompleteOff(),
                                                                              )
                                                                            )
                                                                          ),

                                                                          ## % Linear fit ####
                                                                          conditionalPanel(
                                                                            condition = "input.model.indexOf('Linear') != -1",
                                                                            div(style = "padding: 0px 0px; margin-top:0em",
                                                                                tags$hr(style = "border-color: #333333; border-top: 1px solid #333333;")
                                                                            ),
                                                                            fluidRow(
                                                                              conditionalPanel(
                                                                                condition = "input.fitType == 1",
                                                                                column(6,
                                                                                       textInput(inputId = "trendRef",
                                                                                                 div("Ref. epoch rate",
                                                                                                     helpPopup("Enter the reference epoch for the rate. If empty, the mean data epoch will be used.", anchor = NULL)),
                                                                                                 value = "") |> autoCompleteOff()
                                                                                     ),
                                                                                column(6,
                                                                                       conditionalPanel(
                                                                                         condition = "input.breaking == true",
                                                                                         radioButtons(inputId = "trendType",
                                                                                                      div("Rate type",
                                                                                                          helpPopup("Select the type of linear trend fitted to the series.", anchor = "notes-on-the-model-breaks")),
                                                                                                      choices = list("Continuous" = 0, "Segmented" = 1), selected = 0, inline = F) |> autoCompleteOff()
                                                                                       )
                                                                                )
                                                                              ),
                                                                              conditionalPanel(
                                                                                condition = "input.fitType == 2",
                                                                                column(6,
                                                                                       textInput(inputId = "TrendDev",
                                                                                                 div("Rate process noise",
                                                                                                     helpPopup("Enter the rate variation (standard deviation) for each observation.<br>
                                                                                                             If a null value is used, a constant linear trend will be estimated.", anchor = "notes-on-the-kalman-filter")),
                                                                                                 value = "0.0") |> autoCompleteOff()
                                                                                )
                                                                              )
                                                                            ),
                                                                            conditionalPanel(
                                                                              condition = "input.fitType == 2",
                                                                              fluidRow(
                                                                                column(6,
                                                                                       conditionalPanel(
                                                                                         condition = "input.fitType == 2",
                                                                                         textInput(inputId = "Intercept0",
                                                                                                   div("Initial intercept",
                                                                                                       helpPopup("Enter the initial state value for the intercept. If empty, an approximate value will be used.", anchor = "notes-on-the-kalman-filter")),
                                                                                                   value = "") |> autoCompleteOff()
                                                                                       )
                                                                                ),
                                                                                column(6,
                                                                                       textInput(inputId = "eIntercept0",
                                                                                                 div("Initial intercept error",
                                                                                                     helpPopup("Enter the initial state uncertainty (standard deviation) for the intercept.<br>
                                                                                                             If empty, an approximate value will be used.", anchor = "notes-on-the-kalman-filter")),
                                                                                                 value = "") |> autoCompleteOff()
                                                                                )
                                                                              ),
                                                                              fluidRow(
                                                                                column(6,
                                                                                       conditionalPanel(
                                                                                         condition = "input.fitType == 2",
                                                                                         textInput(inputId = "Trend0",
                                                                                                   div("Initial rate",
                                                                                                       helpPopup("Enter the initial state value for the rate. If empty, an approximate value will be used.", anchor = "notes-on-the-kalman-filter")),
                                                                                                   value = "") |> autoCompleteOff()
                                                                                       )
                                                                                ),
                                                                                column(6,
                                                                                       textInput(inputId = "eTrend0",
                                                                                                 div("Initial rate error",
                                                                                                     helpPopup("Enter the initial state uncertainty (standard deviation) for the rate.<br>
                                                                                                             If empty, an approximate value will be used.", anchor = "notes-on-the-kalman-filter")),
                                                                                                 value = "") |> autoCompleteOff()
                                                                                )
                                                                              )
                                                                            )
                                                                          ),

                                                                          ## % Sinusoidal fit ####
                                                                          conditionalPanel(
                                                                            condition = "input.model.indexOf('Sinusoidal') != -1",
                                                                            div(style = "padding: 0px 0px; margin-top:0em",
                                                                                tags$hr(style = "border-color: #333333; border-top: 1px solid #333333;")
                                                                            ),
                                                                            textInput(inputId = "period",
                                                                                      div("Sinusoidal periods",
                                                                                          helpPopup("Enter a comma-separated list of periods. Each period ended by<br/>
                                                                                                  d : for days<br/>
                                                                                                  w : for weeks<br/>
                                                                                                  y : for years.<br/>
                                                                                                  Add xN at the end to fit up to N higher harmonics, i.e., 1yx2 includes annual and semi-annual periods.", anchor = "notes-on-the-sinusoidal-fitting")),
                                                                                      value = "1y") |> autoCompleteOff(),
                                                                            fluidRow(
                                                                              column(12,
                                                                                     div(style = "font-weight: bold", "Draconitic harmonics",
                                                                                         helpPopup("This option automatically adds four draconitic harmonics for each selected GNSS constellation to the sinusoidal model component.", anchor = "notes-on-the-sinusoidal-fitting"))
                                                                              )
                                                                            ),
                                                                            fluidRow(
                                                                              column(3,
                                                                                     checkboxInput(inputId = "GPSdrac", label = "GPS", value = F) |> autoCompleteOff()
                                                                              ),
                                                                              column(3,
                                                                                     checkboxInput(inputId = "GALdrac", label = "Galileo", value = F) |> autoCompleteOff()
                                                                              ),
                                                                              column(3,
                                                                                     checkboxInput(inputId = "BDSdrac", label = "BeiDou", value = F) |> autoCompleteOff()
                                                                              ),
                                                                              column(3,
                                                                                     checkboxInput(inputId = "GLOdrac", label = "GLONASS", value = F) |> autoCompleteOff()
                                                                              )
                                                                            ),
                                                                            fluidRow(
                                                                              conditionalPanel(
                                                                                condition = "input.fitType == 1 && input.breaking == true",
                                                                                column(4,
                                                                                       div(style = "font-weight: bold; margin-top: 0.75em", "Sinusoid type",
                                                                                           helpPopup("Select the type of sinusoid fitted to the series.", anchor = "notes-on-the-model-breaks"))
                                                                                ),
                                                                                column(8,
                                                                                       div(style = "padding: 0px 0px; margin-top: -0.75em",
                                                                                           radioButtons(inputId = "sinusoidType", label = "", choices = list("Continuous" = 0, "Segmented" = 1), selected = 0, inline = T) |> autoCompleteOff()
                                                                                       )
                                                                                )
                                                                              )
                                                                            ),
                                                                            fluidRow(
                                                                              column(6,
                                                                                     textInput(inputId = "periodRef",
                                                                                               div("Ref. epoch periods",
                                                                                                   helpPopup("Enter the reference epoch for the phase of the sinusoidal periods. If empty, the mean data epoch will be used", anchor = "notes-on-the-sinusoidal-fitting")),
                                                                                               value = "")
                                                                              ),
                                                                              conditionalPanel(
                                                                                condition = "input.fitType == 2",
                                                                                column(6,
                                                                                       textInput(inputId = "S0",
                                                                                                 div("Initial amplitude",
                                                                                                     helpPopup("Enter the initial state value for both sine & cosine amplitudes. If empty, an approximate value will be used.", anchor = "notes-on-the-kalman-filter")),
                                                                                                 value = "") |> autoCompleteOff()
                                                                                )
                                                                              )
                                                                            ),
                                                                            conditionalPanel(
                                                                              condition = "input.fitType == 2",
                                                                              fluidRow(
                                                                                column(6,
                                                                                       textInput(inputId = "SinusoidalDev",
                                                                                                 div("Amplitude process noise",
                                                                                                     helpPopup("Enter the sine/cosine amplitude variation (standard deviation) for each observation and for each period.<br>
                                                                                                             If a null value is used, a constant sinusoidal oscillation will be estimated.", anchor = "notes-on-the-kalman-filter")),
                                                                                                 value = "0.0") |> autoCompleteOff()
                                                                                ),
                                                                                column(6,
                                                                                       textInput(inputId = "eS0",
                                                                                                 div("Initial amplitude error",
                                                                                                     helpPopup("Enter the initial state uncertainty (standard deviation) for sine & cosine amplitudes.<br>
                                                                                                             If empty, an approximate value will be used.", anchor = "notes-on-the-kalman-filter")),
                                                                                                 value = "") |> autoCompleteOff()
                                                                                )
                                                                              ),
                                                                              tags$div(id = "inline",
                                                                                       radioButtons(inputId = "SineCosine",
                                                                                                    div("Amplitude process noise on",
                                                                                                        helpPopup("This option allows choosing between varying the sine amplitude only or varying both the sine & cosine amplitudes independently.", anchor = "notes-on-the-kalman-filter")),
                                                                                                    choices = list("Sine" = 1, "Sine & Cosine" = 2), selected = 2, inline = T) |> autoCompleteOff()
                                                                              )
                                                                            )
                                                                          ),

                                                                          ## % Offset fit ####
                                                                          conditionalPanel(
                                                                            condition = "input.model.indexOf('Offset') != -1",
                                                                            div(style = "padding: 0px 0px; margin-top:0em",
                                                                                tags$hr(style = "border-color: #333333; border-top: 1px solid #333333;")
                                                                            ),
                                                                            textInput(inputId = "offsetEpoch",
                                                                                      div("Offset epochs",
                                                                                          helpPopup("Enter a comma-separated list of offsets in the same time units as the series.", anchor = NULL)),
                                                                                      value = "") |> autoCompleteOff(),
                                                                            checkboxInput(inputId = "click2collect",
                                                                                          div("Click & collect",
                                                                                              helpPopup("Click on the series or residual plots to automatically add the epochs to the list of offsets.", anchor = NULL)),
                                                                                          value = F) |> autoCompleteOff(),
                                                                            conditionalPanel(
                                                                              condition = "input.fitType == 2",
                                                                              fluidRow(
                                                                                column(6,
                                                                                       textInput(inputId = "O0",
                                                                                                 div("Initial offset",
                                                                                                     helpPopup("Enter the initial state value for the offsets. If empty, an approximate value will be used.", anchor = "notes-on-the-kalman-filter")),
                                                                                                 value = "") |> autoCompleteOff()
                                                                                ),
                                                                                column(6,
                                                                                       textInput(inputId = "eO0",
                                                                                                 div("Initial offset error",
                                                                                                     helpPopup("Enter the initial state uncertainty (standard deviation) for the offsets. If empty, an approximate value will be used.", anchor = "notes-on-the-kalman-filter")),
                                                                                                 value = "") |> autoCompleteOff()
                                                                                )
                                                                              )
                                                                            ),
                                                                            fluidRow(
                                                                              column(6,
                                                                                     withBusyIndicatorUI(
                                                                                       actionButton(inputId = "search", label = "Search discontinuities", icon = icon("magnifying-glass", class = NULL, lib = "font-awesome"), style = "font-size: small")
                                                                                     )
                                                                              ),
                                                                              column(6,
                                                                                     sliderInput("segmentLength",
                                                                                                 div("Minimum segment",
                                                                                                     helpPopup("This option sets the minimum segment size given as % of the series length.", anchor = "notes-on-the-discontinuity-detection")),
                                                                                                 min = 0.1, max = 50, value = 10, step = 1, round = 0, ticks = F, animate = F, width = NULL, sep = "", pre = NULL, post = NULL, timeFormat = NULL, timezone = NULL, dragRange = TRUE) |> autoCompleteOff()
                                                                              )
                                                                            ),
                                                                            htmlOutput("offsetFound"),
                                                                            fluidRow(
                                                                              column(5,
                                                                                     checkboxInput(inputId = "verif_offsets",
                                                                                                   div("Check offsets",
                                                                                                       helpPopup("This option estimates the probability that the estimated offsets are not generated by random noise variations.<br/>
                                                                                                               If the probability is < 95 %, offsets may be generated by random noise variations.", anchor = "notes-on-the-offset-verification"),
                                                                                                       value = F)) |> autoCompleteOff()
                                                                              ),
                                                                              conditionalPanel(
                                                                                condition = "input.verif_offsets == true",
                                                                                column(3, style = "margin-top:1em;", align = "left",
                                                                                       radioButtons(inputId = "typeColor", NULL, choices = list("FL/RW" = 1, "PL" = 2), selected = 2, inline = F, width = "auto") |> autoCompleteOff()
                                                                                ),
                                                                                column(width = 4, style = "margin-top:1em; padding: 0px 0px 0px 0px", align = "left",
                                                                                       withBusyIndicatorUI(
                                                                                         actionButton(inputId = "runVerif", label = "Run verification", icon = icon("shuffle", class = NULL, lib = "font-awesome"), style = "font-size: small")
                                                                                       )
                                                                                )
                                                                              )
                                                                            ),
                                                                            conditionalPanel(
                                                                              condition = "input.verif_offsets == true",
                                                                              fluidRow(
                                                                                column(4,
                                                                                       textInput(inputId = "verif_white",
                                                                                                 div("White noise",
                                                                                                     helpPopup("Enter the standard deviation of the expected white noise in the series.", anchor = "notes-on-the-offset-verification")),
                                                                                                 value = "") |> autoCompleteOff()
                                                                                ),
                                                                                conditionalPanel(
                                                                                  condition = "input.typeColor == 2",
                                                                                  column(4,
                                                                                         textInput(inputId = "verif_pl",
                                                                                                   div("Power-law",
                                                                                                       helpPopup("Enter the stardard deviation of the expected power-law noise in the series.", anchor = "notes-on-the-offset-verification")),
                                                                                                   value = "") |> autoCompleteOff()
                                                                                  ),
                                                                                  column(4,
                                                                                         textInput(inputId = "verif_k",
                                                                                                   div("Spectral index",
                                                                                                       helpPopup("Enter the spectral index of the expected power-law noise in the series.", anchor = "notes-on-the-offset-verification")),
                                                                                                   value = "") |> autoCompleteOff()
                                                                                  )
                                                                                ),
                                                                                conditionalPanel(
                                                                                  condition = "input.typeColor == 1",
                                                                                  column(4,
                                                                                         textInput(inputId = "verif_fl",
                                                                                                   div("Flicker noise",
                                                                                                       helpPopup("Enter the stardard deviation of the expected flicker noise in the series.", anchor = "notes-on-the-offset-verification")),
                                                                                                   value = "") |> autoCompleteOff()
                                                                                  ),
                                                                                  column(4,
                                                                                         textInput(inputId = "verif_rw",
                                                                                                   div("Random Walk",
                                                                                                       helpPopup("Enter the stardard deviation of the expected random walk noise in the series.", anchor = "notes-on-the-offset-verification")),
                                                                                                   value = "") |> autoCompleteOff()
                                                                                  )
                                                                                )
                                                                              )
                                                                            ),
                                                                            conditionalPanel(
                                                                              condition = "output.verifhelp",
                                                                              fluidRow(
                                                                                div(style = "padding: 0px 30px;",
                                                                                    htmlOutput("verif", inline = T)
                                                                                )
                                                                              )
                                                                            )
                                                                          ),

                                                                          ## % Exponential fit ####
                                                                          conditionalPanel(
                                                                            condition = "input.model.indexOf('Exponential') != -1",
                                                                            div(style = "padding: 0px 0px; margin-top:0em",
                                                                                tags$hr(style = "border-color: #333333; border-top: 1px solid #333333;")
                                                                            ),
                                                                            textInput(inputId = "ExponenRef",
                                                                                      div("Ref. time exponential",
                                                                                          helpPopup("Enter a comma-separated lisf of the starting epoch of the exponential decays.", anchor = "notes-on-the-exponential/logarithmic-decay-fitting")),
                                                                                      value = "") |> autoCompleteOff(),
                                                                            fluidRow(
                                                                              column(6,
                                                                                     textInput(inputId = "E0",
                                                                                               div("Initial constant",
                                                                                                   helpPopup("Enter the initial value for the asymptotic offset for each decay.<br>
                                                                                                           If empty, an approximate value will be used.", anchor = "notes-on-the-exponential/logarithmic-decay-fitting")),
                                                                                               value = "") |> autoCompleteOff()
                                                                              ),
                                                                              column(6,
                                                                                     textInput(inputId = "TE0",
                                                                                               div("Initial decay rate",
                                                                                                   helpPopup("Enter the initial value for each exponential decay rate. If empty, an approximate value will be used.", anchor = "notes-on-the-exponential/logarithmic-decay-fitting")),
                                                                                               value = "") |> autoCompleteOff()
                                                                              )
                                                                            ),
                                                                            conditionalPanel(
                                                                              condition = "input.fitType == 2",
                                                                              fluidRow(
                                                                                column(6,
                                                                                       textInput(inputId = "eE0",
                                                                                                 div("Initial constant error",
                                                                                                     helpPopup("Enter the initial state uncertainty (standard deviation) for the asymptotic offsets.<br>
                                                                                                             If empty, an approximate value will be used.", anchor = "notes-on-the-exponential/logarithmic-decay-fitting")),
                                                                                                 value = "") |> autoCompleteOff()
                                                                                ),
                                                                                column(6,
                                                                                       textInput(inputId = "eTE0",
                                                                                                 div("Initial decay rate error",
                                                                                                     helpPopup("Enter the initial state uncertainty (standard deviation) for the exponential decay rates.<br>
                                                                                                             If empty, an approximate value will be used.", anchor = "notes-on-the-exponential/logarithmic-decay-fitting")),
                                                                                                 value = "") |> autoCompleteOff()
                                                                                )
                                                                              )
                                                                            )
                                                                          ),

                                                                          ## % Logarithmic fit ####
                                                                          conditionalPanel(
                                                                            condition = "input.model.indexOf('Logarithmic') != -1",
                                                                            div(style = "padding: 0px 0px; margin-top:0em",
                                                                                tags$hr(style = "border-color: #333333; border-top: 1px solid #333333;")
                                                                            ),
                                                                            textInput(inputId = "LogariRef",
                                                                                      div("Ref. time logarithmic",
                                                                                          helpPopup("Enter a comma-separated lisf of the starting epoch for each logarithmic decay.", anchor = "notes-on-the-exponential/logarithmic-decay-fitting")),
                                                                                      value = "") |> autoCompleteOff(),
                                                                            fluidRow(
                                                                              column(6,
                                                                                     textInput(inputId = "L0",
                                                                                               div("Initial constant",
                                                                                                   helpPopup("Enter the initial value for the asymptotic offset of each decay.<br>
                                                                                                           If empty, an approximate value will be used.", anchor = "notes-on-the-exponential/logarithmic-decay-fitting")),
                                                                                               value = "") |> autoCompleteOff()
                                                                              ),
                                                                              column(6,
                                                                                     textInput(inputId = "TL0",
                                                                                               div("Initial decay rate",
                                                                                                   helpPopup("Enter the initial value for the logarithmic decay rates. If empty, an approximate value will be used.", anchor = "notes-on-the-exponential/logarithmic-decay-fitting")),
                                                                                               value = "") |> autoCompleteOff()
                                                                              )
                                                                            ),
                                                                            conditionalPanel(
                                                                              condition = "input.fitType == 2",
                                                                              fluidRow(
                                                                                column(6,
                                                                                       textInput(inputId = "eL0",
                                                                                                 div("Initial constant error",
                                                                                                     helpPopup("Enter the initial state uncertainty (standard deviation) for the asymptotic offsets.<br>
                                                                                                             If empty, an approximate value will be used.", anchor = "notes-on-the-exponential/logarithmic-decay-fitting")),
                                                                                                 value = "") |> autoCompleteOff()
                                                                                ),
                                                                                column(6,
                                                                                       textInput(inputId = "eTL0",
                                                                                                 div("Initial decay rate error",
                                                                                                     helpPopup("Enter the initial state uncertainty (standard deviation) for the logarithmic decay rates.<br>
                                                                                                             If empty, an approximate value will be used.", anchor = "notes-on-the-exponential/logarithmic-decay-fitting")),
                                                                                                 value = "") |> autoCompleteOff()
                                                                                )
                                                                              )
                                                                            )
                                                                          ),

                                                                          ## % Polynomial fit ####
                                                                          conditionalPanel(
                                                                            condition = "input.model.indexOf('Polynomial') != -1",
                                                                            div(style = "padding: 0px 0px; margin-top:0em",
                                                                                tags$hr(style = "border-color: #333333; border-top: 1px solid #333333;")
                                                                            ),
                                                                            fluidRow(
                                                                              column(6,
                                                                                     textInput(inputId = "PolyRef",
                                                                                               div("Ref. epoch polynomial",
                                                                                                   helpPopup("Enter the reference epoch for the polynomial. If empty, the rate reference epoch or the mean data epoch will be used.", anchor = NULL)),
                                                                                               value = "") |> autoCompleteOff()
                                                                              ),
                                                                              column(6,
                                                                                     textInput(inputId = "PolyCoef",
                                                                                               div("Polynomial degree",
                                                                                                   helpPopup("Enter the polynomial degree between 2 and 20.<br>
                                                                                                           The degrees 0 (intercept) and 1 (rate) are estimated with the linear component.", anchor = NULL)),
                                                                                               value = "") |> autoCompleteOff()
                                                                              )
                                                                            ),
                                                                            fluidRow(
                                                                              conditionalPanel(
                                                                                condition = "input.fitType == 1 && input.breaking == true",
                                                                                column(4,
                                                                                       div(style = "font-weight: bold; margin-top: 0.75em", "Polynomial type",
                                                                                           helpPopup("Select the type of polynomial fitted to the series.", anchor = "notes-on-the-model-breaks"))
                                                                                ),
                                                                                column(8,
                                                                                       div(style = "padding: 0px 0px; margin-top: -0.75em",
                                                                                           radioButtons(inputId = "polyType", label = "", choices = list("Continuous" = 0, "Segmented" = 1), selected = 0, inline = T) |> autoCompleteOff()
                                                                                       )
                                                                                )
                                                                              )
                                                                            ),
                                                                            conditionalPanel(
                                                                              condition = "input.fitType == 2",
                                                                              fluidRow(
                                                                                column(6,
                                                                                       textInput(inputId = "P0",
                                                                                                 div("Initial polynomial",
                                                                                                     helpPopup("Enter the initial state value for each polynomial coefficient. If empty, an approximate value will be used.", anchor = NULL)),
                                                                                                 value = "") |> autoCompleteOff()
                                                                                ),
                                                                                column(6,
                                                                                       textInput(inputId = "eP0",
                                                                                                 div("Initial polynomial error",
                                                                                                     helpPopup("Enter the initial state uncertainty (standard deviation) for each polynomial coefficient.<br>
                                                                                                             If empty, an approximate value will be used.", anchor = NULL)),
                                                                                                 value = "") |> autoCompleteOff()
                                                                                )
                                                                              )
                                                                            )
                                                                          )
                                                                        )
                                                                      ),
                                                                      style = "primary"),

                                                      # * Additional fit ####
                                                      bsCollapsePanel(value = 5,
                                                                      tags$h4(style = "color:white;", icon("magnifying-glass-plus", class = "headerIcon", lib = "font-awesome"), div(style = "color: white; display: inline; text-decoration-line: inherit;", "Additional fit"),
                                                                              div(style = "float: right; margin-right: 10px;",
                                                                                  helpPopupHeader("This block allows for additional time series fitting and analysis, including:<br><br>
                                                                                                  Two linear trend estimators using the <span class='UIoption'>MIDAS</span> and the <span class='UIoption'>minimum entropy</span> methods.<br><br>
                                                                                                  The <span class='UIoption'>histogram</span> of the original, model, residual or smoothed series, and a stationarity assessment.<br><br>
                                                                                                  The non-parametric <span class='UIoption'>periodic waveform</span> of any non-sinusoidal periodic variation.<br><br>
                                                                                                  The amplitude or power <span class='UIoption'>periodogram</span> of the original data, the fitted model, the model residuals, the smoothed values, or the smoother residuals.<br><br>
                                                                                                  The pseudo discrete <span class='UIoption'>wavelet</span> transform of the original series, the fitted model, the model residuals, the smoothed values, or the smoother residuals.<br><span class='warning'>WARNING</span>: long computation time.<br><br>
                                                                                                  The Vondr&#225;k <span class='UIoption'>band-pass smoother</span> of the original or residual series.<br><br>
                                                                                                  The MLE <span class='UIoption'>noise analysis</span> to estimate the temporal correlation of the model/filter residuals.<br><span class='warning'>WARNING</span>: long computation time.<br><br>
                                                                                                  See more details in the <span class='help'>help</span> tab."))
                                                                      ),

                                                                      conditionalPanel(
                                                                        condition = "output.tab3D == true",
                                                                        br(),
                                                                        div(style = "text-align: center;", "Select the tab of a coordinate component to enable the fitting options.")
                                                                      ),
                                                                      conditionalPanel(
                                                                        condition = "output.tab3D == false",

                                                                        ## % MIDAS ####
                                                                        fluidRow(
                                                                          column(12,
                                                                                 checkboxInput(inputId = "midas",
                                                                                               div("MIDAS",
                                                                                                   helpPopup("This option estimates the linear trend value with the Median Interannual Difference Adjusted for Skewness algorithm.", anchor = "notes-on-the-midas-trend-estimates")),
                                                                                               value = F) |> autoCompleteOff()
                                                                          )
                                                                        ),

                                                                        ## % Entropy ####
                                                                        fluidRow(
                                                                          column(12,
                                                                                 checkboxInput(inputId = "entropy",
                                                                                               div("Minimum entropy",
                                                                                                   helpPopup("This option estimates the linear rate value with the differential minimum Shannon entropy algorithm.", anchor = "notes-on-the-minimum-entropy")),
                                                                                               value = F) |> autoCompleteOff(),
                                                                                 conditionalPanel(
                                                                                   condition = "input.entropy == true",
                                                                                   textInput(inputId = "offsetEpoch.entropy",
                                                                                             div("Offset epochs (entropy)",
                                                                                                 helpPopup("Enter a comma-separated list of offset epochs.", anchor = "notes-on-the-minimum-entropy")),
                                                                                             value = "") |> autoCompleteOff()
                                                                                 )
                                                                          )
                                                                        ),

                                                                        ## % Histogram ####
                                                                        fluidRow(
                                                                          column(12,
                                                                                 checkboxInput(inputId = "histogram", label = "Histogram", value = F) |> autoCompleteOff()
                                                                          )
                                                                        ),
                                                                        conditionalPanel(
                                                                          condition = "input.histogram == true",
                                                                          radioButtons(inputId = "histogramType", label = NULL, choices = list("None" = 0, "Original" = 1, "Model" = 2, "Model res." = 3, "Filter" = 4, "Filter res." = 5), selected = 0, inline = T, width = NULL, choiceNames = NULL,  choiceValues = NULL) |> autoCompleteOff(),
                                                                          div(style = "padding: 0px 0px; margin-top:0em",
                                                                              tags$hr(style = "border-color: #333333; border-top: 1px solid #333333;")
                                                                          )
                                                                        ),

                                                                        ## % Waveform ####
                                                                        fluidRow(
                                                                          column(6,
                                                                                 checkboxInput(inputId = "waveform",
                                                                                               div("Periodic waveform",
                                                                                                   helpPopup("This option estimates a periodic waveform that does not have a sinusoidal shape.", anchor = "notes-on-the-waveform")),
                                                                                               value = F) |> autoCompleteOff()
                                                                          ),
                                                                          column(6,
                                                                                 conditionalPanel(
                                                                                   condition = "input.waveform == true",
                                                                                   textInput(inputId = "waveformPeriod",
                                                                                             div("Period",
                                                                                                 helpPopup("Enter the waveform period in the same units as the series.<br>
                                                                                                         The waveform period must be larger than twice the average sampling period and smaller than half the total period of the series.", anchor = "notes-on-the-waveform")),
                                                                                             value = "") |> autoCompleteOff()
                                                                                 )
                                                                          )
                                                                        ),
                                                                        conditionalPanel(
                                                                          condition = "input.waveform == true",
                                                                          fluidRow(
                                                                            column(6,
                                                                                   div(style = "margin-top:-4em",
                                                                                       checkboxInput(inputId = "correct_waveform",
                                                                                                     div("Remove from series",
                                                                                                         helpPopup("This option removes the estimated periodic waveform from the original series before the model fit.", anchor = "notes-on-the-waveform")),
                                                                                                     value = F) |> autoCompleteOff()
                                                                                   )
                                                                            )
                                                                          ),
                                                                          div(style = "padding: 0px 0px; margin-top:-1em",
                                                                              tags$hr(style = "border-color: #333333; border-top: 1px solid #333333;")
                                                                          )
                                                                        ),

                                                                        ## % Periodogram ####
                                                                        fluidRow(
                                                                          column(5,
                                                                                 checkboxInput(inputId = "spectrum",
                                                                                               div("Periodogram",
                                                                                                   helpPopup("This option estimates the Lomb-Scargle periodogram.", anchor = "notes-on-the-periodogram")),
                                                                                               value = F) |> autoCompleteOff()
                                                                          ),
                                                                          column(6, offset = 1,
                                                                                 div(style = "margin-top:0.6em;",
                                                                                     conditionalPanel(
                                                                                       condition = "input.spectrum == true",
                                                                                       radioButtons(inputId = "spectrumType", label = NULL, choices = list("Amplitude" = 0, "Power" = 1), selected = 0, inline = T, width = NULL, choiceNames = NULL,  choiceValues = NULL) |> autoCompleteOff()
                                                                                     )
                                                                                 )
                                                                          )
                                                                        ),
                                                                        conditionalPanel(
                                                                          condition = "input.spectrum == true",
                                                                          fluidRow(
                                                                            column(2,
                                                                                   checkboxInput(inputId = "spectrumOriginal", label = "Original", value = F) |> autoCompleteOff()
                                                                            ),
                                                                            column(2,
                                                                                   checkboxInput(inputId = "spectrumModel", label = "Model", value = F) |> autoCompleteOff()
                                                                            ),
                                                                            column(3,
                                                                                   checkboxInput(inputId = "spectrumResiduals", label = "Model res.", value = F) |> autoCompleteOff()
                                                                            ),
                                                                            column(2,
                                                                                   checkboxInput(inputId = "spectrumFilter", label = "Filter", value = F) |> autoCompleteOff()
                                                                            ),
                                                                            column(3,
                                                                                   checkboxInput(inputId = "spectrumFilterRes", label = "Filter res.", value = F) |> autoCompleteOff()
                                                                            )
                                                                          )
                                                                        ),
                                                                        conditionalPanel(
                                                                          condition = "input.spectrum == true",
                                                                          fluidRow(
                                                                            column(4,
                                                                                   textInput(inputId = "ofac", label = "Oversampling", value = NULL) |> autoCompleteOff()
                                                                            ),
                                                                            column(4,
                                                                                   textInput(inputId = "long_period", label = "Longest period", value = NULL) |> autoCompleteOff()
                                                                            ),
                                                                            column(4,
                                                                                   textInput(inputId = "short_period", label = "Shortest period", value = NULL) |> autoCompleteOff()
                                                                            )
                                                                          ),
                                                                          div(style = "padding: 0px 0px; margin-top:-0.5em",
                                                                              tags$hr(style = "border-color: #333333; border-top: 1px solid #333333;")
                                                                          )
                                                                        ),

                                                                        ## % Wavelet ####
                                                                        conditionalPanel(
                                                                          condition = "output.wavelet == true",
                                                                          div(style = "padding: 0px 0px; margin-top:0em",
                                                                              fluidRow(
                                                                                column(4,
                                                                                       checkboxInput(inputId = "wavelet",
                                                                                                     div("Wavelets",
                                                                                                         helpPopup("This option estimates the wavelet transform.", anchor = "notes-on-the-wavelet-transform")),
                                                                                                     value = F) |> autoCompleteOff()
                                                                                ),
                                                                                column(4, offset = 4,
                                                                                       conditionalPanel(
                                                                                         condition = "input.wavelet == true",
                                                                                         textInput(inputId = "loc_wavelet",
                                                                                                   div("Sampling",
                                                                                                       helpPopup("Enter the temporal resolution or time separation between wavelets.<br>
                                                                                                               The maximum valid value is half the total observed period.<br>
                                                                                                               The minimum valid value is the sampling period of the series.", anchor = "notes-on-the-wavelet-transform")),
                                                                                                   value = "") |> autoCompleteOff()
                                                                                       )
                                                                                )
                                                                              ),
                                                                              conditionalPanel(
                                                                                condition = "input.wavelet == true",
                                                                                fluidRow(
                                                                                  column(4,
                                                                                         textInput(inputId = "min_wavelet",
                                                                                                   div("Min.",
                                                                                                       helpPopup("Enter the shortest period to compute the transform.<br>The minimum valid value is twice the median sampling period.", anchor = "notes-on-the-wavelet-transform")),
                                                                                                   value = "") |> autoCompleteOff()
                                                                                  ),
                                                                                  column(4,
                                                                                         textInput(inputId = "max_wavelet",
                                                                                                   div("Max.",
                                                                                                       helpPopup("Enter the longest period to compute the transform.<br>The maximum valid value is half the total observed period.", anchor = "notes-on-the-wavelet-transform")),
                                                                                                   value = "") |> autoCompleteOff()
                                                                                  ),
                                                                                  column(4,
                                                                                         textInput(inputId = "res_wavelet",
                                                                                                   div("Step",
                                                                                                       helpPopup("Enter the time resolution or separation between the periods to compute the transform.", anchor = "notes-on-the-wavelet-transform")),
                                                                                                   value = "") |> autoCompleteOff()
                                                                                  )
                                                                                )
                                                                              )
                                                                          )
                                                                        ),
                                                                        conditionalPanel(
                                                                          condition = "input.wavelet == true",
                                                                          radioButtons(inputId = "waveletType", label = NULL, choices = list("None" = 0, "Original" = 1, "Model" = 2, "Model res." = 3, "Filter" = 4, "Filter res." = 5), selected = 0, inline = T, width = NULL, choiceNames = NULL,  choiceValues = NULL) |> autoCompleteOff(),
                                                                          div(style = "padding: 0px 0px; margin-top:-0.5em",
                                                                              tags$hr(style = "border-color: #333333; border-top: 1px solid #333333;")
                                                                          )
                                                                        ),

                                                                        ## % Vondrak ####
                                                                        div(style = "padding: 0px 0px; margin-top:0em",
                                                                            fluidRow(
                                                                              column(6,
                                                                                     checkboxInput(inputId = "filter",
                                                                                                   div("Band-pass smoother",
                                                                                                       helpPopup("This option computes the Vondrak smoother for the original or residual series.", anchor = "notes-on-the-vondrak-smoother")),
                                                                                                   value = F) |> autoCompleteOff()
                                                                              ),
                                                                              div(style = "padding: 0px 0px; margin-top:1em",
                                                                                  column(6,
                                                                                         conditionalPanel(
                                                                                           condition = "input.filter == true",
                                                                                           div(style = "padding: 0px 0px; margin-top:-0.4em",
                                                                                               radioButtons(inputId = "series2filter", label = NULL, choices = list("Original" = 1, "Residual" = 2), selected = 1, inline = T) |> autoCompleteOff()
                                                                                           )
                                                                                         )
                                                                                  )
                                                                              )
                                                                            ),
                                                                            conditionalPanel(
                                                                              condition = "input.filter == true",
                                                                              fluidRow(
                                                                                column(6,
                                                                                       textInput(inputId = "low",
                                                                                                 div("Low-pass period cutoff",
                                                                                                     helpPopup("Enter the low-pass period. The maximum recommended value is 1/4 of the series length.", anchor = "notes-on-the-vondrak-smoother")),
                                                                                                 value = "") |> autoCompleteOff()
                                                                                ),
                                                                                column(6,
                                                                                       textInput(inputId = "high",
                                                                                                 div("High-pass period cutoff",
                                                                                                     helpPopup("Enter the high-pass period. The maximum recommended value is 1/4 of the series length.", anchor = "notes-on-the-vondrak-smoother")),
                                                                                                 value = "") |> autoCompleteOff()
                                                                                )
                                                                              ),
                                                                              div(style = "padding: 0px 0px; margin-top:-0.5em",
                                                                                  tags$hr(style = "border-color: #333333; border-top: 1px solid #333333;")
                                                                              )
                                                                            )
                                                                        ),

                                                                        ## % Noise ####
                                                                        div(style = "padding: 0px 0px; margin-top:0em",
                                                                            fluidRow(
                                                                              column(5,
                                                                                     checkboxInput(inputId = "mle",
                                                                                                   div("Noise analysis",
                                                                                                       helpPopup("This option estimates the parameters of a covariance model of the residual series.", anchor = "notes-on-the-noise-analysis")),
                                                                                                   value = F) |> autoCompleteOff()
                                                                              ),
                                                                              conditionalPanel(
                                                                                condition = "input.mle == true",
                                                                                column(width = 4, offset = 3, style = "margin-top:0em; padding: 0px 0px 0px 0px", align = "left",
                                                                                       conditionalPanel(
                                                                                         condition = "input.mle == true",
                                                                                         withBusyIndicatorUI(
                                                                                           actionButton(inputId = "runmle", label = "Run MLE", icon = icon("hourglass", class = NULL, lib = "font-awesome"), style = "font-size: small")
                                                                                         )
                                                                                       )
                                                                                )
                                                                              )
                                                                            ),
                                                                            conditionalPanel(
                                                                              condition = "input.mle == true",
                                                                              fluidRow(
                                                                                column(6,
                                                                                       checkboxInput(inputId = "noise_unc",
                                                                                                     div("Noise uncertainty",
                                                                                                         helpPopup("This option enables or disables the estimation of the formal uncertainties of the parameters of the estimated noise model.", anchor = "notes-on-the-noise-analysis")),
                                                                                                     value = T) |> autoCompleteOff()
                                                                                ),
                                                                                column(6,
                                                                                       checkboxInput(inputId = "wiener",
                                                                                                     div("Noise separation",
                                                                                                         helpPopup("This option separates the residual series into the different estimated noise components.", anchor = "notes-on-the-noise-analysis")),
                                                                                                     value = F) |> autoCompleteOff()
                                                                                )
                                                                              )
                                                                            ),
                                                                            fluidRow(
                                                                              conditionalPanel(
                                                                                condition = "input.mle == true",
                                                                                column(2, style = "padding: 0px 0px 0px 10px;",
                                                                                       checkboxInput(inputId = "white", label = "White", value = F, width = '25%') |> autoCompleteOff()
                                                                                ),
                                                                                column(2, style = "padding: 0px 0px 0px 0px;",
                                                                                       checkboxInput(inputId = "flicker", label = "Flicker", value = F, width = '25%') |> autoCompleteOff()
                                                                                ),
                                                                                column(4, style = "padding: 0px 0px 0px 0px;",
                                                                                       checkboxInput(inputId = "randomw", label = "Random walk", value = F, width = '200%') |> autoCompleteOff()
                                                                                ),
                                                                                column(4, style = "padding: 0px 10px 0px 10px;",
                                                                                       checkboxInput(inputId = "powerl", label = "Power-law", value = F, width = '150%') |> autoCompleteOff()
                                                                                )
                                                                              )
                                                                            ),
                                                                            fluidRow(
                                                                              column(4,
                                                                                     conditionalPanel(
                                                                                       condition = "input.white == true",
                                                                                       htmlOutput("est.white")
                                                                                     )
                                                                              ),
                                                                              conditionalPanel(
                                                                                condition = "input.powerl == true",
                                                                                column(4,
                                                                                       htmlOutput("est.powerl")
                                                                                ),
                                                                                column(4,
                                                                                       htmlOutput("est.index")
                                                                                )
                                                                              ),
                                                                              conditionalPanel(
                                                                                condition = "input.powerl != true",
                                                                                column(4,
                                                                                       conditionalPanel(
                                                                                         condition = "input.flicker == true",
                                                                                         htmlOutput("est.flicker")
                                                                                       )
                                                                                ),
                                                                                column(4,
                                                                                       conditionalPanel(
                                                                                         condition = "input.randomw == true",
                                                                                         htmlOutput("est.randomw")
                                                                                       )
                                                                                )
                                                                              )
                                                                            ),
                                                                            conditionalPanel(
                                                                              condition = "input.mle == true",
                                                                              htmlOutput("est.mle"),
                                                                              htmlOutput("est.unc"),
                                                                              htmlOutput("crossover")
                                                                            )
                                                                        )
                                                                      ),

                                                                      style = "primary")
                                           ),

                                           # * Local download ####
                                           bsCollapse(id = "localDir", open = "", multiple = F,
                                                      bsCollapsePanel(value = 6,
                                                                      tags$h4(style = "color:white", icon("box-archive", class = NULL, lib = "font-awesome"), "Save results"),
                                                                      fluidRow(
                                                                        column(2,
                                                                               downloadButton(outputId = "downloadAs", label = "Save as")
                                                                        ),
                                                                        column(10,
                                                                               verbatimTextOutput("localDirectory", placeholder = T) |> autoCompleteOff()
                                                                        )
                                                                      ),
                                                                      div(style = "padding: 0px 0px; margin-top:1em",
                                                                          fluidRow(
                                                                            column(8,
                                                                                   textInput(inputId = "directory",
                                                                                             div("Select directory",
                                                                                                 helpPopup("Enter the full path of the download directory.", anchor = NULL)),
                                                                                             value = "") |> autoCompleteOff()
                                                                            ),
                                                                            column(4,
                                                                                   div(style = "padding: 0px 0px; margin-top:2em",
                                                                                       actionButton(inputId = "autoDownload", label = "Automatic save", icon = icon("floppy-disk", class = NULL, lib = "font-awesome"), style = "font-size: small")
                                                                                   )
                                                                            )
                                                                          )
                                                                      ),
                                                                      actionButton(inputId = "browser", label = "Debug pit stop"),
                                                                      style = "primary")
                                           )
                                         )
                                    ),

                                    # Visualization panel ####

                                    # Tab numbers in order from left to right:
                                    # 0: SARI logo
                                    # 6: help
                                    # 4: 3D series
                                    # 1: 1st component
                                    # 2: 2nd component
                                    # 3: 3rd component
                                    # 5: residual series
                                    # 7: save
                                    # 8: PDF

                                    mainPanel(
                                      # style = "position:fixed; right: 0px; height: 90vh; overflow-y: auto;",
                                      id = "main-panel",
                                      conditionalPanel(
                                        condition = "input.header == true",
                                        verbatimTextOutput("showHeader", placeholder = F)
                                      ),
                                      fluidPage(
                                        tableOutput('debug')
                                      ),
                                      navbarPage(
                                        title = "", windowTitle = version, id = "tab", selected = 1, position = "fixed-top", header = NULL, footer = NULL, inverse = F, collapsible = T, fluid = T, theme = NULL,
                                        tabPanel(div(style = "display: inline-block; font-size: 40px; color: #333333", "SARI"), value = 0, id = "SARI"),
                                        tabPanel(div(style = "margin-top:-3.5em; font-size: 25px; display: inline-block;","Help"), value = 6, icon = icon("circle-info", class = "fas fa-2x"),
                                                 uiOutput("about_file")
                                        ),

                                        # * 3D series ####
                                        tab3Contents("3D"),

                                        # * component 1 ####
                                        tabContents(1),

                                        # * component 2 ####
                                        tabContents(2),

                                        # * component 3 ####
                                        tabContents(3),

                                        # * residual series ####
                                        tab3Contents("residuals"),

                                        tabPanel(title = downloadLink('print_out', div(style = "margin-top:-3.5em; font-size: 25px; display: inline-block; font-family: sans-serif; font-weight: normal;","PDF"), class = "fa-solid fa-file", style = "font-size:30px; margin-top:-0.9em"), value = 8),
                                        tabPanel(title = downloadLink('download', div(style = "margin-top:-3.5em; font-size: 25px; display: inline-block; font-family: sans-serif; font-weight: normal;","Save"), class = "fa-solid fa-floppy-disk", style = "font-size:30px; margin-top:-0.9em"), value = 7)
                                      )
                                    )
                      )
                  )
                )
)



server <- function(input,output,session) {

  # disabling clicking on the SARI name
  toggleClass(
    class = "disabled",
    selector = "#tab li a[data-value=0]"
  )

  # starting logging the user' session
  mySession <- NULL
  cat(file = stderr(), "\n", "\n", "START", "\n")

  # Catching a refreshed page, but trying to exclude the loading of a new instance
  shinyjs::runjs("
    var pageAccessedByReload = 'false';
    var startTime = 0;
    pageAccessedByReload = window.performance.getEntriesByType('navigation')[0].type.includes('reload');
    startTime = window.performance.getEntriesByType('navigation')[0].responseStart;
    if (pageAccessedByReload === true && startTime > 2000) {
      pageAccessedByReload = 'false';
    }
    Shiny.onInputChange('refreshed', pageAccessedByReload);
  ")

  # Debugging pit stop (from https://www.r-bloggers.com/2019/02/a-little-trick-for-debugging-shiny/?msclkid=3fafd7f3bc9911ec9c1253a868203435)
  observeEvent(input$browser,{
    browser()
  })

  # Initialize reactive variables of the global database only for debugging
  database <- c("file", "ranges", "info", "db1", "db2", "inputs", "trans", "url")
  
  # 1. input files.
  file <- reactiveValues(primary = NULL, secondary = NULL, id1 = NULL, id2 = NULL, sitelog = NULL, euler = NULL, soln = NULL, custom = NULL)

  # 2. series ranges:
  #   x0 = original time axis
  #   x1 = used series time axis
  #   x2 = residual time axis
  #   x3 = periodogram time axis
  #   y1 = primary series values axis
  #   y12 = secondary series values axis
  #   y2 = residual series values axis
  #   y3 = amplitude/power values axis
  #   y4 = instantaneous rate values axis
  ranges <- reactiveValues(x0 = NULL, x1 = NULL, y1 = NULL, y12 = NULL, x2 = NULL, y2 = NULL, x3 = NULL, y3 = NULL, y4 = NULL,
                           y3D11 = NULL, y3D21 = NULL, y3D31 = NULL, y3D12 = NULL, y3D22 = NULL, y3D32 = NULL)

  # 3. series info
  #   sampling = current sampling of the series in the current time units
  #   sampling0 = sampling of the series in the current time units and before resampling
  #   samplingRaw = sampling of the uploaded series for each time unit
  info <- reactiveValues(points = NULL, removed = NULL, directory = NULL, log = NULL, log_years = NULL, sinfo = NULL, sinfo_years = NULL, soln = NULL, soln_years = NULL, custom = NULL, custom_years = NULL,
                         custom_warn = 0, tab = NULL, stop = NULL, noise = NULL, menu = c(1),
                         decimalsx = NULL, decimalsy = NULL, decimalsyList = c(), scientific = F, scientificList = c(), nsmall = NULL, digits = NULL,
                         sampling = NULL, sampling0 = NULL, sampling_regular = NULL, samplingRaw = c(0,0,0), samplingRaw2 = c(0,0,0), rangex = NULL, errorbars = T,
                         step = NULL, step2 = NULL, stepUnit = NULL,
                         minx = NULL, maxx = NULL, miny = NULL, maxy = NULL, width = isolate(session$clientData$output_plot1_width),
                         run = F, tunits.label = NULL, tunits.known1 = F, tunits.known2 = F, tunits.last = NULL, run_wavelet = T, pixelratio = NULL, welcome = F,
                         last_optionSecondary = 0, format = NULL, format2 = NULL, intro = T, KFiter = NULL, tol = NULL,
                         white = NULL, flicker = NULL, randomw = NULL, powerl = NULL, timeMLE = NULL, components = NULL, local = F,
                         product1 = NULL,
                         db1 = "stop", db2 = "stop",
                         trendRef = F, PolyRef = F, periodRef = F,
                         plateFile = NULL,
                         last_eulerType = 0, last_giaType = 0,
                         overview = F,
                         clickX = NULL, clickY = NULL, closestX = NULL, closestY = NULL,
                         LStol = 1e-5, parameters = NULL,
                         redo_step2 = 0)

  # 4. database:
  #   1 = original
  #   2 = resampled
  #   3 = corrected (series are first resampled and then corrected)
  db1 <- reactiveValues(original = NULL)
  db2 <- reactiveValues(original = NULL)

  # 5. user input
  inputs <- reactiveValues(thresholdRes = NULL, thresholdResN = NULL, trendRef = NULL, period = NULL,
                           periodRef = NULL, offsetEpoch = NULL, ExponenRef = NULL, E0 = NULL, TE0 = NULL,
                           LogariRef = NULL, L0 = NULL, TL0 = NULL, PolyRef = NULL, PolyCoef = NULL, ofac = "",
                           long_period = "", short_period = "", low = NULL, high = NULL, scaleFactor = 1,
                           step = NULL, step2 = NULL,
                           giaTrend = NULL, giaTrend2 = NULL,
                           plot4_1click = NULL, plot5_1click = NULL,
                           breakEpoch = NULL,
                           pole_x = NULL, pole_y = NULL, pole_z = NULL, pole_lat = NULL, pole_lon = NULL, pole_rot = NULL, station_x = NULL, station_y = NULL, station_z = NULL, station_x2 = NULL, station_y2 = NULL, station_z2 = NULL)

  obs <- reactiveVal()

  # 6. computed values
  trans <- reactiveValues(x0 = NULL, y0 = NULL, sy0 = NULL, x = NULL, y = NULL, sy = NULL, xe = NULL, ye = NULL,
                          sye = NULL, y2 = NULL, sy2 = NULL,
                          res = NULL, mod = NULL, results = NULL, filter = NULL,
                          filterRes = NULL, kalman = NULL, equation = NULL, ordinate = NULL, midas_vel = NULL,
                          midas_sig = NULL, midas_all = NULL, midas_vel2 = NULL, midas_sig2 = NULL,
                          mle = NULL, verif = NULL, pattern = NULL, unc = NULL, vondrak = NULL, wave = NULL,
                          noise = NULL, fs = NULL, names = NULL, KFnames = NULL, LScoefs = NULL, fs = NULL, amp = NULL, psd = NULL,
                          col = NULL, spectra = NULL, spectra_old = NULL, title = NULL, var = NULL, wavelet = NULL,
                          model_old = NULL, offsetEpochs = NULL, offsetEpochs1 = NULL, offsetEpochs2 = NULL, offsetEpochs3 = NULL, periods = NULL, breakEpochs = NULL,
                          x_orig = NULL, gaps = NULL,
                          plate = NULL, plate2 = NULL, gia = NULL, gia2 = NULL,
                          entropy_vel = NULL, entropy_sig = NULL, offsetEpoch.entropy = NULL,
                          slope = NULL,
                          white = NULL, flicker = NULL, randomw = NULL, powerl = NULL, white_sig = NULL, flicker_sig = NULL, randomw_sig = NULL, powerl_sig = NULL,
                          plotInfo1 = NULL, plotInfo2 = NULL, plotInfo3 = NULL)

  # 7. output
  OutPut <- reactiveValues(df = NULL)
  output_excluded <- reactiveValues(df = NULL)

  # 8. input parameters via URL
  url <- reactiveValues(station = NULL, server = NULL, file = NULL, station2 = NULL, server2 = NULL, file2 = NULL, logfile = NULL, logfile2 = NULL)

  # Resetting all parameters to default values each time the page loads (avoids problems when clicking back on the browser)
  reset("side-panel")
  reset("main-panel")

  # Constants ####
  SARIcolors <- c("black", "#DF536B", "#61D04F", "#2297E6", "#28E2E5", "#CD0BBC", "#F5C710", "gray62") # colorblind palette copied from the palette R4 for R versions < 4
  daysInYear <- 365.2425 # Gregorian year
  degMa2radyr <- pi/180000000 # geologic to geodetic units conversion
  debug <- F # saving the environment
  messages <- 2 # print step by step messages on the console depending on the verbosity level (0, 1, 2, 3, 4, 5, 6)
  info$components <- c("", "", "", "", "") # labels of the tab components at start up
  output$tabName1 <- renderText({ "Visualization panel" })
  output$tabName2 <- renderText({ info$components[2] })
  output$tabName3 <- renderText({ info$components[3] })
  output$tabName4 <- renderText({ info$components[4] })
  output$tabName5 <- renderText({ info$components[5] })

  # Welcome ####
  observe({
    # This fires each time a reactive input changes
    # inputChanged <- input$changed[lapply(input$changed, function(x) length(grep("clientdata|shinyjs-delay|shinyjs-resettable|undefined_", x, value = F))) == 0]
    # if (length(inputChanged) > 0 && messages > 5) {
    #   cat(file = stderr(), mySession, paste("Latest input fired:", input$changed, Sys.time(), paste(head(input[[input$changed]]), collapse = ", ")), "\n")
    # }
    req(info$intro)
    # next is run only at the start of each session
    if (grepl("HeadlessChrome|phantomjs|selenium|puppeteer|Playwright|wkhtmltopdf|HtmlUnit|SlimerJS", session$clientData$url_search, ignore.case = T)) {
      cat(file = stderr(), mySession, "Headless connection", "\n")
    }
    info$local = Sys.getenv('SHINY_PORT') == "" || session$clientData$url_hostname == "127.0.0.1" # detect local connection
    if (length(input$isMobile) > 0 && input$isMobile) {
      cat(file = stderr(), mySession, "Mobile connection", "\n")
      # cat(file = stderr(), mySession, "Screen size", input$size[1], "x", input$size[2], "\n")
      # cat(file = stderr(), mySession, "Touchscreen", input$tactile, "\n")
      shinyjs::hide(id = "menu")
      shinyjs::hide(id = "localDir")
      shinyjs::hide(selector = "#tab li a[data-value=1]")
      shinyjs::hide(selector = "#tab li a[data-value=2]")
      shinyjs::hide(selector = "#tab li a[data-value=3]")
      shinyjs::hide(selector = "#tab li a[data-value=4]")
      shinyjs::hide(selector = "#tab li a[data-value=5]")
      shinyjs::hide(selector = "#tab li a[data-value=8]")
      updateNavbarPage(session, "tab", selected = "6")
      shinyjs::hide(selector = "#tab li a[data-value=6]")
      shinyjs::hideElement(id = "side-panel", anim = F)
      showModal(modalDialog(
        title = tags$h3("Dear SARI user"),
        HTML("It is strongly discouraged to use SARI on small-screen devices.<br>Please, consider using a desktop connection instead."),
        size = "m",
        easyClose = F,
        fade = F
      ))
      load_data(2)
    } else {
      if (info$local) { # local SARI session
        load_data(0)
        if (!is.null(dev.list())) dev.off()
        shinyjs::show("localDir")
      } else { # remote SARI session
        shinyjs::delay(100, {
          if (isTRUE(input$refreshed)) { # we do not like refreshed remote sessions
            if (messages > 0) cat(file = stderr(), mySession, "Page refreshed", "\n")
            showModal(modalDialog(
              title = tags$h3("Dear SARI user"),
              HTML("<div style='padding: 0px 50px'>The SARI webpage has been reloaded.<br><br>If this was due to an error, please consider giving feedback <a href='https://github.com/alvarosantamariagomez/sari' target='_blank'>here</a>.<br><br>Otherwise, if the session is still connected to the server, to start a new analysis, it is <span style='color: red; font-weight: bold;'>strongly recommended</span> to use the RESET button instead (left panel, plot controls section).</div>"),
              size = "m",
              easyClose = T,
              fade = T
            ))
          }
        })
        # if (messages > 5) cat(file = stderr(), mySession, "Screen size", input$size[1], "x", input$size[2], "\n")
        # if (messages > 5) cat(file = stderr(), mySession, "Pixel ratio", info$pixelratio, "\n")
        # if (messages > 2) cat(file = stderr(), mySession, "Touchscreen", input$tactile, "\n")
        shinyjs::hide("localDir")
        # welcome message on screen (deprecated)
        if (isTRUE(info$welcome)) {
          showNotification("<<< It is strongly recommended to read the help content at least once to avoid mistakes and to make the most of this tool.", action = NULL, duration = 10, closeButton = T, id = "point_to_help", type = "message", session = getDefaultReactiveDomain())
          if (messages > 2) cat(file = stderr(), mySession, "Warning", "\n")
          # if (isTruthy(input$tactile)) {
          #   if (input$tactile > 0) {
          #     if (messages > 2) cat(file = stderr(), mySession, "Touchscreen", input$tactile, "\n")
          #     showModal(modalDialog(
          #       title = tags$h3("Dear SARI user"),
          #       HTML("It is strongly discouraged to use the touchscreen with SARI.<br>Please, consider using the mouse instead."),
          #       size = "m",
          #       easyClose = T,
          #       fade = F
          #     ))
          #   }
          # }
          info$welcome <- F
        }
        mySession <<- as.integer(runif(n = 1, min = 1, max = 999999)) # setting anonymous user' session id
        load_data(4) # load the app
      }
      # setting the IU options that are defined at the server side
      output$showStation1 <- renderUI({
        textInput(inputId = "station1", label = "Station", value = "")
      })
      output$showStation2 <- renderUI({
        if (isTruthy(inputs$station2)) {
          textInput(inputId = "station2", label = "Station", value = "")
        }
      })
      output$fileSeries1 <- renderUI({
        tags$a(href = "SPOTGINS_CRAL00FRA.enu", "Show file example", targe = "_blank")
      })
      output$fileSeries2 <- renderUI({
        NULL
      })
      output$sitelog <- renderUI({
        tags$a(href = "cral00fra_20231110.log", "Show file example", target = "_blank")
      })
      output$station.info <- renderUI({
        tags$a(href = "station.info", "Show file example", target = "_blank")
      })
      output$solnFile <- renderUI({
        tags$a(href = "soln.snx", "Show file example", target = "_blank")
      })
      output$customFile <- renderUI({
        tags$a(href = "steps.txt", "Show file example", target = "_blank")
      })
    }
    info$intro <- F
  }, priority = 2000)

  # UI output reactive flags ####
  output$print_out <- reactive({}) # bugfix to avoid hidden() breaking the downloadHandler()
  outputOptions(output, "print_out", suspendWhenHidden = F)
  output$download <- reactive({})
  outputOptions(output, "download", suspendWhenHidden = F)

  output$about_file <- renderUI({
    if (input$isMobile && length(input$isMobile) > 0) {
      file <- "www/about_mobile.md"
    } else {
      file <- "www/about.md"
    }
    withMathJax(includeMarkdown(file))
  })

  output$tab3D <- reactive({
    return(input$tab == 4 || input$tab == 5)
  })
  outputOptions(output, "tab3D", suspendWhenHidden = F)

  output$wavelet <- reactive({
    return(exists("get.nscales", mode = "function"))
  })
  outputOptions(output, "wavelet", suspendWhenHidden = F)

  output$log <- reactive({
    return(!is.null(file$sitelog) || !is.null(file$primary$logfile) || !is.null(file$secondary$logfile))
  })
  outputOptions(output, "log", suspendWhenHidden = F)

  output$sinfo <- reactive({
    return(!is.null(input$sinfo))
  })
  outputOptions(output, "sinfo", suspendWhenHidden = F)

  output$soln <- reactive({
    return(!is.null(file$soln))
  })
  outputOptions(output, "soln", suspendWhenHidden = F)

  output$custom <- reactive({
    return(!is.null(file$custom))
  })
  outputOptions(output, "custom", suspendWhenHidden = F)

  output$series1 <- reactive({
    return(!is.null(file$primary))
  })
  outputOptions(output, "series1", suspendWhenHidden = F)

  output$series2 <- reactive({
    return(!is.null(file$secondary))
  })
  outputOptions(output, "series2", suspendWhenHidden = F)

  output$run <- reactive({
    return(isTRUE(info$run))
  })
  outputOptions(output, "run", suspendWhenHidden = F)

  output$verifhelp <- reactive({
    return(isTruthy(trans$verif))
  })
  outputOptions(output, "verifhelp", suspendWhenHidden = F)

  output$data <- reactive({
    return(!is.null(db1$original))
  })
  outputOptions(output, "data", suspendWhenHidden = F)

  output$residuals <- reactive({
    return(!is.null(trans$res))
  })
  outputOptions(output, "residuals", suspendWhenHidden = F)

  output$rate <- reactive({
    return("Linear" %in% input$model && length(trans$kalman) > 0 && trans$kalman_info$processNoise[2] > 0)
  })
  outputOptions(output, "rate", suspendWhenHidden = F)

  output$mobile <- reactive({
    return(length(input$isMobile) > 0 && input$isMobile)
  })
  outputOptions(output, "mobile", suspendWhenHidden = F)

  output$pmm <- renderUI({
    if (isTruthy(input$plateModel)) {
      if (input$plateModel == "ITRF2020") {
        model <- "ITRF2020-PMM.dat"
      } else if (input$plateModel == "NNR-MORVEL56") {
        model <- "NNR-MORVEL56.txt"
      } else if (input$plateModel == "NNR-GSRM") {
        model <- "NNR-GSRM_v2.1.txt"
      }
      link <- a("Show the selected plate model", href = model, target = "_blank")
      tagList(link)
    }
  })
  outputOptions(output, "pmm", suspendWhenHidden = F)
  
  output$pearson <- reactive({
    common <- NULL
    if (input$optionSecondary == 1 && isTruthy(trans$y) && isTruthy(trans$y2)) {
      serie1 <- data.frame(x = trans$x, y = trans$y)
      serie2 <- data.frame(x = trans$x2, y = trans$y2)
      common <- merge(serie1, serie2, by = "x")
    }
    return(length(common$x) > 30)
  })
  outputOptions(output, "pearson", suspendWhenHidden = F)

  # Series summary ####
  output$information1 <- output$information2 <- renderUI({
    req(db1[[info$db1]])
    if (input$tunits == 1) {
      units <- "days"
    } else if (input$tunits == 2) {
      units <- "weeks"
    } else if (input$tunits == 3) {
      units <- "years"
    }
    if (input$tab > 3) {
      statusAll <- colSums(t(cbind(db1[[info$db1]]$status1, db1[[info$db1]]$status2, db1[[info$db1]]$status3))) > 0
      x <- db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(statusAll)]
      rangex <- range(x)
      seriesInfo(x)
      removed <- max(sum(!db1[[info$db1]]$status1 %in% T), sum(!db1[[info$db1]]$status2 %in% T), sum(!db1[[info$db1]]$status3 %in% T), na.rm = T)
    } else {
      rangex <- range(trans$x)
      removed <- info$removed
    }
    line1 <- sprintf("Number of points = %d",info$points)
    line2 <- sprintf("Number of points removed = %d",removed)
    line3 <- paste(sprintf("Series length = %.*f", info$decimalsx, info$rangex), units)
    line4 <- sprintf("Series range = %.*f - %.*f",info$decimalsx, rangex[1], info$decimalsx, rangex[2])
    line5 <- paste(sprintf("Series sampling = %.*f",info$decimalsx, info$sampling), units)
    line6 <- sprintf("Series completeness = %.1f %%",100*(info$points - 1)/(info$rangex/info$sampling))
    HTML(paste("", line1, line2, line3, line4, line5, line6, sep = "<br/>"))
  })

  # Debouncers & checks for user typed inputs ####
  reactive({
    inputs$ObsError <- suppressWarnings(as.numeric(trimws(input$ObsError, which = "both", whitespace = "[ \t\r\n]")))
  }) %>% debounce(0, priority = 1000)

  reactive({
    inputs$thresholdRes <- suppressWarnings(as.numeric(trimws(input$thresholdRes, which = "both", whitespace = "[ \t\r\n]")))
  }) %>% debounce(0, priority = 1000)

  reactive({
    inputs$thresholdResN <- suppressWarnings(as.numeric(trimws(input$thresholdResN, which = "both", whitespace = "[ \t\r\n]")))
  }) %>% debounce(0, priority = 1000)

  trendRef_d <- reactive(input$trendRef) %>% debounce(1000, priority = 1000)
  observeEvent(trendRef_d(), {
    if (is.na(inputs$trendRef) || is.null(inputs$trendRef) || trendRef_d() != inputs$trendRef) {
      inputs$trendRef <- suppressWarnings(as.numeric(trimws(trendRef_d(), which = "both", whitespace = "[ \t\r\n]")))
    }
  }, priority = 1000)

  period_d <- reactive(input$period) %>% debounce(1000, priority = 1000)
  observeEvent(period_d(), {
    inputs$period <- trimws(period_d(), which = "both", whitespace = "[ \t\r\n]")
  }, priority = 1000)

  periodRef_d <- reactive(input$periodRef) %>% debounce(1000, priority = 1000)
  observeEvent(periodRef_d(), {
    if (is.na(inputs$periodRef) || is.null(inputs$periodRef) || periodRef_d() != inputs$periodRef) {
      inputs$periodRef <- suppressWarnings(as.numeric(trimws(periodRef_d(), which = "both", whitespace = "[ \t\r\n]")))
      info$periodRef <- isTruthy(inputs$periodRef)
    }
  }, priority = 1000)

  offsetEpoch_d <- reactive(input$offsetEpoch) %>% debounce(1000, priority = 1000)
  observeEvent(offsetEpoch_d(), {
    inputs$offsetEpoch <- trimws(offsetEpoch_d(), which = "both", whitespace = "[ \t\r\n]")
  }, priority = 1000)

  offsetEpoch.entropy_d <- reactive(input$offsetEpoch.entropy) %>% debounce(1000, priority = 1000)
  observeEvent(offsetEpoch.entropy_d(), {
    inputs$offsetEpoch.entropy <- trimws(offsetEpoch.entropy_d(), which = "both", whitespace = "[ \t\r\n]")
  }, priority = 1000)

  ExponenRef_d <- reactive(input$ExponenRef) %>% debounce(1000, priority = 1000)
  observeEvent(ExponenRef_d(), {
    inputs$ExponenRef <- trimws(ExponenRef_d(), which = "both", whitespace = "[ \t\r\n]")
  }, priority = 1000)

  E0_d <- reactive(input$E0) %>% debounce(1000, priority = 1000)
  observeEvent(E0_d(), {
    if (!isTruthy(inputs$E0) || E0_d() != inputs$E0) {
      inputs$E0 <- trimws(E0_d(), which = "both", whitespace = "[ \t\r\n]")
    }
  }, priority = 1000)

  reactive({
    inputs$eE0 <- trimws(input$eE0, which = "both", whitespace = "[ \t\r\n]")
  }) %>% debounce(0, priority = 1000)

  TE0_d <- reactive(input$TE0) %>% debounce(1000, priority = 1000)
  observeEvent(TE0_d(), {
    if (!isTruthy(inputs$TE0) || TE0_d() != inputs$TE0) {
      inputs$TE0 <- trimws(TE0_d(), which = "both", whitespace = "[ \t\r\n]")
    }
  }, priority = 1000)

  reactive({
    inputs$eTE0 <- trimws(input$eTE0, which = "both", whitespace = "[ \t\r\n]")
  }) %>% debounce(0, priority = 1000)

  LogariRef_d <- reactive(input$LogariRef) %>% debounce(1000, priority = 1000)
  observeEvent(LogariRef_d(), {
    inputs$LogariRef <- trimws(LogariRef_d(), which = "both", whitespace = "[ \t\r\n]")
  }, priority = 1000)

  L0_d <- reactive(input$L0) %>% debounce(1000, priority = 1000)
  observeEvent(L0_d(), {
    if (!isTruthy(inputs$L0) || L0_d() != inputs$L0) {
      inputs$L0 <- trimws(L0_d(), which = "both", whitespace = "[ \t\r\n]")
    }
  }, priority = 1000)

  reactive({
    inputs$eL0 <- trimws(input$eL0, which = "both", whitespace = "[ \t\r\n]")
  }) %>% debounce(0, priority = 1000)

  TL0_d <- reactive(input$TL0) %>% debounce(1000, priority = 1000)
  observeEvent(TL0_d(), {
    if (!isTruthy(inputs$TL0) || TL0_d() != inputs$TL0) {
      inputs$TL0 <- trimws(TL0_d(), which = "both", whitespace = "[ \t\r\n]")
    }
  }, priority = 1000)

  reactive({
    inputs$eTL0 <- trimws(input$eTL0, which = "both", whitespace = "[ \t\r\n]")
  }) %>% debounce(0, priority = 1000)

  PolyRef_d <- reactive(input$PolyRef) %>% debounce(1000, priority = 1000)
  observeEvent(PolyRef_d(), {
    if (is.na(inputs$PolyRef) || is.null(inputs$PolyRef) || PolyRef_d() != inputs$PolyRef) {
      inputs$PolyRef <- suppressWarnings(as.numeric(trimws(PolyRef_d(), which = "both", whitespace = "[ \t\r\n]")))
    }
  }, priority = 1000)

  PolyCoef_d <- reactive(input$PolyCoef) %>% debounce(1000, priority = 1000)
  observeEvent(PolyCoef_d(), {
    inputs$PolyCoef <- suppressWarnings(as.numeric((trimws(PolyCoef_d(), which = "both", whitespace = "[ \t\r\n]"))))
  }, priority = 1000)

  ofac_d <- reactive(input$ofac) %>% debounce(1000, priority = 1000)
  observeEvent(ofac_d(), {
    if (is.na(inputs$ofac) || ofac_d() != inputs$ofac) {
      inputs$ofac <- suppressWarnings(as.numeric(trimws(ofac_d(), which = "both", whitespace = "[ \t\r\n]")))
    }
  }, priority = 1000)

  long_period_d <- reactive(input$long_period) %>% debounce(1000, priority = 1000)
  observeEvent(long_period_d(), {
    if (is.na(inputs$long_period) || long_period_d() != inputs$long_period) {
      inputs$long_period <- suppressWarnings(as.numeric(trimws(long_period_d(), which = "both", whitespace = "[ \t\r\n]")))
    }
  }, priority = 1000)

  short_period_d <- reactive(input$short_period) %>% debounce(1000, priority = 100)
  observeEvent(short_period_d(), {
    if (is.na(inputs$short_period) || short_period_d() != inputs$short_period) {
      inputs$short_period <- suppressWarnings(as.numeric(trimws(short_period_d(), which = "both", whitespace = "[ \t\r\n]")))
    }
  }, priority = 100)

  low_d <- reactive(input$low) %>% debounce(1000, priority = 1000)
  observeEvent(low_d(), {
    inputs$low <- suppressWarnings(as.numeric(trimws(low_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  high_d <- reactive(input$high) %>% debounce(1000, priority = 1000)
  observeEvent(high_d(), {
    inputs$high <- suppressWarnings(as.numeric(trimws(high_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  step_d <- reactive(input$step) %>% debounce(1000, priority = 1000)
  observeEvent(c(step_d()), {
    if (grepl("^=", trimws(step_d()), perl = T)) {
      step <- try(eval(parse(text = sub("=", "", trimws(step_d())))), silent = T)
      if (isTruthy(step) && !inherits(step,"try-error")) {
        updateTextInput(session, inputId = "step", value = sprintf("%.*f",info$decimalsx, step))
      }
      req(info$stop)
    } else {
      inputs$step <- suppressWarnings(as.numeric(trimws(step_d(), which = "both", whitespace = "[ \t\r\n]")))
    }
  }, priority = 1000)

  step2_d <- reactive(input$step2) %>% debounce(1000, priority = 1000)
  observeEvent(c(step2_d()), {
    if (grepl("^=", trimws(step2_d()), perl = T)) {
      step <- try(eval(parse(text = sub("=","",trimws(step2_d())))), silent = T)
      if (isTruthy(step) && !inherits(step,"try-error")) {
        updateTextInput(session, inputId = "step2", value = sprintf("%.*f",info$decimalsx, step))
      }
      req(info$stop)
    } else {
      inputs$step2 <- suppressWarnings(as.numeric(trimws(step2_d(), which = "both", whitespace = "[ \t\r\n]")))
    }
  }, priority = 1000)

  min_wavelet_d <- reactive(input$min_wavelet) %>% debounce(1000, priority = 1000)
  observeEvent(c(min_wavelet_d()), {
    inputs$min_wavelet <- suppressWarnings(as.numeric(trimws(min_wavelet_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  max_wavelet_d <- reactive(input$max_wavelet) %>% debounce(1000, priority = 1000)
  observeEvent(max_wavelet_d(), {
    inputs$max_wavelet <- suppressWarnings(as.numeric(trimws(max_wavelet_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  res_wavelet_d <- reactive(input$res_wavelet) %>% debounce(1000, priority = 1000)
  observeEvent(res_wavelet_d(), {
    inputs$res_wavelet <- suppressWarnings(as.numeric(trimws(res_wavelet_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  loc_wavelet_d <- reactive(input$loc_wavelet) %>% debounce(1000, priority = 1000)
  observeEvent(loc_wavelet_d(), {
    inputs$loc_wavelet <- suppressWarnings(as.numeric(trimws(loc_wavelet_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  reactive({
    inputs$verif_white <- suppressWarnings(as.numeric(trimws(input$verif_white, which = "both", whitespace = "[ \t\r\n]")))
  }) %>% debounce(0, priority = 1000)

  reactive({
    inputs$verif_pl <- suppressWarnings(as.numeric(trimws(input$verif_pl, which = "both", whitespace = "[ \t\r\n]")))
  }) %>% debounce(0, priority = 1000)

  reactive({
    inputs$verif_k <- suppressWarnings(as.numeric(trimws(input$verif_k, which = "both", whitespace = "[ \t\r\n]")))
  }) %>% debounce(0, priority = 1000)

  reactive({
    inputs$verif_fl <- suppressWarnings(as.numeric(trimws(input$verif_fl, which = "both", whitespace = "[ \t\r\n]")))
  }) %>% debounce(0, priority = 1000)

  reactive({
    inputs$verif_rw <- suppressWarnings(as.numeric(trimws(input$verif_rw, which = "both", whitespace = "[ \t\r\n]")))
  }) %>% debounce(0, priority = 1000)

  waveformPeriod_d <- reactive(input$waveformPeriod) %>% debounce(1000, priority = 1000)
  observeEvent(waveformPeriod_d(), {
    inputs$waveformPeriod <-  suppressWarnings(as.numeric(trimws(waveformPeriod_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  reactive({
    inputs$min_optirange <-  suppressWarnings(as.numeric(trimws(input$min_optirange, which = "both", whitespace = "[ \t\r\n]")))
  }) %>% debounce(0, priority = 1000)

  reactive({
    inputs$max_optirange <-  suppressWarnings(as.numeric(trimws(input$max_optirange, which = "both", whitespace = "[ \t\r\n]")))
  }) %>% debounce(0, priority = 1000)

  epoch_d <- reactive(input$epoch) %>% debounce(1000, priority = 1000)
  observeEvent(epoch_d(), {
    inputs$epoch <-  suppressWarnings(as.numeric(trimws(epoch_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  variable_d <- reactive(input$variable) %>% debounce(1000, priority = 1000)
  observeEvent(variable_d(), {
    inputs$variable <-  suppressWarnings(as.numeric(trimws(variable_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  errorBar_d <- reactive(input$errorBar) %>% debounce(1000, priority = 1000)
  observeEvent(errorBar_d(), {
    inputs$errorBar <-  suppressWarnings(as.numeric(trimws(errorBar_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  ids_d <- reactive(input$ids) %>% debounce(1000, priority = 1000)
  observeEvent(ids_d(), {
    inputs$ids <-  trimws(ids_d(), which = "both", whitespace = "[ \t\r\n]")
  }, priority = 1000)

  epoch2_d <- reactive(input$epoch2) %>% debounce(1000, priority = 1000)
  observeEvent(epoch2_d(), {
    inputs$epoch2 <-  suppressWarnings(as.numeric(trimws(epoch2_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  variable2_d <- reactive(input$variable2) %>% debounce(1000, priority = 1000)
  observeEvent(variable2_d(), {
    inputs$variable2 <-  suppressWarnings(as.numeric(trimws(variable2_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  errorBar2_d <- reactive(input$errorBar2) %>% debounce(1000, priority = 1000)
  observeEvent(errorBar2_d(), {
    inputs$errorBar2 <-  suppressWarnings(as.numeric(trimws(errorBar2_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  station_x_d <- reactive(input$station_x) %>% debounce(1000, priority = 1000)
  observeEvent(station_x_d(), {
    inputs$station_x <- suppressWarnings(as.numeric(trimws(station_x_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  station_x2_d <- reactive(input$station_x2) %>% debounce(1000, priority = 1000)
  observeEvent(station_x2_d(), {
    inputs$station_x2 <- suppressWarnings(as.numeric(trimws(station_x2_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  station_y_d <- reactive(input$station_y) %>% debounce(1000, priority = 1000)
  observeEvent(station_y_d(), {
    inputs$station_y <- suppressWarnings(as.numeric(trimws(station_y_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  station_y2_d <- reactive(input$station_y2) %>% debounce(1000, priority = 1000)
  observeEvent(station_y2_d(), {
    inputs$station_y2 <- suppressWarnings(as.numeric(trimws(station_y2_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  station_z_d <- reactive(input$station_z) %>% debounce(1000, priority = 1000)
  observeEvent(station_z_d(), {
    inputs$station_z <- suppressWarnings(as.numeric(trimws(station_z_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  station_z2_d <- reactive(input$station_z2) %>% debounce(1000, priority = 1000)
  observeEvent(station_z2_d(), {
    inputs$station_z2 <- suppressWarnings(as.numeric(trimws(station_z2_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)
  
  allCoordinates <- reactive({
    list(inputs$pole_x, inputs$pole_y, inputs$pole_z, inputs$pole_lat, inputs$pole_lon, inputs$pole_rot, inputs$station_x, inputs$station_y, inputs$station_z, inputs$station_x2, inputs$station_y2, inputs$station_z2)
  }) %>% debounce(100, priority = 2000)

  station_lat_d <- reactive(input$station_lat) %>% debounce(1000, priority = 1000)
  observeEvent(station_lat_d(), {
    inputs$station_lat <- suppressWarnings(as.numeric(trimws(station_lat_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  station_lat2_d <- reactive(input$station_lat2) %>% debounce(1000, priority = 1000)
  observeEvent(station_lat2_d(), {
    inputs$station_lat2 <- suppressWarnings(as.numeric(trimws(station_lat2_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  station_lon_d <- reactive(input$station_lon) %>% debounce(1000, priority = 1000)
  observeEvent(station_lon_d(), {
    inputs$station_lon <- suppressWarnings(as.numeric(trimws(station_lon_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  station_lon2_d <- reactive(input$station_lon2) %>% debounce(1000, priority = 1000)
  observeEvent(station_lon2_d(), {
    inputs$station_lon2 <- suppressWarnings(as.numeric(trimws(station_lon2_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  pole_x_d <- reactive(input$pole_x) %>% debounce(1000, priority = 1000)
  observeEvent(pole_x_d(), {
    inputs$pole_x <- suppressWarnings(as.numeric(trimws(pole_x_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  pole_y_d <- reactive(input$pole_y) %>% debounce(1000, priority = 1000)
  observeEvent(pole_y_d(), {
    inputs$pole_y <- suppressWarnings(as.numeric(trimws(pole_y_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  pole_z_d <- reactive(input$pole_z) %>% debounce(1000, priority = 1000)
  observeEvent(pole_z_d(), {
    inputs$pole_z <- suppressWarnings(as.numeric(trimws(pole_z_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  pole_lat_d <- reactive(input$pole_lat) %>% debounce(1000, priority = 1000)
  observeEvent(pole_lat_d(), {
    inputs$pole_lat <- suppressWarnings(as.numeric(trimws(pole_lat_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  pole_lon_d <- reactive(input$pole_lon) %>% debounce(1000, priority = 1000)
  observeEvent(pole_lon_d(), {
    inputs$pole_lon <- suppressWarnings(as.numeric(trimws(pole_lon_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  pole_rot_d <- reactive(input$pole_rot) %>% debounce(1000, priority = 1000)
  observeEvent(pole_rot_d(), {
    inputs$pole_rot <- suppressWarnings(as.numeric(trimws(pole_rot_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  scaleFactor_d <- reactive(input$scaleFactor) %>% debounce(1000, priority = 1000)
  observeEvent(scaleFactor_d(), {
    if (is.na(as.numeric(input$scaleFactor)) || trimws(input$scaleFactor) == "0") {
      updateTextInput(session, inputId = "scaleFactor", value = "1")
    } else {
      inputs$scaleFactor <- suppressWarnings(as.numeric(trimws(scaleFactor_d(), which = "both", whitespace = "[ \t\r\n]")))
    }
  }, priority = 1000)

  station1_d <- reactive(input$station1) %>% debounce(1000, priority = 1000)
  observeEvent(station1_d(), {
    inputs$station1 <- suppressWarnings(trimws(station1_d(), which = "both", whitespace = "[ \t\r\n]"))
  }, priority = 1000)

  station2_d <- reactive(input$station2) %>% debounce(1000, priority = 1000)
  observeEvent(station2_d(), {
    inputs$station2 <- suppressWarnings(trimws(station2_d(), which = "both", whitespace = "[ \t\r\n]"))
  }, priority = 1000)

  cutStart_d <- reactive(input$cutStart) %>% debounce(1000, priority = 1000)
  observeEvent(cutStart_d(), {
    inputs$cutStart <- suppressWarnings(as.numeric(trimws(cutStart_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  cutEnd_d <- reactive(input$cutEnd) %>% debounce(1000, priority = 1000)
  observeEvent(cutEnd_d(), {
    inputs$cutEnd <- suppressWarnings(as.numeric(trimws(cutEnd_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)
  
  cutAbove_d <- reactive(input$cutAbove) %>% debounce(1000, priority = 1000)
  observeEvent(cutAbove_d(), {
    inputs$cutAbove <- suppressWarnings(as.numeric(trimws(cutAbove_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)
  
  cutBelow_d <- reactive(input$cutBelow) %>% debounce(1000, priority = 1000)
  observeEvent(cutBelow_d(), {
    inputs$cutBelow <- suppressWarnings(as.numeric(trimws(cutBelow_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  stripStart_d <- reactive(input$stripStart) %>% debounce(1000, priority = 1000)
  observeEvent(stripStart_d(), {
    inputs$stripStart <- suppressWarnings(as.numeric(trimws(stripStart_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  stripEnd_d <- reactive(input$stripEnd) %>% debounce(1000, priority = 1000)
  observeEvent(stripEnd_d(), {
    inputs$stripEnd <- suppressWarnings(as.numeric(trimws(stripEnd_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  giaTrend_d <- reactive(input$giaTrend) %>% debounce(1000, priority = 1000)
  observeEvent(giaTrend_d(), {
    inputs$giaTrend <- suppressWarnings(as.numeric(trimws(giaTrend_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  giaTrend2_d <- reactive(input$giaTrend2) %>% debounce(1000, priority = 1000)
  observeEvent(giaTrend2_d(), {
    inputs$giaTrend2 <- suppressWarnings(as.numeric(trimws(giaTrend2_d(), which = "both", whitespace = "[ \t\r\n]")))
  }, priority = 1000)

  breakEpoch_d <- reactive(input$breakEpoch) %>% debounce(1000, priority = 1000)
  observeEvent(breakEpoch_d(), {
    inputs$breakEpoch <- trimws(breakEpoch_d(), which = "both", whitespace = "[ \t\r\n]")
  }, priority = 1000)

  # Update data ####
  observeEvent(c(input$plot, input$sigmas, input$tab, input$format, input$tunits,
                 inputs$step, inputs$epoch, inputs$variable, inputs$errorBar, input$separator,
                 inputs$epoch2, inputs$variable2, inputs$errorBar2, input$separator2, input$format2, input$ne, inputs$scaleFactor,
                 input$fullSeries, info$db1, info$db2,
                 input$eulerType, trans$plate, trans$plate2, input$giaType, trans$gia, trans$gia2, input$neu1D,
                 db1[[info$db1]]$status1, db1[[info$db1]]$status2, db1[[info$db1]]$status3, db2[[info$db2]]), {
    req(isolate(db1[[info$db1]]))
    removeNotification("kf_not_valid")
    removeNotification("regular")
    if (input$tab > 3 || (isTruthy(info$tab) && info$tab > 3)) {
      req(info$stop)
    }
    if (messages > 0) cat(file = stderr(), mySession, "Updating dataset", "\n")

    isolate({
      table1 <- db1[[info$db1]]
      table2 <- db2[[info$db2]]
      status <- db1[[info$db1]][[paste0("status",input$tab)]]
    })

    if (isTruthy(input$ne)) {
      table2y_tmp <- table2$y2
      table2sy_tmp <- table2$sy2
      table2$y2 <- table2$y1
      table2$sy2 <- table2$sy1
      table2$y1 <- table2y_tmp
      table2$sy1 <- table2sy_tmp
    }

    # extracted series:
    # trans$y0  : all points from the original input series (including deleted with status NA)
    # trans$y   : points with TRUE status
    # trans$sy  : sigmas with TRUE status
    # trans$ye  : points with FALSE status (excluded)
    # trans$sye : sigmas with FALSE status (excluded)
    # trans$y2  : points from secondary series (independent)
    # trans$sy2 : sigmas from secondary series (independent)

    # set time axis
    if (!isTruthy(input$tunits) || input$tunits == 3) {
      trans$x0 <- table1$x3
      trans$x2 <- table2$x3
    } else if (input$tunits == 1) {
      trans$x0 <- table1$x1
      trans$x2 <- table2$x1
    } else if (input$tunits == 2) {
      trans$x0 <- table1$x2
      trans$x2 <- table2$x2
    }

    # extract data for each component
    if ((input$tab == 1) || (input$format == 4)) {
      trans$y0 <- as.numeric(table1$y1)
      trans$sy0 <- as.numeric(table1$sy1)
      trans$y2 <- as.numeric(table2$y1) * inputs$scaleFactor
      trans$sy2 <- as.numeric(table2$sy1) * inputs$scaleFactor
      status <- table1$status1
      if (isTruthy(trans$plate) && input$eulerType == 2 && info$db1 != "merged") {
        if (input$format == 4) {
          trans$y0 <- trans$y0 - trans$plate[as.numeric(input$neu1D)]*(trans$x0 - median(trans$x0[table1$status1], na.rm = T)) - median(trans$y0, na.rm = T)
        } else {
          trans$y0 <- trans$y0 - trans$plate[1]*(trans$x0 - median(trans$x0[table1$status1], na.rm = T)) - median(trans$y0, na.rm = T)
        }
      }
      if (input$format == 4 && isTruthy(trans$gia) && input$giaType == 2 && info$db1 != "merged") {
        trans$y0 <- trans$y0 - trans$gia[3]*(trans$x0 - median(trans$x0[table1$status1], na.rm = T)) - median(trans$y0, na.rm = T)
      }
      if (isTruthy(trans$plate2) && input$eulerType == 2) {
        if (input$format2 == 4) {
          trans$y2 <- trans$y2 - trans$plate2[as.numeric(input$neu1D)]*(trans$x2 - median(trans$x2, na.rm = T)) - median(trans$y2, na.rm = T)
        } else {
          trans$y2 <- trans$y2 - trans$plate2[1]*(trans$x2 - median(trans$x2, na.rm = T)) - median(trans$y2, na.rm = T)
        }
      }
      if (input$format2 == 4 && isTruthy(trans$gia2) && input$giaType == 2) {
        trans$y2 <- trans$y2 - trans$gia2[3]*(trans$x2 - median(trans$x2, na.rm = T)) - median(trans$y2, na.rm = T)
      }
    } else if (input$tab == 2) {
      trans$y0 <- as.numeric(table1$y2)
      trans$sy0 <- as.numeric(table1$sy2)
      trans$y2 <- as.numeric(table2$y2) * inputs$scaleFactor
      trans$sy2 <- as.numeric(table2$sy2) * inputs$scaleFactor
      status <- table1$status2
      if (isTruthy(trans$plate) && input$eulerType == 2 && info$db1 != "merged") {
        trans$y0 <- trans$y0 - trans$plate[2]*(trans$x0 - median(trans$x0[table1$status2], na.rm = T)) - median(trans$y0, na.rm = T)
      }
      if (isTruthy(trans$plate2) && input$eulerType == 2) {
        trans$y2 <- trans$y2 - trans$plate2[2]*(trans$x2 - median(trans$x2, na.rm = T)) - median(trans$y2, na.rm = T)
      }
    } else if (input$tab == 3) {
      trans$y0 <- as.numeric(table1$y3)
      trans$sy0 <- as.numeric(table1$sy3)
      trans$y2 <- as.numeric(table2$y3) * inputs$scaleFactor
      trans$sy2 <- as.numeric(table2$sy3) * inputs$scaleFactor
      status <- table1$status3
      if (isTruthy(trans$gia) && input$giaType == 2 && info$db1 != "merged") {
        trans$y0 <- trans$y0 - trans$gia[3]*(trans$x0 - median(trans$x0[table1$status1], na.rm = T)) - median(trans$y0, na.rm = T)
      }
      if (isTruthy(trans$gia2) && input$giaType == 2) {
        trans$y2 <- trans$y2 - trans$gia2[3]*(trans$x2 - median(trans$x2, na.rm = T)) - median(trans$y2, na.rm = T)
      }
    }
    # getting data range including excluded points
    trans$x <- trans$xe <- trans$x0
    trans$x <- trans$x[status & !is.na(status)]
    trans$xe <- trans$xe[!status & !is.na(status)]
    info$removed <- length(trans$x[!status | is.na(status)])
    transy <- trans$y0[!is.na(status)]
    info$miny <- min(transy, na.rm = T)
    info$maxy <- max(transy, na.rm = T)
    ids <- trans$x0[!is.na(status)] >= ranges$x1[1] & trans$x0[!is.na(status)] <= ranges$x1[2]
    if (sum(ids) > 0) {
      ranges$y1 <- range(transy[ids], na.rm = T)
      if (any(is.na(ranges$y1)) || any(is.infinite(ranges$y1))) {
        ranges$y1 <- c(info$miny, info$maxy)
      }
    } else {
      ranges$y1 <- c(info$miny, info$maxy)
    }
    # getting only valid points
    trans$y <- trans$y0[status & !is.na(status)]
    trans$ye <- trans$y0[!status & !is.na(status)]
    trans$sy <- trans$sy0[status & !is.na(status)]
    trans$sye <- trans$sy0[!status & !is.na(status)]
    if (length(file$secondary) > 0 && input$optionSecondary == 1 && any(!is.na(trans$y2))) {
      ids <- trans$x2[!is.na(trans$y2)] >= ranges$x1[1] & trans$x2[!is.na(trans$y2)] <= ranges$x1[2]
      if (sum(ids) > 0) {
        ranges$y12 <- range(trans$y2[ids], na.rm = T)
        if (any(is.na(ranges$y12)) || any(is.infinite(ranges$y12))) {
          ranges$y12 <- range(trans$y2, na.rm = T)
        }
      } else {
        ranges$y12 <- range(trans$y2, na.rm = T)
      }
    }
    # getting data sampling
    seriesInfo(trans$x)
    info$decimalsy <- info$decimalsyList[as.numeric(input$tab)]
    info$scientific <- info$scientificList[as.numeric(input$tab)]
    trans$ordinate <- median(trans$y)
    info$noise <- (sd(head(trans$y, 30)) + sd(tail(trans$y, 30)))/2
    # dealing with the kalman filter series
    if (input$fitType == 2 && length(trans$mod) > 0 && length(trans$res) > 0) {
      if (sum(status, na.rm = T) < sum(isolate(db1[[info$db1]]$status.kf), na.rm = T)) {
        trans$mod <- trans$mod0[!is.na(status) & status]
        trans$res <- trans$res0[!is.na(status) & status]
        trans$kalman <- trans$kalman0[!is.na(status) & status,]
        trans$kalman_unc <- trans$kalman_unc0[!is.na(status) & status,]
        showNotification(HTML("At least one point used in the KF fit was removed. The KF fit results are no longer valid.<br>Consider running it again."), action = NULL, duration = 10, closeButton = T, id = "kf_not_valid", type = "warning", session = getDefaultReactiveDomain())
        updateButton(session, inputId = "runKF", label = " Run KF", icon = icon("filter", class = NULL, lib = "font-awesome"), style = "danger")
      } else if (sum(status, na.rm = T) > sum(isolate(db1[[info$db1]]$status.kf), na.rm = T)) {
        info$run <- F
        trans$mod <- trans$mod0 <- NULL
        trans$res <- trans$res0 <- NULL
        trans$kalman <- trans$kalman0 <- NULL
        trans$kalman_unc <- trans$kalman_unc0 <- NULL
        showNotification("At least one point previously not used in the KF fit has been restored in the series. The KF fit is no longer valid. Consider running it again.", action = NULL, duration = 10, closeButton = T, id = "kf_not_valid", type = "warning", session = getDefaultReactiveDomain())
      } else if (any(is.na(trans$mod0[!is.na(status) & status]))) {
        info$run <- F
        trans$mod <- trans$mod0 <- NULL
        trans$res <- trans$res0 <- NULL
        trans$kalman <- trans$kalman0 <- NULL
        trans$kalman_unc <- trans$kalman_unc0 <- NULL
        showNotification(HTML("At least one point previously not used in the KF fit has been restored in the series. The KF fit is no longer valid.<br>Consider running it again."), action = NULL, duration = 10, closeButton = T, id = "kf_not_valid", type = "warning", session = getDefaultReactiveDomain())
      } else {
        trans$mod <- trans$mod0[!is.na(status) & status]
        trans$res <- trans$res0[!is.na(status) & status]
        trans$kalman <- trans$kalman0[!is.na(status) & status,]
        trans$kalman_unc <- trans$kalman_unc0[!is.na(status) & status,]
        updateButton(session, inputId = "runKF", label = " Run KF", icon = icon("filter", class = NULL, lib = "font-awesome"), style = "default")
      }
    }
    # setting sigmas to one if needed
    if (!isTruthy(input$sigmas)) {
      trans$sy <- rep(1, length(trans$sy))
      trans$sy0 <- rep(1, length(trans$sy0))
      trans$sye <- rep(1, length(trans$sye))
      trans$sy2 <- rep(1, length(trans$sy2))
    }
    # removing wavelet data
    if (input$waveletType > 0) {
      updateRadioButtons(session, inputId = "waveletType", label = NULL,
                         choices = list("None" = 0, "Original" = 1, "Model" = 2, "Model res." = 3, "Filter" = 4, "Filter res." = 5),
                         selected = 0, inline = T, choiceNames = NULL,  choiceValues = NULL)
      updateTextInput(session, "min_wavelet", value = "")
      updateTextInput(session, "max_wavelet", value = "")
      updateTextInput(session, "res_wavelet", value = "")
    }
    #
    if (isTruthy(debug)) {
      debugMem()
    }
  }, priority = 3)

  # Load SARI file ####
  observeEvent(input$loadSARI, {
    req(db1[[info$db1]])
    removeNotification("sari_version")
    removeNotification("format_not_compatible")
    removeNotification("no_model")
    removeNotification("no_sari")
    removeNotification("update_model")
    removeNotification("bad_LS")
    updateRadioButtons(session, inputId = "fitType", selected = 0)
    # extracting file header
    comments <- grep("^#", readLines(con = input$loadSARI$datapath, n = 100, ok = T, warn = F, skipNul = T), ignore.case = F, perl = T, value = T, fixed = F, useBytes = F, invert = F)
    if (isTruthy(comments) && grepl("^# SARI ", comments[1], ignore.case = F, perl = T)) {
      if (messages > 0) cat(file = stderr(), mySession, "Loading SARI file", "\n")
      # parsing header
      if (!grepl(version, comments[1], ignore.case = F, perl = T)) {
        showNotification("Warning: the SARI version used in the uploaded file is not the same as the current version", action = NULL, duration = 10, closeButton = T, id = "sari_version", type = "warning", session = getDefaultReactiveDomain())
      }
      if (sum(grepl("^# Model", comments, ignore.case = F, perl = T)) > 1) {
        showNotification("The format of the uploaded file is not compatible.", action = NULL, duration = 10, closeButton = T, id = "format_not_compatible", type = "error", session = getDefaultReactiveDomain())
      } else if (sum(grepl("^# Model", comments, ignore.case = F, perl = T)) < 1) {
        showNotification("No model found in the uploaded file.", action = NULL, duration = 10, closeButton = T, id = "no_model", type = "error", session = getDefaultReactiveDomain())
      } else {
        if (sum(grepl("^# Model .*KF", comments, ignore.case = F, perl = T)) > 0) {
          # this is a KF fit
          model <- grep("^# Model .*KF", comments, ignore.case = F, perl = T, value = T)
          if (nchar(model) > 18) {
            text <- strsplit(model, ")\\*|-|)|>|\\^")[[1]]
            aprioris <- grep("^# Initial: ", comments, ignore.case = F, perl = T, value = T)
            if (!isTruthy(aprioris)) {
              aprioris <- grep("^# A priori: ", comments, ignore.case = F, perl = T, value = T)
            }
            process_noises <- grep("^# Process noise: ", comments, ignore.case = F, perl = T, value = T)
            mn <- strsplit(grep("^# Measurement noise: ", comments, ignore.case = F, perl = T, value = T), ":")
            if (isTruthy(mn) && length(mn) > 0) {
              measurement_noise <- gsub("[a-zA-Z]", "", mn[[1]][2])
              updateTextInput(session, inputId = "ObsError", value = measurement_noise)
            }
            components <- c()
            # Extracting Intercept info
            if (grepl("Intercept", model, ignore.case = F, perl = T)) {
              index <- grep(" Intercept", aprioris, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              values <- strsplit(aprioris[index], "=|\\+\\/-")
              if (isTruthy(values) && length(values) > 0) {
                values <- values[[1]]
                updateTextInput(inputId = "Intercept0", value = values[2])
                updateTextInput(inputId = "eIntercept0", value = values[3])
              }
            }
            # Extracting Rate info
            if (grepl(" \\+ Rate", model, ignore.case = F, perl = T)) {
              updateTextInput(session, "trendRef", value = text[2])
              index <- grep(" Rate", aprioris, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              values <- strsplit(aprioris[index], "=|\\+\\/-")
              if (isTruthy(values) && length(values) > 0) {
                values <- values[[1]]
                updateTextInput(inputId = "Trend0", value = values[2])
                updateTextInput(inputId = "eTrend0", value = values[3])
              }
              index <- grep(" Rate", process_noises, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              values <- strsplit(process_noises[index], "=")
              if (isTruthy(values) && length(values) > 0) {
                values <- values[[1]]
                updateTextInput(inputId = "TrendDev", value = values[2])
              } else {
                updateTextInput(inputId = "TrendDev", value = "0.0")
              }
              components <- c(components, "Linear")
            }
            # Extracting Polynomial info
            if (grepl(" \\+ P", model, ignore.case = F, perl = T)) {
              index <- grep(" + P", text, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              updateTextInput(session, "PolyRef", value = text[index[1] + 1])
              updateTextInput(session, "PolyCoef", value = text[index[length(index)] + 3])
              index <- grep(" Initial: P", aprioris, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              if (!isTruthy(index)) {
                index <- grep(" A priori: P", aprioris, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              }
              values <- strsplit(aprioris[index], "=|\\+\\/-")
              updateTextInput(inputId = "P0", value = paste(sapply(values, "[[", 2), collapse = ", "))
              updateTextInput(inputId = "eP0", value = paste(sapply(values, "[[", 3), collapse = ", "))
              components <- c(components, "Polynomial")
            }
            # Extracting Sinusoidal info
            if (grepl(" \\+ S", model, ignore.case = F, perl = T)) {
              updateCheckboxInput(session, inputId = "GPSdrac", value = F)
              updateCheckboxInput(session, inputId = "GALdrac", value = F)
              updateCheckboxInput(session, inputId = "GLOdrac", value = F)
              updateCheckboxInput(session, inputId = "BDSdrac", value = F)
              index <- grep(" + S", text, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              updateTextInput(session, "periodRef", value = unique(text[index + 1]))
              if (input$tunits == 1) {
                units <- "d"
              } else if (input$tunits == 2) {
                units <- "w"
              } else if (input$tunits == 3) {
                units <- "y"
              }
              updateTextInput(session, "period", value = paste(paste0(1/as.numeric(text[index + 2]), units), collapse = ","))
              index <- grep(" Initial: S", aprioris, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              if (!isTruthy(index)) {
                index <- grep(" A priori: S", aprioris, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              }
              values <- strsplit(aprioris[index], "=|\\+\\/-")
              updateTextInput(inputId = "S0", value = paste(sapply(values, "[[", 2), collapse = ", "))
              updateTextInput(inputId = "eS0", value = paste(sapply(values, "[[", 3), collapse = ", "))
              index <- grep(" Process noise: S", process_noises, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              values <- strsplit(process_noises[index], "=")
              if (isTruthy(values)) {
                updateTextInput(inputId = "SinusoidalDev", value = paste(sapply(values, "[[", 2), collapse = ", "))
              } else {
                updateTextInput(inputId = "SinusoidalDev", value = paste(rep("0.0", length(index)), collapse = ","))
              }
              components <- c(components, "Sinusoidal")
            }
            # Extracting Offset info
            if (grepl(" \\+ O", model, ignore.case = F, perl = T)) {
              index <- grep("Initial: O", aprioris, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              if (!isTruthy(index)) {
                index <- grep("A priori: O", aprioris, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              }
              values <- strsplit(aprioris[index], "=|\\+\\/-")
              updateTextInput(inputId = "O0", value = paste(sapply(values, "[[", 2), collapse = ", "))
              updateTextInput(inputId = "eO0", value = paste(sapply(values, "[[", 3), collapse = ", "))
              index <- grep(" + O", text, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              updateTextInput(session, "offsetEpoch", value = paste(text[index + 1], collapse = ", "))
              components <- c(components, "Offset")
            }
            # Extracting Exponential info
            if (grepl(" \\+ E", model, ignore.case = F, perl = T)) {
              index <- grep(" + E", text, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              updateTextInput(session, "ExponenRef", value = paste(text[index + 1], collapse = ","))
              index <- grep(" Initial: E", aprioris, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              if (!isTruthy(index)) {
                index <- grep(" A priori: E", aprioris, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              }
              values <- strsplit(aprioris[index], "=|\\+\\/-")
              updateTextInput(session, "E0", value = paste(trimws(sapply(values, "[[", 2)), collapse = ", "))
              updateTextInput(session, "eE0", value = paste(trimws(sapply(values, "[[", 3)), collapse = ", "))
              index <- grep(" Initial: TauE", aprioris, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              if (!isTruthy(index)) {
                index <- grep(" A priori: TauE", aprioris, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              }
              values <- strsplit(aprioris[index], "=|\\+\\/-")
              updateTextInput(session, "TE0", value = paste(trimws(sapply(values, "[[", 2)), collapse = ", "))
              updateTextInput(session, "eTE0", value = paste(trimws(sapply(values, "[[", 3)), collapse = ", "))
              components <- c(components, "Exponential")
            }
            # Extracting Logarithmic info
            if (grepl(" \\+ L", model, ignore.case = F, perl = T)) {
              index <- grep(" + L", text, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              updateTextInput(session, "LogariRef", value = paste(text[index + 1], collapse = ","))
              index <- grep(" Initial: L", aprioris, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              if (!isTruthy(index)) {
                index <- grep(" A priori: L", aprioris, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              }
              values <- strsplit(aprioris[index], "=|\\+\\/-")
              updateTextInput(session, "L0", value = paste(trimws(sapply(values, "[[", 2)), collapse = ", "))
              updateTextInput(session, "eL0", value = paste(trimws(sapply(values, "[[", 3)), collapse = ", "))
              index <- grep(" Initial: TauL", aprioris, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              if (!isTruthy(index)) {
                index <- grep(" A priori: TauL", aprioris, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              }
              values <- strsplit(aprioris[index], "=|\\+\\/-")
              updateTextInput(session, "TL0", value = paste(trimws(sapply(values, "[[", 2)), collapse = ", "))
              updateTextInput(session, "eTL0", value = paste(trimws(sapply(values, "[[", 3)), collapse = ", "))
              components <- c(components, "Logarithmic")
            }
            updateCheckboxGroupInput(session, inputId = "model", label = "", choices = list("Linear","Polynomial","Sinusoidal","Offset","Exponential","Logarithmic"), selected = components, inline = T)
            updateRadioButtons(session, inputId = "fitType", label = NULL, list("None" = 0, "LS" = 1, "KF" = 2), selected = 2, inline = T, choiceNames = NULL, choiceValues = NULL)
            if (grepl("^# Model EKF", model, ignore.case = F, perl = T)) {
              updateRadioButtons(session, inputId = "kf", label = NULL, choices = list("EKF" = 1, "UKF" = 2), selected = 1, inline = T)
            } else if (grepl("^# Model UKF", model, ignore.case = F, perl = T)) {
              updateRadioButtons(session, inputId = "kf", label = NULL, choices = list("EKF" = 1, "UKF" = 2), selected = 2, inline = T)
            }
            info$menu <- unique(c(info$menu, 4))
            updateCollapse(session, id = "menu", open = info$menu)
          }
        } else {
          # This is a LS fit
          model <- grep("^# Model LS:", comments, ignore.case = F, perl = T, value = T)
          if (nchar(model) > 18) {
            breakpoints <- unlist(strsplit(sub("# Breakpoints at: ", "", grep("^# Breakpoints at:", comments, ignore.case = F, perl = T, value = T)), ","))
            trendType <- grepl("Rate2", model)
            sinusoidType <- grepl("S12", model)
            polyType <- grepl("P21", model)
            if (length(breakpoints) > 0) {
              updateCheckboxInput(session, inputId = "breaking", value = T)
              updateTextInput(session, inputId = "breakEpoch", value = breakpoints)
              if (trendType) {
                updateRadioButtons(session, inputId = "trendType", selected = 1)
              } else {
                updateRadioButtons(session, inputId = "trendType", selected = 0)
              }
              if (polyType) {
                model <- gsub("P..\\*\\(\\(x-\\d+\\.\\d+\\)\\^\\d+\\)\\*if\\(x\\>\\d+\\.\\d+", "", model, perl = T)
                updateRadioButtons(session, inputId = "polyType", selected = 1)
              } else {
                updateRadioButtons(session, inputId = "polyType", selected = 0)
              }
              if (sinusoidType) {
                model <- gsub("...\\*...\\(2\\*pi\\*\\(x-\\d+\\.\\d+\\)\\*\\d+\\)\\*if\\(x>\\d+\\.\\d+", "", model, perl = T)
                updateRadioButtons(session, inputId = "sinusoidType", selected = 1)
              } else {
                updateRadioButtons(session, inputId = "sinusoidType", selected = 0)
              }
            } else {
              updateRadioButtons(session, inputId = "trendType", selected = 0)
              updateRadioButtons(session, inputId = "polyType", selected = 0)
              updateRadioButtons(session, inputId = "sinusoidType", selected = 0)
              updateTextInput(session, inputId = "breakEpoch", value = "")
              updateCheckboxInput(session, inputId = "breaking", value = F)
            }
            text <- strsplit(model, ")\\*|-|)|>|\\^")[[1]]
            parameters <- grep("^# Parameter: ", comments, ignore.case = F, perl = T, value = T)
            components <- c()
            # Extracting Rate info
            if (grepl(" \\+ Rate", model, ignore.case = F, perl = T)) {
              updateTextInput(session, "trendRef", value = text[2])
              info$trendRef <- T
              components <- c(components, "Linear")
            }
            # Extracting Polynomial info
            if (grepl(" \\+ P", model, ignore.case = F, perl = T)) {
              index <- grep(" + P", text, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              updateTextInput(session, "PolyRef", value = text[index[1] + 1])
              updateTextInput(session, "PolyCoef", value = text[index[length(index)] + 3])
              info$PolyRef <- T
              components <- c(components, "Polynomial")
            }
            # Extracting Sinusoidal info
            if (grepl(" \\+ S", model, ignore.case = F, perl = T)) {
              updateCheckboxInput(session, inputId = "GPSdrac", value = F)
              updateCheckboxInput(session, inputId = "GALdrac", value = F)
              updateCheckboxInput(session, inputId = "GLOdrac", value = F)
              updateCheckboxInput(session, inputId = "BDSdrac", value = F)
              index <- grep(" + S", text, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              inputs$periodRef <- unique(text[index + 1])
              updateTextInput(session, "periodRef", value = inputs$periodRef)
              info$periodRef <- T
              if (input$tunits == 1) {
                units <- "d"
              } else if (input$tunits == 2) {
                units <- "w"
              } else if (input$tunits == 3) {
                units <- "y"
              }
              updateTextInput(session, "period", value = paste(paste0(1/as.numeric(text[index + 2]), units), collapse = ","))
              components <- c(components, "Sinusoidal")
            }
            # Extracting Offset info
            if (grepl(" \\+ O", model, ignore.case = F, perl = T)) {
              index <- grep(" + O", text, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              updateTextInput(session, "offsetEpoch", value = paste(text[index + 1], collapse = ", "))
              components <- c(components, "Offset")
            }
            # Extracting Exponential info
            if (grepl(" \\+ E", model, ignore.case = F, perl = T)) {
              index <- grep(" + E", text, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              updateTextInput(session, "ExponenRef", value = paste(text[index + 1], collapse = ","))
              index <- grep(" Parameter: E", parameters, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              values <- strsplit(parameters[index], "=|\\+\\/-")
              updateTextInput(session, "E0", value = paste(trimws(sapply(values, "[[", 2)), collapse = ", "))
              index <- grep(" Parameter: TauE", parameters, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              values <- strsplit(parameters[index], "=|\\+\\/-")
              updateTextInput(session, "TE0", value = paste(trimws(sapply(values, "[[", 2)), collapse = ", "))
              components <- c(components, "Exponential")
            }
            # Extracting Logarithmic info
            if (grepl(" \\+ L", model, ignore.case = F, perl = T)) {
              index <- grep(" + L", text, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              updateTextInput(session, "LogariRef", value = paste(text[index + 1], collapse = ","))
              index <- grep(" Parameter: L", parameters, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              values <- strsplit(parameters[index], "=|\\+\\/-")
              updateTextInput(session, "L0", value = paste(trimws(sapply(values, "[[", 2)), collapse = ", "))
              index <- grep(" Parameter: TauL", parameters, ignore.case = F, perl = F, value = F, fixed = T, useBytes = F, invert = F)
              values <- strsplit(parameters[index], "=|\\+\\/-")
              updateTextInput(session, "TL0", value = paste(trimws(sapply(values, "[[", 2)), collapse = ", "))
              components <- c(components, "Logarithmic")
            }
            info$menu <- unique(c(info$menu, 4))
            updateCollapse(session, id = "menu", open = info$menu)
            showNotification("Updating the model from the uploaded SARI file.", action = NULL, duration = 10, closeButton = T, id = "update_model", type = "warning", session = getDefaultReactiveDomain())
            shinyjs::delay(2000, updateRadioButtons(session, inputId = "fitType", selected = 1))
            shinyjs::delay(2100, updateCheckboxGroupInput(session, inputId = "model", choices = list("Linear","Polynomial","Sinusoidal","Offset","Exponential","Logarithmic"), inline = T, selected = components))
            shinyjs::delay(3000, removeNotification("update_model"))
          }
        }
      }
    } else {
      showNotification(HTML("Unable to find the SARI version in the uploaded file.<br><br>Is this a SARI file?"), action = NULL, duration = 10, closeButton = T, id = "no_sari", type = "warning", session = getDefaultReactiveDomain())
    }
  })

  # Plot series ####
  ## 1D ####
  output$plot1 <- output$plot2 <- output$plot3 <- renderPlot({
    req(db1[[info$db1]], trans$x, trans$y, trans$sy)
    if (input$tab < 4) {
      removeNotification("wrong_series")
      if (messages > 0) cat(file = stderr(), mySession, "Plotting the series", "\n")
      title <- ""
      sigmas <- F
      # check if plotting error polygons
      if (isTruthy(input$sigmas) && ((info$format == 4 && isTruthy(inputs$errorBar)) || input$format != 4)) {
        sigmas <- T
      }
      # setting plot symbol
      if (input$symbol == 0) {
        symbol <- 'p'
      } else if (input$symbol == 1) {
        symbol <- 'l'
      } else if (input$symbol == 2) {
        symbol <- 'o'
      }
      rangesy1 <- ranges$y1
      # check secondary series and plot it first
      if (length(isolate(file$secondary)) > 0 && input$optionSecondary == 1 && any(!is.na(trans$y2))) {
        # setting the right Y axis
        pointsX1 <- trans$x[trans$x > ranges$x1[1] & trans$x < ranges$x1[2]]
        pointsX2 <- trans$x2[trans$x2 > ranges$x1[1] & trans$x2 < ranges$x1[2]]
        pointsY1 <- trans$y[trans$x > ranges$x1[1] & trans$x < ranges$x1[2]]
        pointsY2 <- trans$y2[trans$x2 > ranges$x1[1] & trans$x2 < ranges$x1[2]]
        if (isTruthy(input$sameScale)) {
          rangesy12 <- range(pointsY2)
          if (isTruthy(rangesy1)) {
            range1 <- diff(rangesy1)
          } else {
            range1 <- diff(range(pointsY1))
          }
          range2 <- diff(rangesy12)
          if (input$fullSeries) {
            if (range1 >= range2) {
              rangesy12[1] <- rangesy12[1] - (range1 - range2)/2
              rangesy12[2] <- rangesy12[2] + (range1 - range2)/2
            } else {
              rangesy1[1] <- ranges$y1[1] - (range2 - range1)/2
              rangesy1[2] <- ranges$y1[2] + (range2 - range1)/2
            }
          } else {
            middle <- ifelse(isTruthy(pointsY2), median(pointsY2), 0)
            rangesy12 <- c(middle - range1/2, middle + range1/2)
          }
          # adjusting the vertical offset within the same scale (range)
          if (length(pointsX1) == 0 || length(pointsX2) == 0) {
            # NA
          } else if (pointsX2[1] > pointsX1[length(pointsX1)]) {
            # NA
          } else if (pointsX1[1] > pointsX2[length(pointsX2)]) {
            # NA
          } else {
            tie1 <- sort(sapply(pointsX1, function(x) min(abs(pointsX2 - x))), index.return = T)$ix
            tie2 <- sort(sapply(pointsX2, function(x) min(abs(pointsX1 - x))), index.return = T)$ix
            tie1 <- tie1[1:min(length(tie1),length(tie2))]
            tie2 <- tie2[1:min(length(tie1),length(tie2))]
            pointsBias <- median(pointsY1[tie1] - pointsY2[tie2], na.rm = T)
            if (input$fullSeries) {
              if (range1 >= range2) {
                rangesy12 <- rangesy12 + (rangesy1[1] - rangesy12[1]) - pointsBias
              } else {
                rangesy1 <- rangesy1 + (rangesy12[1] - rangesy1[1]) + pointsBias
              }
            } else {
              rangesy12 <- rangesy12 + (rangesy1[1] - rangesy12[1]) - pointsBias
            }
          }
        } else if (isTruthy(input$same_axis)) {
          if (input$fullSeries) {
            range <- range(c(pointsY1,pointsY2))
            rangesy12 <- rangesy1 <- range
          } else {
            if (isTruthy(rangesy1)) {
              rangesy12 <- rangesy1
            } else {
              rangesy12 <- range(pointsY1)
            }
          }
        } else {
          ids <- trans$x2 >= ranges$x1[1] & trans$x2 <= ranges$x1[2]
          if (sum(ids) > 0) {
            rangesy12 <- range(trans$y2[ids], na.rm = T)
          } else {
            rangesy12 <- range(trans$y2, na.rm = T)
          }
        }
        ranges$y12 <- rangesy12
        plot(trans$x2, trans$y2, type = symbol, lwd = 2, cex = 1.1, pch = 23, col = SARIcolors[3], axes = F, xlab = NA, ylab = NA, xlim = ranges$x1, ylim = rangesy12)
        if (isTruthy(sigmas)) {
          color <- SARIcolors[3]
          alfa <- 0.2
          shade <- adjustcolor(color, alpha.f = alfa)
          ba <- trans$y2 + trans$sy2
          bb <- trans$y2 - trans$sy2
          polygon(c(trans$x2, rev(trans$x2)), c(ba, rev(bb)), col = shade, border = NA)
        }
        axis(side = 4, at = NULL, labels = T, tick = T, line = NA, pos = NA, outer = F)
        par(new = T)
      }
      # plotting primary series
      plot_series(trans$x,trans$y,trans$sy,ranges$x1,rangesy1,sigmas,title,input$symbol,T,info$tunits.label)
      # plotting excluded points
      points(trans$xe, trans$ye, type = "p", col = SARIcolors[2], bg = 2, pch = 21)
      # plotting plate and GIA model predictions
      xx <- median(trans$x[trans$x > ranges$x1[1] & trans$x < ranges$x1[2]], na.rm = T)
      yy <- median(trans$y[trans$x > ranges$x1[1] & trans$x < ranges$x1[2]], na.rm = T)
      centerx <- which(abs(trans$x - xx) == min(abs(trans$x - xx)))[1]
      centery <- which(abs(trans$y - yy) == min(abs(trans$y - yy)))[1]
      if (input$format == 4) {
        if (input$eulerType == 1 && length(trans$plate[!is.na(trans$plate)]) == 3) {
          rate <- trans$plate[as.numeric(input$neu1D)]
        } else if (isTruthy(input$gia) && input$giaType == 1 && length(trans$gia[!is.na(trans$gia)]) == 3) {
          rate <- trans$gia[3]
        }
      } else {
        if (input$tab == 1 || input$tab == 2) {
          if (input$eulerType == 1 && length(trans$plate[!is.na(trans$plate)]) == 3) {
            rate <- trans$plate[as.numeric(input$tab)]
          }
        } else if (input$giaType == 1 && length(trans$gia[!is.na(trans$gia)]) == 3) {
          rate <- trans$gia[3]
        }
      }
      if (exists("rate") && is.numeric(rate)) {
        lines(c(trans$x[1],trans$x[length(trans$x)]),c(trans$y[centery] + rate*(trans$x[1] - trans$x[centerx]),trans$y[centery] + rate*(trans$x[length(trans$x)] - trans$x[centerx])), col = SARIcolors[4], lwd = 3)
      }
      # plotting vertical lines
      if (input$traceLog && length(info$log) > 0) {
        for (r in info$log[[2]]) {
          abline(v = r, col = SARIcolors[4], lty = 2)
        }
        for (a in info$log[[1]]) {
          abline(v = a, col = SARIcolors[4])
        }
      }
      if (input$traceSinfo && length(info$sinfo) > 0) {
        for (r in info$sinfo[[2]]) {
          abline(v = r, col = SARIcolors[6], lty = 2)
        }
        for (a in info$sinfo[[1]]) {
          abline(v = a, col = SARIcolors[6])
        }
      }
      if (input$traceSoln && length(info$soln) > 0) {
        for (r in info$soln[[2]]) {
          abline(v = r, col = SARIcolors[8], lty = 2)
        }
        for (a in info$soln[[1]]) {
          abline(v = a, col = SARIcolors[8])
        }
      }
      if (input$traceCustom && length(info$custom) > 0) {
        for (r in info$custom[[2]]) {
          abline(v = r, col = SARIcolors[5], lty = 2)
        }
        for (a in info$custom[[1]]) {
          abline(v = a, col = SARIcolors[5])
        }
      }
      if (input$breaking && isTruthy(trans$breakEpochs) && (input$trendType > 0 || input$sinusoidType > 0 || input$polyType > 0)) {
        for (p in trans$breakEpochs) {
          abline(v = p, col = SARIcolors[3], lwd = 2, lty = 3)
        }
      }
      # plotting fit results
      if (length(trans$mod) > 0 && isTruthy(info$run)) {
        lines(trans$x,trans$mod, col = SARIcolors[2], lwd = 3)
      }
      if (length(trans$filter) > 0 && input$filter == T && input$series2filter == 1) {
        lines(trans$x,trans$filter, col = SARIcolors[7], lwd = 3)
      }
      # show/hide zoom-in tag
      if (ranges$x1[1] > info$minx || ranges$x1[2] < info$maxx) {
        shinyjs::show(paste0("zoomin",input$tab))
      } else {
        shinyjs::hide(paste0("zoomin",input$tab))
      }
      # updating the overview plot
      updateOverview()
      # print clicks on plot
      output$plot1_info <- output$plot2_info <- output$plot3_info <- renderText({
        if (length(input$plot_1click$x) > 0 && length(input$plot_brush) == 0 && length(input$res_brush) == 0) {
          paste("Plot coordinates = ", input$plot_1click$x, input$plot_1click$y, sep = "\t")
        }
      })
    }
  }, width = reactive(info$width))

  ## 3D ####
  output$plot41 <- renderPlot({
    if (input$tab == 4) {
      plot3series(1)
    }
  }, width = reactive(info$width))
  output$plot42 <- renderPlot({
    if (input$tab == 4) {
      plot3series(2)
    }
  }, width = reactive(info$width))
  output$plot43 <- renderPlot({
    if (input$tab == 4) {
      plot3series(3)
    }
  }, width = reactive(info$width))

  # Print clicks on the 3D tab
  output$plot4_info <- renderPrint({
    line1 <- line2 <- line3 <- NULL
    if (length(input$plot41_1click$x) > 0 && length(input$plot41_brush) == 0) {
      x <- input$plot41_1click$x
      y <- input$plot41_1click$y
      line1 <- paste("Plot 1 coordinates =", x, y, sep = "\t")
    }
    if (length(input$plot42_1click$x) > 0 && length(input$plot42_brush) == 0) {
      x <- input$plot42_1click$x
      y <- input$plot42_1click$y
      line2 <- paste("Plot 2 coordinates =", x, y, sep = "\t")
    }
    if (length(input$plot43_1click$x) > 0 && length(input$plot43_brush) == 0) {
      x <- input$plot43_1click$x
      y <- input$plot43_1click$y
      line3 <- paste("Plot 3 coordinates =", x, y, sep = "\t")
    }
    if (isTruthy(line1) || isTruthy(line2) || isTruthy(line3)) {
      cat('', line1, '\n', line2, '\n', line3, '\n')
    }
  })

  # MIDAS ####
  observeEvent(c(input$midas, trans$y, trans$offsetEpochs, input$tunits), {
    req(trans$x, trans$y, info$tol)
    if (isTruthy(input$midas)) {
      # setting lag period
      if (input$tunits == 1) {
        period <- 365
      } else if (input$tunits == 2) {
        period <- 52
      } else if (input$tunits == 3) {
        period <- 1
      }
      if ((info$rangex / period) < 1) {
        showNotification("Not enough data available to compute interannual differences.", action = NULL, duration = 10, closeButton = T, id = "no_interannual", type = "error", session = getDefaultReactiveDomain())
        updateCheckboxInput(session, inputId = "midas", label = NULL, value = F)
        req(info$stop)
      }
      if (messages > 0) cat(file = stderr(), mySession, "Computing MIDAS", "\n")
      if (length(trans$x) > 6) {
        withProgress(message = 'Computing MIDAS trend.',
                     detail = 'This may take a while ...', value = 0, {
                       setProgress(0)
                       vel <- sapply(1:length(trans$x), function(x) midas_vel(m = x, t = period, disc = 0, trans$x, trans$y))
                       vel <- c(vel[1,],vel[2,])
                       vel <- vel[vel > -999999]
                       if (length(vel) > 9) {
                         vel_sig <- 1.4826*mad(vel, na.rm = T)
                         vel_lim <- c(median(vel) + 2*vel_sig, median(vel) - 2*vel_sig)
                         vel_good <- vel[vel < vel_lim[1] & vel > vel_lim[2]]
                         vel_mad <- mad(vel_good, na.rm = T)
                         trans$midas_vel <- median(vel_good)
                         trans$midas_sig <- 1.2533*1.4826*vel_mad/sqrt(length(vel_good)/4)
                         trans$midas_all <- vel_good
                       } else {
                         showNotification("Not enough interannual differences to compute a reliable trend.", action = NULL, duration = 10, closeButton = T, id = "no_interannual", type = "error", session = getDefaultReactiveDomain())
                         updateCheckboxInput(session, inputId = "midas", label = NULL, value = F)
                       }
                       if (length(trans$offsetEpochs) > 0 && "Offset" %in% isolate(input$model)) {
                         setProgress(0)
                         vel <- sapply(1:length(trans$x), function(x) midas_vel(m = x, t = period, disc = 1, trans$x, trans$y))
                         vel <- c(vel[1,],vel[2,])
                         vel <- vel[vel > -999999]
                         if (length(vel) > 9) {
                           vel_sig <- 1.4826*mad(vel, na.rm = T)
                           vel_lim <- c(median(vel) + 2*vel_sig, median(vel) - 2*vel_sig)
                           vel_good <- vel[vel < vel_lim[1] & vel > vel_lim[2]]
                           vel_mad <- mad(vel_good, na.rm = T)
                           trans$midas_vel2 <- median(vel_good)
                           trans$midas_sig2 <- 1.2533*1.4826*vel_mad/sqrt(length(vel_good)/4)
                           trans$midas_all <- vel_good
                         } else {
                           showNotification("Not enough interannual differences to compute a reliable trend.", action = NULL, duration = 10, closeButton = T, id = "no_interannual", type = "error", session = getDefaultReactiveDomain())
                           updateCheckboxInput(session, inputId = "midas", label = NULL, value = F)
                         }
                       } else {
                         trans$midas_vel2 <- NULL
                       }
                     })
      } else {
        showNotification("Not enough interannual differences to compute a reliable trend.", action = NULL, duration = 10, closeButton = T, id = "no_interannual", type = "error", session = getDefaultReactiveDomain())
        updateCheckboxInput(session, inputId = "midas", label = NULL, value = F)
      }
    } else {
      trans$midas_vel <- NULL
    }
    #
    if (isTruthy(debug)) {
      debugMem()
    }
  })

  # Plot MIDAS histogram ####
  output$midas_hist1 <- output$midas_hist2 <- output$midas_hist3 <- renderPlot({
    req(db1[[info$db1]], input$midas, trans$midas_all)
    if (messages > 0) cat(file = stderr(), mySession, "MIDAS histogram", "\n")
    if (input$tunits == 1) {
      period <- "day"
    } else if (input$tunits == 2) {
      period <- "week"
    } else if (input$tunits == 3) {
      period <- "year"
    }
    if (input$sunits == 1) {
      units <- paste0("(m/",period,")")
    } else if (input$sunits == 2) {
      units <- paste0("(mm/",period,")")
    } else {
      units <- ""
    }
    values <- trans$midas_all
    hist(values, breaks = "FD", freq = F, xlab = paste("Selected interannual velocities", units), ylab = "", main = "MIDAS velocity histogram", col = SARIcolors[4])
    dnorm(values, mean = mean(values, na.rm = T), sd = sd(values), log = F)
    xfit <- seq(min(values),max(values),length = 40)
    yfit <- dnorm(xfit,mean = mean(values, na.rm = T),sd = sd(values))
    lines(xfit, yfit, col = SARIcolors[2], lwd = 3)
  }, width = reactive(info$width))

  # Minimum entropy ####
  observeEvent(c(input$entropy, trans$y, trans$offsetEpochs, inputs$offsetEpoch.entropy, info$rangex), {
    removeNotification("bad_entropy")
    removeNotification("different_offsets")
    removeNotification("bad_offset_epoch")
    req(trans$x, trans$y)
    if (isTruthy(input$entropy)) {
      # checking offset epochs provided for the entropy analysis
      offsetEpoch.entropy <- NULL
      if (isTruthy(inputs$offsetEpoch.entropy)) {
        offsetEpoch.entropy <- trimws(unlist(strsplit(inputs$offsetEpoch.entropy, split = ",")))
        offsetEpoch.entropy_all <- offsetEpoch.entropy
        # check for valid numeric values
        not_numeric <- suppressWarnings(which(is.na(as.numeric(offsetEpoch.entropy))))
        if (length(not_numeric) > 0) {
          offsetEpoch.entropy <- offsetEpoch.entropy[-not_numeric]
          showNotification(HTML(paste("The epoch given for offset(s)", paste0("#",not_numeric, collapse = " "), "is not numeric.<br>These offsets were skipped.")), action = NULL, duration = 10, closeButton = T, id = "not_numeric_offset", type = "warning", session = getDefaultReactiveDomain())
        }
        offsetEpoch.entropy <- as.numeric(offsetEpoch.entropy)
        if (length(offsetEpoch.entropy) > 0) {
          # check for soln without observations
          offsetEpoch.entropy_sorted <- suppressWarnings(sort(offsetEpoch.entropy, na.last = NA))
          if (length(offsetEpoch.entropy_sorted) > 1) {
            invalidSegment <- sapply(seq(length(offsetEpoch.entropy_sorted) - 1), function(x) length(trans$x[trans$x > offsetEpoch.entropy_sorted[x] & trans$x < offsetEpoch.entropy_sorted[x + 1]]) ) == 0
            for (soln in which(invalidSegment)) {
              uselessOffset_id <- which.min(abs(offsetEpoch.entropy - offsetEpoch.entropy_sorted[soln]))
              uselessOffset_id1 <- which.min(abs(suppressWarnings(as.numeric(offsetEpoch.entropy_all) - offsetEpoch.entropy_sorted[soln])))
              uselessOffset_id2 <- which.min(abs(suppressWarnings(as.numeric(offsetEpoch.entropy_all) - offsetEpoch.entropy_sorted[soln + 1])))
              offsetEpoch.entropy <- offsetEpoch.entropy[-uselessOffset_id]
              showNotification(HTML(paste0("There are no observations between offsets #", uselessOffset_id1, " and #", uselessOffset_id2,".<br>The first offset was skipped")), action = NULL, duration = 10, closeButton = T, id = "bad_offset_epoch", type = "warning", session = getDefaultReactiveDomain())
            }
          }
          # check for offsets outside data limits
          toremove <- 999999
          for (i in seq_len(length(offsetEpoch.entropy))) {
            if (offsetEpoch.entropy[i] > trans$x[length(trans$x)] || offsetEpoch.entropy[i] < trans$x[1]) {
              uselessOffset_id <- which.min(abs(suppressWarnings(as.numeric(offsetEpoch.entropy_all) - offsetEpoch.entropy[i])))
              toremove <- c(toremove, i)
              showNotification(HTML(paste0("There are no observations before or after offset #", uselessOffset_id,".<br>This offset was skipped.")), action = NULL, duration = 10, closeButton = T, id = "bad_offset_epoch", type = "warning", session = getDefaultReactiveDomain())
            }
          }
          offsetEpoch.entropy <- offsetEpoch.entropy[-toremove]
        }
      }
      trans$offsetEpoch.entropy <- offsetEpoch.entropy
      # updating the list of entropy offsets with the LS offsets
      if (isTruthy(input$model)) {
        if (length(setdiff(trans$offsetEpochs,trans$offsetEpoch.entropy)) > 0) {
          breaks <- paste(unique(sort(c(trans$offsetEpochs,offsetEpoch.entropy))), collapse = ", ")
          updateTextInput(session, inputId = "offsetEpoch.entropy", value = breaks)
          req(info$stop)
        }
        if (length(trans$offsetEpochs) < length(offsetEpoch.entropy)) {
          showNotification(HTML("Warning: there are more offset epochs used in the entropy estimate than in the LS estimate.<br>Check all the offset epochs are correct for the entropy estimate."), action = NULL, duration = 10, closeButton = T, id = "different_offsets", type = "warning", session = getDefaultReactiveDomain())
        }
      }
      if (messages > 0) cat(file = stderr(), mySession, "Computing entropy", "\n")
      # getting velocity samples to be tested
      ap <- try(unname(summary(lm(trans$y~trans$x))$coefficients)[2,1:2], silent = T)
      if (!isTruthy(ap) || inherits(ap,"try-error")) {
        ap <- c(0,1)
      }
      ap.1 <- ap[1] - ap[2]*100
      ap.2 <- ap[1] + ap[2]*100
      vel_samples <- 200
      incr <- (ap.2 - ap.1)/vel_samples
      aps <- seq(ap.1,ap.2,incr)
      # estimating the entropy for each velocity
      time <- ceiling(0.0009 * info$points) + 1
      withProgress(message = 'Optimizing min entropy.',
                   detail = paste("This should take about", time, "s"), value = 0, {
                     setProgress(0.3) # just for progress bar lovers
                     H <- sapply(aps, function(v) compute_entropy(v))
                     setProgress(0.7)
                     Sys.sleep(0.5)
                     setProgress(1)
                   })
      # getting the velocity estimate from the minimum entropy
      if (any(H == 0)) {
        trans$entropy_vel <- trans$entropy_sig <- NULL
        showNotification(HTML("Unable to compute the entropy value.<br>The series may be a constant value."), action = NULL, duration = 10, closeButton = T, id = "bad_entropy", type = "error", session = getDefaultReactiveDomain())
      } else {
        minH <- which.min(H)
        if (minH < 10 || minH > vel_samples - 10) {
          showNotification(HTML("The minimim entropy value may not be optimal.<br>The series may not be linear or some discontinuities may need to be removed."), action = NULL, duration = 10, closeButton = T, id = "bad_entropy", type = "warning", session = getDefaultReactiveDomain())
        }
        trans$entropy_vel <- aps[minH]
        # roughly reducing the series length due to offsets
        n <- 0
        breaks <- unique(sort(c(trans$x[1],trans$offsetEpochs,offsetEpoch.entropy,trans$x[length(trans$x)])))
        for (i in seq_len(length(breaks) - 1)) {
          segment <- trans$x >= breaks[i] & trans$x < breaks[i + 1]
          n <- ifelse(sum(segment) > n, sum(segment), n)
        }
        l <- (n + 2*info$points) / (3*info$points) # longest segment counts at least 2/3 of total length
        # compute the velocity uncertainty
        trans$entropy_sig <- 2^(min(H) - 2.0471) / (info$rangex * l)
      }
    } else {
      trans$entropy_vel <- trans$entropy_sig <- NULL
    }
    #
    if (isTruthy(debug)) {
      debugMem()
    }
  })

  # Offset verification ####
  observeEvent(c(input$runVerif), {
    req(trans$res, trans$x, trans$offsetEpochs)
    if (isTruthy(input$verif_offsets) &&
        ((nchar(inputs$verif_white) > 0 && !is.na(inputs$verif_white) && inputs$verif_white > 0) ||
        (nchar(input$verif_pl) > 0 && nchar(input$verif_k) > 0 && !is.na(inputs$verif_pl) && !is.na(inputs$verif_k) && inputs$verif_pl > 0 && inputs$verif_k <= 0) ||
        (nchar(inputs$verif_fl) > 0 && !is.na(inputs$verif_fl) && inputs$verif_fl > 0) ||
        (nchar(inputs$verif_rw) > 0 && !is.na(inputs$verif_rw) && inputs$verif_rw > 0))) {
      if (input$fitType == 1) {
        offsets <- grep(pattern = "O", rownames(trans$LScoefs), ignore.case = F, perl = F, fixed = T)
      } else if (input$fitType == 2) {
        offsets <- grep(pattern = "O", colnames(trans$kalmanman), ignore.case = F, perl = F, fixed = T)
      }
      if (length(offsets) != length(trans$offsetEpochs)) {
        showNotification("Unable to verify the significance of the estimated offsets.", action = NULL, duration = 10, closeButton = T, id = NULL, type = "error", session = getDefaultReactiveDomain())
        req(info$stop)
      }
      if (messages > 0) cat(file = stderr(), mySession, "Verifying offsets", "\n")
      n <- length(trans$res)
      n_all <- length(trans$gaps)
      C <- matrix(0,n,n)
      scaling <- 10^signifdecimal(sd(trans$res), T)
      if (isTruthy(inputs$verif_fl) || isTruthy(inputs$verif_rw) || isTruthy(inputs$verif_pl)) {
        estimatedTime <- as.integer(ceiling((1.3547*exp(0.0007*n) + 7*length(trans$offsetEpochs))/60))
      } else {
        estimatedTime <- as.integer(ceiling((1.3988*exp(0.0006*n) + 7*length(trans$offsetEpochs))/60))
      }
      withBusyIndicatorServer("runVerif", {
        withProgress(message = 'Verifying offset values.',
                     detail = paste("This should take about", estimatedTime, "min"), value = 0, {
                       start.time <- Sys.time()
                       # setting the expected covariance matrix
                       if (isTruthy(inputs$verif_white) && inputs$verif_white > 0) {
                         C <- C + as.numeric(inputs$verif_white)^2 * diag(n) * scaling^2
                       }
                       if (isTruthy(inputs$verif_fl) && inputs$verif_fl > 0) {
                         Cfl <- cov_powerlaw(-1,n_all,F,trans$gaps,info$sampling)[[1]]
                         C <- C + as.numeric(inputs$verif_fl)^2 * Cfl * scaling^2
                       }
                       if (isTruthy(inputs$verif_rw) && inputs$verif_rw > 0) {
                         Crw <- cov_powerlaw(-2,n_all,F,trans$gaps,info$sampling)[[1]]
                         C <- C + as.numeric(inputs$verif_rw)^2 * Crw * scaling^2
                       }
                       if (isTruthy(inputs$verif_pl) && inputs$verif_pl > 0 && isTruthy(inputs$verif_k) && inputs$verif_k < 0) {
                         k <- as.numeric(inputs$verif_k)
                         Cpl <- cov_powerlaw(k,n_all,F,trans$gaps,info$sampling)[[1]]
                         C <- C + as.numeric(inputs$verif_pl)^2 * Cpl * scaling^2
                       } else {
                         updateTextInput(session, inputId = "verif_pl", value = "")
                         updateTextInput(session, inputId = "verif_k", value = "")
                       }
                       setProgress(0.2)
                       if (!all(C == 0)) {
                         trans$verif <- F
                         y0 <- (trans$res - mean(trans$res)) * scaling
                         line <- c()
                         for (i in seq_len(length(trans$offsetEpochs))) {
                           setProgress(0.2 + ((i - 1)*0.8/length(trans$offsetEpochs)))
                           # adding the estimated offsets to the residual series
                           if (input$fitType == 1) {
                             offsets <- grep(pattern = "O", rownames(trans$LScoefs), ignore.case = F, perl = F, fixed = T)
                             ya <- y0 + trans$LScoefs[offsets[i]]*scaling*I(trans$x > trans$offsetEpochs[i])
                           } else if (input$fitType == 2) {
                             offsets <- grep(pattern = "O", colnames(trans$kalmanman), ignore.case = F, perl = F, fixed = T)
                             ya <- y0 + colMeans(trans$kalmanman)[offsets[i]]*scaling*I(trans$x > trans$offsetEpochs[i])
                           }
                           # estimate likelihood ratio and significance
                           Tq <- crossprod(ya, solve(C, ya)) - crossprod(y0, solve(C, y0))
                           line <- c(line, paste("Offset",i,"significance:", sprintf("%.0f",pchisq(Tq, df = 1)*100),"%", sep = " "))
                         }
                         setProgress(1)
                         Sys.sleep(1)
                         if (isTruthy(Tq)) {
                           trans$verif <- T
                         }
                       }
                     })
        end.time <- Sys.time()
      })
    } else {
      trans$verif <- F
    }
    # Print results on the left panel
    output$verif <- renderUI({
      if (isTruthy(trans$verif)) {
        HTML(paste0(paste(line,"<br/>")))
      } else {
        NULL
      }
    })
    #
    if (isTruthy(debug)) {
      debugMem()
    }
  })

  # LS fit ####
  observeEvent(c(input$model, input$sigmas, inputs$LogariRef, inputs$L0, inputs$TL0, inputs$ExponenRef, inputs$E0,
                 inputs$TE0, inputs$offsetEpoch, inputs$period, inputs$periodRef, inputs$trendRef, input$fitType,
                 input$tab, inputs$PolyRef, inputs$PolyCoef, input$P0, input$correct_waveform, inputs$step, input$tunits,
                 trans$y, trans$sy,
                 trans$breakEpochs, input$trendType, input$sinusoidType, input$polyType,
                 info$LStol), {
    req(trans$x, trans$y, trans$sy, trans$ordinate)
    removeNotification("bad_errorbar")
    removeNotification("bad_sinusoidal")
    removeNotification("bad_LS")
    removeNotification("overfit")
    if (input$tab > 3) {
      req(info$stop)
    }
    output$offsetFound <- renderUI({ NULL })
    output$est.white <- renderUI({ NULL })
    output$est.flicker <- renderUI({ NULL })
    output$est.randomw <- renderUI({ NULL })
    output$est.powerl <- renderUI({ NULL })
    output$est.index <- renderUI({ NULL })
    output$est.mle <- renderUI({ NULL })
    output$est.unc <- renderUI({ NULL })
    trans$noise <- NULL
    trans$mle <- F
    if (length(input$model) > 0) {
      if (input$fitType == 1) {
        if (messages > 0) cat(file = stderr(), mySession, "LS fit", "\n")
        # check if model changes are worth to continue
        if (isTruthy(trans$model_old)) {
          if (length(trans$model_old) < length(input$model)) {
            changes <- setdiff(input$model,trans$model_old)
          } else {
            changes <- setdiff(trans$model_old,input$model)
          }
          if (isTruthy(changes) &&
              (("Offset" %in% changes && !isTruthy(inputs$offsetEpoch)) ||
               ("Exponential" %in% changes && !isTruthy(inputs$ExponenRef)) ||
               ("Logarithmic" %in% changes && !isTruthy(inputs$LogariRef)) ||
               ("Polynomial" %in% changes && !isTruthy(inputs$PolyCoef)))) { # not worth
            trans$model_old <- as.list(input$model)
            req(info$stop)
          }
        } else {
          showNotification("Preparing least squares fitting.", action = NULL, duration = 10, closeButton = T, id = "preparingLS", type = "warning", session = getDefaultReactiveDomain())
        }
        trans$model_old <- input$model
        x <- trans$x
        y <- trans$y - trans$ordinate
        # removing waveform before the fitting
        if (isTruthy(input$correct_waveform)) {
          if (length(trans$pattern) > 0) {
            y <- y - trans$pattern
          } else {
            updateCheckboxInput(session, inputId = "correct_waveform", value = F)
            updateCheckboxInput(session, inputId = "waveform", label = NULL, value = F)
          }
        }
        sy <- trans$sy
        if (any(sy <= 0) || any(is.na(sy))) {
          showNotification(HTML("Some errorbar values are not valid.<br>No weighting applied."), action = NULL, duration = 10, closeButton = T, id = "bad_errorbar", type = "error", session = getDefaultReactiveDomain())
          sy <- rep(0.01, length(y))
          updateCheckboxInput(session, inputId = "sigmas", label = NULL, value = F)
        }
        weights <- 1/(sy^2)
        # set model equation and a priori values
        m <- model(x,y)
        removeNotification("preparingLS")
        if (isTruthy(info$run) && isTruthy(m)) {
          info$run <- F
          trans$mle <- F
          trans$verif <- NULL
          req(m$model_lm, m$model_nls, m$apriori)
          if (messages > 1) cat(file = stderr(), mySession, m$model_nls, "\n")
          # run fit
          fit <- NULL
          if (grepl("L1",m$model_nls) || grepl("E1",m$model_nls)) {
            model <- m$model_nls
            apriori <- m$apriori
            fit <- try(nls(as.formula(model), model = T, start = apriori, trace = F, weights = weights, control = nls.control(tol = info$LStol, minFactor = 1e-10, warnOnly = F, printEval = F, scaleOffset = 1)), silent = F)
          } else {
            model <- m$model_lm
            I <- function(a,b) { ifelse(x >= a & x < b, 1, 0) }
            R <- function(a,b) { ifelse(x >= a & x < b, x - as.numeric(inputs$trendRef), 0) }
            P <- function(a,b,c) { ifelse(x >= a & x < b, (x - as.numeric(inputs$PolyRef))^c, 0) }
            S <- function(a,b,c) { ifelse(x >= a & x < b, sin(2*pi*(x - as.numeric(inputs$periodRef))*c), 0) }
            C <- function(a,b,c) { ifelse(x >= a & x < b, cos(2*pi*(x - as.numeric(inputs$periodRef))*c), 0) }
            O <- function(a) { ifelse(x > a, 1, 0) }
            fit <- try(lm(as.formula(model), weights = weights), silent = F)
          }
          if (!inherits(fit,"try-error") && !is.null(fit)) {
            if (!grepl("L1",m$model_nls) && !grepl("E1",m$model_nls)) {
              if (fit$rank == length(info$parameters)) {
                names(fit$coefficients) <- info$parameters
              } else {
                showNotification(paste0("Problem computing the parameters: ",paste(names(which(is.na(fit$coefficients))), collapse = ", ")), action = NULL, duration = 10, closeButton = T, id = "bad_rank", type = "error", session = getDefaultReactiveDomain())
                req(info$stop)
              }
            }
            synthesis <- summary(fit,correlation = T, signif.stars = T)
            if (grepl("L1",m$model_nls) || grepl("E1",m$model_nls)) {
              jacobian <- fit$m$gradient()/sqrt(weights)
              # format model equation
              synthesis$formula <- deparse(synthesis$formula)
              synthesis$formula <- gsub(" > ", ">", gsub(" - ", "-", gsub(" \\* ", "\\*", gsub("))", ")", gsub("I\\(cos", "cos", gsub("I\\(sin", "sin", gsub("^ *|(?<= ) | *$", "", Reduce(paste, synthesis$formula), perl = TRUE)))))))
            } else {
              jacobian <- model.matrix(fit)
            }
            # transforming the intercept estimate and its significance
            synthesis$coefficients[grep(pattern = "Intercept", x = rownames(synthesis$coefficients), ignore.case = F, perl = F, value = F, fixed = F)] <- synthesis$coefficients[grep(pattern = "Intercept", x = rownames(synthesis$coefficients), ignore.case = F, perl = F, value = F, fixed = F)] + trans$ordinate
            synthesis$coefficients[,3] <- abs(synthesis$coefficients[,1]) / synthesis$coefficients[,2]
            synthesis$coefficients[,4] <- 2 * pt(abs(synthesis$coefficients[,3]), synthesis$df[1:2] , lower.tail = F)
            # compute the model series
            mod <- predict(fit)
            if (length(mod) == 1) {
              mod <- rep(mod, length(trans$x))
            }
            mod <- mod + trans$ordinate
            if (isTruthy(input$correct_waveform) && length(trans$pattern) > 0) {
              mod <- mod + trans$pattern
            }
            # compute the model residuals
            res <- residuals(fit)
            # transforming the sin/cos sinusoidal parameters into amp/phase
            if (any(grepl(pattern = "S", row.names(synthesis$coefficients)))) {
              ss <- 0
              info_out <- list()
              sinusoidal_code <- list()
              for (s in which(grepl(pattern = "S", row.names(synthesis$coefficients)))) {
                ss <- ss + 1
                sinusoidal_code <- c(sinusoidal_code, sub("S","",info$parameters[s]))
                sine <- synthesis$coefficients[s,1]
                cosine <- synthesis$coefficients[s + 1,1]
                sine_err <- synthesis$coefficients[s,2]
                cosine_err <- synthesis$coefficients[s + 1,2]
                sine_cosine_cov <- synthesis$sigma^2 * synthesis$cov.unscaled[s,s + 1]
                amp <- sqrt(sine^2 + cosine^2)
                phase <- atan2(cosine,sine)
                amp_err <- try(sqrt((sine^2*sine_err^2 + cosine^2*cosine_err^2 + 2*sine*cosine*sine_cosine_cov)/amp^2), silent = F)
                phase_err <- try(sqrt((sine^2*cosine_err^2 + cosine^2*sine_err^2 - 2*sine*cosine*sine_cosine_cov)/amp^4), silent = F)
                if (isTruthy(amp_err) && isTruthy(phase_err) && !inherits(amp_err,"try-error") && !inherits(phase_err,"try-error")) {
                  for (i in list(noquote(trans$periods[ss]), amp, amp_err, phase, phase_err)) {
                    info_out[[length(info_out) + 1]] <- i
                  }
                } else {
                  if (messages > 1) cat(file = stderr(), mySession, a, amp, phase, sine, sine_err, cosine, cosine_err, synthesis$cov.unscaled[s,s + 1], "\n")
                  showNotification(HTML(paste0("Unable to compute the amplitude and/or phase error from the errors of the sine and cosine coefficients of sinusoid ",ss,".<br><br>Please contact the author to repport this problem.")), action = NULL, duration = 10, closeButton = T, id = "bad_sinusoidal", type = "error", session = getDefaultReactiveDomain())
                  ss <- ss - 1
                }
              }
              if (isTruthy(info_out)) {
                synthesis$sinusoidales <- matrix(data = info_out, nrow = ss, ncol = 5, byrow = T)
                synthesis$sinusoidales[,c(2,3)] <- format(synthesis$sinusoidales[,c(2,3)], digits = 2, nsmall = 2, scientific = F, width = 5)
                synthesis$sinusoidales[,2] <- format(synthesis$sinusoidales[,2], digits = 2, nsmall = 2, scientific = F, width = max(nchar(synthesis$sinusoidales[,2])))
                synthesis$sinusoidales[,3] <- format(synthesis$sinusoidales[,3], digits = 2, nsmall = 2, scientific = F, width = max(nchar(synthesis$sinusoidales[,3])))
                synthesis$sinusoidales[,c(4,5)] <- format(synthesis$sinusoidales[,c(4,5)], digits = 3, nsmall = 3, scientific = F, width = 6)
                synthesis$sinusoidales[,4] <- format(synthesis$sinusoidales[,4], digits = 2, nsmall = 2, scientific = F, width = max(nchar(synthesis$sinusoidales[,4])))
                synthesis$sinusoidales[,5] <- format(synthesis$sinusoidales[,5], digits = 2, nsmall = 2, scientific = F, width = max(nchar(synthesis$sinusoidales[,5])))
                # dimnames(synthesis$sinusoidales) <- list(paste0("Sinusoidal ",1:ss), c("Period","Amplitude","Amp. Error","Phase (rad)","Ph. Error (rad)"))
                dimnames(synthesis$sinusoidales) <- list(paste0("Sinusoidal ",sinusoidal_code), c("Period","Amplitude","Amp. Error","Phase (rad)","Ph. Error (rad)"))
              }
            }
            # removing wavelet
            if (isTruthy(input$wavelet) && input$waveletType > 1) {
              updateRadioButtons(session, inputId = "waveletType", label = NULL, choices = list("None" = 0, "Original" = 1, "Model" = 2, "Model res." = 3, "Filter" = 4, "Filter res." = 5), selected = 0, inline = T, choiceNames = NULL,  choiceValues = NULL)
            }
            # updating waveform
            if (isTruthy(inputs$waveformPeriod)) {
              save_value <- inputs$waveformPeriod
              updateTextInput(session, "waveformPeriod", value = "")
              updateTextInput(session, "waveformPeriod", value = save_value)
            }
            # keeping estimated fit
            trans$names <- names(coef(fit))
            trans$unc <- unname(synthesis$coefficients[grepl("Rate",rownames(synthesis$coefficients)),2])
            trans$equation <- gsub("x", "Epoch", sub("y ~","Model =",m$model_nls))
            trans$results <- synthesis
            trans$LScoefs <- synthesis$coefficients
            trans$res <- res
            trans$mod <- mod
            trans$moderror <- sqrt( diag(jacobian %*% synthesis$cov.unscaled %*% t(jacobian)) )
            trans$reserror <- synthesis$sigma * trans$sy
            if (!any(is.na(trans$moderror))) {
              if (isTruthy(synthesis$sigma)) {
                if (!any(1/weights < trans$moderror^2)) {
                  trans$reserror <- sqrt( 1/weights - trans$moderror^2 ) * synthesis$sigma
                }
                trans$moderror <- trans$moderror * synthesis$sigma
              }
            } else {
              showNotification(HTML("Unable to assess the model variance.<br>The model may be overfitted.<br>Change the model components."), action = NULL, duration = 10, closeButton = T, id = "overfit", type = "warning", session = getDefaultReactiveDomain())
            }
            # keeping results for the overview plot
            if ("Linear" %in% input$model && input$trendType == 0) {
              trans[[paste0("plotInfo", input$tab)]][[info$db1]] <- c(trans$LScoefs[2,1], trans$LScoefs[2,2], sd(trans$res))
            } else {
              trans[[paste0("plotInfo", input$tab)]][[info$db1]] <- c(NA, NA, sd(trans$res))
            }
            # keeping results for the 3D plot
            if (input$format != 4) {
              isolate({
                if (all(is.na(db1[[info$db1]][[paste0("res", input$tab)]])) ||
                    length(trans$res) != length(db1[[info$db1]][[paste0("res", input$tab)]][!is.na(db1[[info$db1]][[paste0("res", input$tab)]])]) ||
                    any(trans$res - db1[[info$db1]][[paste0("res", input$tab)]][!is.na(db1[[info$db1]][[paste0("res", input$tab)]])] != 0) ||
                    any(trans$mod - db1[[info$db1]][[paste0("mod", input$tab)]][!is.na(db1[[info$db1]][[paste0("mod", input$tab)]])] != 0)) {
                  db1[[info$db1]][[paste0("res", input$tab)]] <- NA
                  db1[[info$db1]][[paste0("mod", input$tab)]] <- NA
                  db1[[info$db1]][[paste0("reserror", input$tab)]] <- NA
                  db1[[info$db1]][[paste0("res", input$tab)]][match(x, db1[[info$db1]][[paste0("x", input$tunits)]])] <- trans$res
                  db1[[info$db1]][[paste0("mod", input$tab)]][match(x, db1[[info$db1]][[paste0("x", input$tunits)]])] <- trans$mod
                  db1[[info$db1]][[paste0("reserror", input$tab)]][match(x, db1[[info$db1]][[paste0("x", input$tunits)]])] <- trans$reserror
                  trans[[paste0("offsetEpochs", input$tab)]] <- trans$offsetEpochs
                }
              })
            }
            info$run <- T
          } else {
            if ((grepl("L1",m$model_nls) || grepl("E1",trans$equation)) && grepl("minFactor", fit[1]) && info$LStol < 1e-2) {
              info$LStol <- info$LStol*10
              req(info$stop)
            } else {
              trans$results <- NULL
              trans$unc <- NULL
              trans$res <- NULL
              trans$mod <- NULL
              trans$LScoefs <- NULL
              trans$names <- NULL
              showNotification(HTML("Unable to fit the LS model.<br>Change the model components."), action = NULL, duration = 5, closeButton = T, id = "bad_LS", type = "error", session = getDefaultReactiveDomain())
            }
          }
        } else {
          trans$results <- NULL
          trans$res <- NULL
          trans$mod <- NULL
          trans$LScoefs <- NULL
          trans$names <- NULL
          trans$model_old <- NULL
          db1[[info$db1]][[paste0("res", input$tab)]] <- NA
          db1[[info$db1]][[paste0("mod", input$tab)]] <- NA
          db1[[info$db1]][[paste0("reserror", input$tab)]] <- NA
          trans[[paste0("offsetEpochs", input$tab)]] <- NA
        }
      }
    } else {
      trans$results <- NULL
      trans$res <- NULL
      trans$mod <- NULL
      trans$LScoefs <- NULL
      trans$names <- NULL
      trans$model_old <- NULL
      db1[[info$db1]][[paste0("res", input$tab)]] <- NA
      db1[[info$db1]][[paste0("mod", input$tab)]] <- NA
      db1[[info$db1]][[paste0("reserror", input$tab)]] <- NA
      trans[[paste0("offsetEpochs", input$tab)]] <- NA
    }
    #
    if (isTruthy(debug)) {
      debugMem()
    }
  }, priority = 2)

  # KF fit ####
  observeEvent(input$runKF, {
    req(input$model, trans$x, trans$y)
    removeNotification("no_weighting")
    removeNotification("bad_model")
    removeNotification("not_even")
    removeNotification("bad_measurement_error")
    removeNotification("bad_a_priori_state")
    removeNotification("bad_variance")
    removeNotification("bad_kf")
    removeNotification("kf_not_valid")
    removeNotification("bad_obserror")
    removeNotification("bad_sigmaPoints")
    updateButton(session, inputId = "runKF", label = " Run KF", icon = icon("filter", class = NULL, lib = "font-awesome"), style = "default")
    output$offsetFound <- renderUI({ NULL })
    output$est.white <- renderUI({ NULL })
    output$est.flicker <- renderUI({ NULL })
    output$est.randomw <- renderUI({ NULL })
    output$est.powerl <- renderUI({ NULL })
    output$est.index <- renderUI({ NULL })
    output$est.mle <- renderUI({ NULL })
    output$est.unc <- renderUI({ NULL })
    trans$noise <- NULL
    trans$mle <- F
    if (input$fitType == 2) {
      trans$verif <- NULL
      # run KF button click
      withBusyIndicatorServer("runKF", {
        withProgress(message = 'Running Kalman Filter.',
                     detail = 'This may take a while ...', value = 0, {
                       x <- trans$x
                       y <- trans$y
                       # removing the waveform before the fit
                       if (isTruthy(input$correct_waveform)) {
                         if (length(trans$pattern) > 0) {
                           y <- y - trans$pattern
                         }
                       }
                       # checking the series error bars
                       sy <- trans$sy
                       if (any(sy <= 0) || any(is.na(sy))) {
                         showNotification(HTML("Some errorbar values are not valid.<br>No weighting applied."), action = NULL, duration = 10, closeButton = T, id = "no_weighting", type = "error", session = getDefaultReactiveDomain())
                         sy <- rep(1, length(y))
                         updateCheckboxInput(session, inputId = "sigmas", label = NULL, value = F)
                       }
                       # reset the previous KF fit
                       trans$mod <- trans$mod0 <- NULL
                       trans$res <- trans$res0 <- NULL
                       trans$kalman <- trans$kalman0 <- NULL
                       trans$kalman_unc <- trans$kalman_unc0 <- NULL
                       trans$results <- NULL
                       # set the model equation and the a priori state values
                       m <- model(x,y)
                       req(m$model, m$apriori, m$nouns, m$processNoise, m$error)
                       trans$KFnames <- unlist(m$nouns)
                       if (!isTruthy(m) && length(m$apriori) < 2) {
                         showNotification(HTML("Not enough model components to run the KF.<br>Check the input values."), action = NULL, duration = 10, closeButton = T, id = "bad_model", type = "error", session = getDefaultReactiveDomain())
                         info$run <- F
                         req(info$stop)
                       }
                       if (messages > 1) cat(file = stderr(), mySession, m$model, "\n")
                       apriori <- as.numeric(m$apriori)
                       unc_ini <- as.numeric(m$error)^2
                       # Measurement function
                       FFfunction <- function(x,k) {
                         e <- matrix(0, nrow = k, ncol = length(x))
                         e[k,] <- x
                         x <- trans$x
                         if (k == 1) {
                           obs <- e[1,1]
                         } else {
                           obs <- eval(parse(text = model_kf))
                         }
                         c(obs)
                       }
                       # State transition
                       if ("Linear" %in% input$model && !is.na(as.numeric(input$TrendDev)) && as.numeric(input$TrendDev) > 0) {
                         model_kf <- m$model_kf_inst
                         GGfunction <- function(x, k) {
                           if (k != 1) {
                             x[1] <- x[1] + x[2] * (trans$x[k] - trans$x[k - 1])
                           }
                           c(x)
                         }
                       } else {
                         model_kf <- m$model_kf_mean
                         GGfunction <- function(x, k) {
                           c(x)
                         }
                       }
                       start.time <- Sys.time()
                       # likelihood optimization function
                       llikss <- function(x, data) {
                         if (messages > 2) cat(file = stderr(), mySession, "This iteration =", sqrt(exp(x[1])), "\n")
                         info$KFiter <- info$KFiter + 1
                         showNotification(paste0("Running KF iteration ", info$KFiter), action = NULL, duration = NULL, closeButton = T, id = "KF_iter", type = "warning", session = getDefaultReactiveDomain())
                         mod <- NULL
                         mod <- list(
                           m0 = apriori,
                           C0 = diag(unc_ini),
                           V = exp(x[1]),
                           W = diag(m$processNoise))
                         UKF(y = data, mod = mod, FFfunction = FFfunction, GGfunction = GGfunction, simplify = T, logLik = T)$logLik
                       }
                       # setting the measurement noise
                       sigmaR <- NULL
                       if (isTruthy(input$ObsError)) {
                         if (isTruthy(inputs$ObsError) && inputs$ObsError > 0) {
                           sigmaR <- inputs$ObsError
                         } else {
                           sigmaR <- info$noise/5
                           max_decimals <- signifdecimal(sigmaR, F) + 2
                           updateTextInput(session, "ObsError", value = sprintf("%.*f", max_decimals, sigmaR))
                           showNotification("The input measurement error is not valid.", action = NULL, duration = 10, closeButton = T, id = "bad_obserror", type = "error", session = getDefaultReactiveDomain())
                         }
                       } else {
                         sigmaR <- info$noise/5
                         max_decimals <- signifdecimal(sigmaR, F) + 2
                         updateTextInput(session, "ObsError", value = sprintf("%.*f", max_decimals, sigmaR))
                       }
                       # setting the range of the measurement noise optimization
                       if (isTruthy(input$errorm)) {
                         if (isTruthy(inputs$min_optirange)) {
                           min_optirange <- inputs$min_optirange
                         } else {
                           min_optirange <- info$noise/10
                           max_decimals <- signifdecimal(min_optirange, F) + 2
                           updateTextInput(session, "min_optirange", value = sprintf("%.*f", max_decimals, min_optirange))
                         }
                         if (isTruthy(inputs$max_optirange)) {
                           max_optirange <- inputs$max_optirange
                         } else {
                           max_optirange <- info$noise*10
                           max_decimals <- signifdecimal(max_optirange, F) + 2
                           updateTextInput(session, "max_optirange", value = sprintf("%.*f", max_decimals, max_optirange))
                         }
                         # run the measurement noise optimization
                         if (min_optirange > 0 && max_optirange > 0 && max_optirange > min_optirange) {
                           if (messages > 0) cat(file = stderr(), mySession, "Optimizing measurement noise", "\n")
                           info$KFiter <- 0
                           mod <- optim(log(sigmaR^2), llikss, lower = log(as.numeric(min_optirange)^2), upper = log(as.numeric(max_optirange)^2), method = "Brent", hessian = T, data = y, control = list(reltol = exp(as.numeric(min_optirange)/10)))
                           removeNotification("KF_iter")
                           if (mod$convergence == 0) {
                             sigmaR <- sqrt(exp(mod$par))
                             seParms <- sqrt(diag(solve(mod$hessian)))
                             max_decimals <- signifdecimal(sigmaR, F) + 2
                             updateTextInput(session, "ObsError", value = sprintf("%.*f", max_decimals, sigmaR))
                             if (isTruthy(seParms)) {
                               rangoR <- sqrt(exp(mod$par + qnorm(.05/2)*seParms %o% c(1,-1)))
                               max_decimals <- max(signifdecimal(rangoR, F)) + 2
                               updateTextInput(session, "min_optirange", value = sprintf("%.*f", max_decimals, rangoR[1]))
                               updateTextInput(session, "max_optirange", value = sprintf("%.*f", max_decimals, rangoR[2]))
                               updateCheckboxInput(inputId = "errorm", value = F)
                             }
                           }
                         } else {
                           showNotification(HTML("The input measurement error bounds are not valid.<br>Skipping optimization."), action = NULL, duration = 10, closeButton = T, id = "bad_measurement_error", type = "error", session = getDefaultReactiveDomain())
                         }
                       }
                       if (!isTruthy(sigmaR)) {
                         sigmaR <- info$noise/5
                         max_decimals <- signifdecimal(rangoR, F) + 2
                         updateTextInput(session, "ObsError", value = sprintf("%.*f", max_decimals, sigmaR))
                       }
                       # time-variable measurement noise values based on the series error bars
                       if (isTruthy(input$sigmas)) {
                         sigmaR <- sigmaR * sy / median(sy)
                       } else {
                         sigmaR <- rep(sigmaR, length(trans$y))
                       }
                       # setting the filter
                       ex1 <- list(m0 = apriori, C0 = diag(unc_ini), V = sigmaR^2, W = diag(m$processNoise))
                       kfs <- NULL
                       if (any(is.na(ex1$C0))) {
                         showNotification(HTML("Missing information required on the a priori state to run the Kalman filter.<br>Check the input values"), action = NULL, duration = 10, closeButton = T, id = "bad_a_priori_state", type = "error", session = getDefaultReactiveDomain())
                         info$run <- F
                         req(info$stop)
                       }
                       # EKF
                       if (input$kf == 1) {
                         if (messages > 0) cat(file = stderr(), mySession, "EKF fit", "\n")
                         kf <- NULL
                         # run forward EKF fit
                         kf <- try(dlmExtFilter(y = y, mod = ex1, GGfunction = GGfunction, FFfunction = FFfunction), silent = F)
                         if (!inherits(kf,"try-error") && !is.null(kf)) {
                           kfs <- NULL
                           # run backward EKF smoother
                           kfs <- try(dlmExtSmooth(kf), silent = F)
                           if (!inherits(kfs,"try-error") && !is.null(kfs)) {
                             # extract estimated state errors
                             varcov_kfs <- dlmSvd2var(kfs$U.S, kfs$D.S)
                             kfs_unc <- matrix(data = 0, nrow = nrow(kfs$s) - 1, ncol = ncol(kfs$s))
                             for (component in seq_len(ncol(kfs$s))) {
                               kfs_unc[,component] <- unlist(sapply(varcov_kfs[2:length(varcov_kfs)], function(x) diag(x)[component]))
                             }
                             if (any(kfs_unc < 0)) {
                               kfs_unc[kfs_unc < 0] <- NA
                               showNotification(HTML("Negative estimated state variances were found and changed to NA.<br>Something went wrong with the EKF fit."), action = NULL, duration = 15, closeButton = T, id = "bad_variance", type = "warning", session = getDefaultReactiveDomain())
                             }
                           } else {
                             trans$results <- NULL
                             trans$res <- NULL
                             trans$mod <- NULL
                             info$run <- F
                             showNotification(HTML("Unable to run the EKF smoother.<br>The error covariances of the initial state may be zero or too large"), action = NULL, duration = 10, closeButton = T, id = "bad_kf", type = "error", session = getDefaultReactiveDomain())
                           }
                         } else {
                           trans$results <- NULL
                           trans$res <- NULL
                           trans$mod <- NULL
                           info$run <- F
                           showNotification(HTML("Unable to fit the EKF.<br>Change the model parameters."), action = NULL, duration = 10, closeButton = T, id = "bad_kf", type = "error", session = getDefaultReactiveDomain())
                         }
                         # UKF
                       } else if (input$kf == 2) {
                         if (messages > 0) cat(file = stderr(), mySession, "UKF fit", "\n")
                         kf <- NULL
                         # run forward UKF fit
                         kf <- try(UKF(y = y, mod = ex1, sqrtMethod = "svd", GGfunction = GGfunction, FFfunction = FFfunction), silent = F)
                         if (!inherits(kf,"try-error") && !is.null(kf)) {
                           kfs <- NULL
                           # run backward UKF smoother
                           kfs <- try(UKFsmooth(kf, GGfunction = GGfunction), silent = F)
                           if (!inherits(kfs,"try-error") && !is.null(kfs)) {
                             # extract estimated state errors
                             kfs_unc <- matrix(data = 0, nrow = nrow(kfs$s) - 1, ncol = ncol(kfs$s))
                             for (component in seq_len(ncol(kfs$s))) {
                               kfs_unc[,component] <- unlist(sapply(kfs$S[2:length(kfs$S)], function(x) diag(x)[component]))
                             }
                             if (any(kfs_unc < 0)) {
                               kfs_unc[kfs_unc < 0] <- NA
                               showNotification(HTML("Negative estimated state variances were found and changed to NA.<br>Something went wrong with the UKF fit."), action = NULL, duration = 15, closeButton = T, id = "bad_variance", type = "warning", session = getDefaultReactiveDomain())
                             }
                           } else {
                             trans$results <- NULL
                             trans$res <- NULL
                             trans$mod <- NULL
                             info$run <- F
                             showNotification(HTML("Unable to run the UKF smoother.<br>The error covariances of the initial state may be zero or too large."), action = NULL, duration = 10, closeButton = T, id = "bad_kf", type = "error", session = getDefaultReactiveDomain())
                           }
                         } else {
                           trans$results <- NULL
                           trans$res <- NULL
                           trans$mod <- NULL
                           info$run <- F
                           showNotification(HTML("Unable to fit the UKF.<br>Change the model parameters."), action = NULL, duration = 10, closeButton = T, id = "bad_kf", type = "error", session = getDefaultReactiveDomain())
                         }
                       }
                       # Common EKF & UKF
                       if (isTruthy(kfs$s)) {
                         info$run <- T
                         e <- kfs$s[2:nrow(kfs$s),]
                         # save KF fit
                         if ("Linear" %in% input$model && !is.na(as.numeric(input$TrendDev)) && as.numeric(input$TrendDev) > 0) {
                           trans$mod <- sapply(1:length(x), function(k) if (k == 1) { e[1,1] } else { eval(parse(text = sub("+ e[k,2]*(x[k] - x[k-1])", "", model_kf, fixed = T))) })
                         } else {
                           trans$mod <- sapply(1:length(x), function(k) eval(parse(text = model_kf)) )
                         }
                         trans$mod0 <- db1[[info$db1]][[paste0("status",input$tab)]]
                         trans$mod0[which(trans$mod0)] <- trans$mod
                         trans$mod0[!db1[[info$db1]][[paste0("status",input$tab)]]] <- NA
                         trans$res <- y - trans$mod
                         trans$res0 <- db1[[info$db1]][[paste0("status",input$tab)]]
                         trans$res0[which(trans$res0)] <- trans$res
                         trans$mod0[!db1[[info$db1]][[paste0("status",input$tab)]]] <- NA
                         if (isTruthy(input$correct_waveform) && length(trans$pattern) > 0) {
                           trans$mod <- trans$mod0 <- trans$mod + trans$pattern
                         }
                         # Computing time-variable mean rate (deprecated)
                         # if ("Linear" %in% input$model && !is.na(as.numeric(input$TrendDev)) && as.numeric(input$TrendDev) > 0) {
                         #   mean_rate <- lapply(1:length(x), function(i) coefficients(summary(lm(e[1:i,2]~1,weights = 1/kfs_unc[1:i,1])))[1:2])
                         #   mean_rate[[1]][2] <- kfs_unc[1,2]
                         #   e <- cbind(e,sapply(mean_rate, "[", 1))
                         #   colnames(e) <- c(m$nouns, "MeanRate")
                         #   kfs_unc <- cbind(kfs_unc,sapply(mean_rate, "[", 2))
                         #   colnames(kfs_unc) <- c(m$nouns, "MeanRate")
                         # }
                         # saving KF results
                         colnames(e) <- m$nouns
                         colnames(kfs_unc) <- m$nouns
                         trans$kalman <- e
                         trans$kalman0 <- matrix(db1[[info$db1]][[paste0("status", input$tab)]], nrow = length(db1[[info$db1]][[paste0("status", input$tab)]]), ncol = ncol(trans$kalman))
                         trans$kalman0[which(trans$kalman0)] <- trans$kalman
                         trans$kalman0[!db1[[info$db1]][[paste0("status",input$tab)]]] <- NA
                         colnames(trans$kalman0) <- colnames(trans$kalman)
                         trans$kalman_unc <- sqrt(kfs_unc)
                         trans$kalman_unc0 <- matrix(db1[[info$db1]][[paste0("status", input$tab)]], nrow = length(db1[[info$db1]][[paste0("status", input$tab)]]), ncol = ncol(trans$kalman_unc))
                         trans$kalman_unc0[which(trans$kalman_unc0)] <- trans$kalman_unc
                         trans$kalman_unc0[!db1[[info$db1]][[paste0("status",input$tab)]]] <- NA
                         colnames(trans$kalman_unc0) <- colnames(trans$kalman_unc)
                         # trans$results <- formatting(psych::describe(trans$kalman, na.rm = F, interp = F, skew = F, ranges = T, trim = 0, type = 3, check = T, fast = F, quant = c(.05,.25,.75,.95), IQR = T), 1)
                         trans$results <- psych::describe(trans$kalman, na.rm = F, interp = F, skew = F, ranges = T, trim = 0, type = 3, check = T, fast = F, quant = c(.05,.25,.75,.95), IQR = T)
                         trans$kalman_info <- m
                         trans$equation <- sub("y ~","Model =",m$model)
                         end.time <- Sys.time()
                         time.taken <- end.time - start.time
                         if (messages > 2) cat(file = stderr(), mySession, "Total time =", time.taken, "\n")
                         db1[[info$db1]]$status.kf <- db1[[info$db1]][[paste0("status",input$tab)]]
                         if (isTruthy(inputs$waveformPeriod)) {
                           save_value <- inputs$waveformPeriod
                           updateTextInput(session, "waveformPeriod", value = "")
                           updateTextInput(session, "waveformPeriod", value = save_value)
                         }
                         # Plot instantaneous rate
                         output$rate1 <- output$rate2 <- output$rate3 <- renderPlot({
                           if ("Linear" %in% input$model && length(trans$kalman) > 0 && trans$kalman_info$processNoise[2] > 0) {
                             if (input$tunits == 1) {
                               period <- "day"
                             } else if (input$tunits == 2) {
                               period <- "week"
                             } else if (input$tunits == 3) {
                               period <- "year"
                             }
                             if (input$sunits == 1) {
                               units <- paste0("(m/",period,")")
                             } else if (input$sunits == 2) {
                               units <- paste0("(mm/",period,")")
                             } else {
                               units <- ""
                             }
                             title <- "Instantaneous linear rate"
                             plot_series(trans$x,trans$kalman[,2],trans$kalman_unc[,2],ranges$x2,ranges$y4,T,"",input$symbol,F,"")
                             title(ylab = units)
                             title(title, line = 3)
                           }
                         }, width = reactive(info$width))
                         trans$model_old <- input$model
                         # keeping results for the overview plot
                         if ("Linear" %in% input$model) {
                           trans[[paste0("plotInfo", input$tab)]][[info$db1]] <- c(mean(trans$kalman[,2]), mean(trans$kalman_unc[,2]), sd(trans$res))
                         } else {
                           trans[[paste0("plotInfo", input$tab)]][[info$db1]] <- c(0.0, 0.0, sd(trans$res))
                         }
                         # keeping results for the 3D plot
                         if (input$format != 4) {
                           isolate({
                             if (all(is.na(db1[[info$db1]][[paste0("res", input$tab)]])) ||
                                 length(trans$res) != length(db1[[info$db1]][[paste0("res", input$tab)]][!is.na(db1[[info$db1]][[paste0("res", input$tab)]])]) ||
                                 any(trans$res - db1[[info$db1]][[paste0("res", input$tab)]][!is.na(db1[[info$db1]][[paste0("res", input$tab)]])] != 0)) {
                               db1[[info$db1]][[paste0("res", input$tab)]] <- NA
                               db1[[info$db1]][[paste0("mod", input$tab)]] <- NA
                               db1[[info$db1]][[paste0("reserror", input$tab)]] <- NA
                               db1[[info$db1]][[paste0("res", input$tab)]][match(x, db1[[info$db1]][[paste0("x", input$tunits)]])] <- trans$res
                               db1[[info$db1]][[paste0("mod", input$tab)]][match(x, db1[[info$db1]][[paste0("x", input$tunits)]])] <- trans$mod
                               db1[[info$db1]][[paste0("reserror", input$tab)]][match(x, db1[[info$db1]][[paste0("x", input$tunits)]])] <- trans$sy
                               trans[[paste0("offsetEpochs", input$tab)]] <- trans$offsetEpochs
                             }
                           })
                         }
                         updateButton(session, inputId = "runKF", label = " Run KF", icon = icon("filter", class = NULL, lib = "font-awesome"), style = "default")
                       }
                     })
      })
    }
    #
    if (isTruthy(debug)) {
      debugMem()
    }
  })

  # Plot residuals ####
  ### 1D ####
  output$res1 <- output$res2 <- output$res3 <- renderPlot({
    req(trans$res, trans$x, trans$sy, info$run)
    if (messages > 0) cat(file = stderr(), mySession, "Plotting residual series", "\n")
    if (input$sunits == 1) {
      units <- "(m)"
    } else if (input$sunits == 2) {
      units <- "(mm)"
    } else {
      units <- ""
    }
    title <- "Model residuals"
    if (!is.null(trans$filter)) {
      title <- paste(title, "(black) & Filter-Model residuals (yellow)")
    }
    if (length(trans$reserror) > 0) {
      ey <- trans$reserror
    } else {
      ey <- trans$sy
    }
    sigmas <- F
    if (isTruthy(input$sigmas) && ((input$format == 4 && isTruthy(inputs$errorBar)) || input$format != 4)) {
      sigmas <- T
    }
    rangesx2 <- range(trans$x)
    if (isTruthy(ranges$x2)) {
      rangesx2 <- ranges$x2
    }
    plot_series(trans$x,trans$res,ey,rangesx2,ranges$y2,sigmas,"",input$symbol,T,"")
    title(title, line = 3)
    abline(h = 0, col = SARIcolors[2], lwd = 3)
    if (input$traceLog && length(info$log) > 0) {
      for (r in info$log[[2]]) {
        abline(v = r, col = SARIcolors[4], lty = 2)
      }
      for (a in info$log[[1]]) {
        abline(v = a, col = SARIcolors[4])
      }
    }
    if (input$traceSinfo && length(info$sinfo) > 0) {
      for (r in info$sinfo[[2]]) {
        abline(v = r, col = SARIcolors[6], lty = 2)
      }
      for (a in info$sinfo[[1]]) {
        abline(v = a, col = SARIcolors[6])
      }
    }
    if (input$traceSoln && length(info$soln) > 0) {
      for (r in info$soln[[2]]) {
        abline(v = r, col = SARIcolors[8], lty = 2)
      }
      for (a in info$soln[[1]]) {
        abline(v = a, col = SARIcolors[8])
      }
    }
    if (input$traceCustom && length(info$custom) > 0) {
      for (r in info$custom[[2]]) {
        abline(v = r, col = SARIcolors[5], lty = 2)
      }
      for (a in info$custom[[1]]) {
        abline(v = a, col = SARIcolors[5])
      }
    }
    if ("Offset" %in% isolate(input$model)) {
      for (p in trans$offsetEpochs) {
        abline(v = p, col = SARIcolors[2], lwd = 2)
      }
    }
    if (input$breaking && isTruthy(trans$breakEpochs) && (input$trendType > 0 || input$sinusoidType > 0 || input$polyType > 0)) {
      for (p in trans$breakEpochs) {
        abline(v = p, col = SARIcolors[3], lwd = 2, lty = 3)
      }
    }
    if (!is.null(trans$filter) && input$filter == T) {
      if (input$series2filter == 1) {
        lines(trans$x,trans$filter - trans$mod, col = SARIcolors[7], lwd = 3)
      } else if (input$series2filter == 2) {
        lines(trans$x,trans$filter, col = SARIcolors[7], lwd = 3)
      }
    }
  }, width = reactive(info$width))

  ### 3D ####
  output$plot51 <- renderPlot({
    plot3series(1)
  }, width = reactive(info$width))
  output$plot52 <- renderPlot({
    plot3series(2)
  }, width = reactive(info$width))
  output$plot53 <- renderPlot({
    plot3series(3)
  }, width = reactive(info$width))

  # Print clicks on the residuals tab
  output$plot5_info <- renderPrint({
    line1 <- line2 <- line3 <- NULL
    if (length(input$plot51_1click$x) > 0 && length(input$plot51_brush) == 0) {
      x <- input$plot51_1click$x
      y <- input$plot51_1click$y
      line1 <- paste("Plot 1 coordinates =", x, y, sep = "\t")
    }
    if (length(input$plot52_1click$x) > 0 && length(input$plot52_brush) == 0) {
      x <- input$plot52_1click$x
      y <- input$plot52_1click$y
      line2 <- paste("Plot 2 coordinates =", x, y, sep = "\t")
    }
    if (length(input$plot53_1click$x) > 0 && length(input$plot53_brush) == 0) {
      x <- input$plot53_1click$x
      y <- input$plot53_1click$y
      line3 <- paste("Plot 3 coordinates =", x, y, sep = "\t")
    }
    if (isTruthy(line1) || isTruthy(line2) || isTruthy(line3)) {
      cat('', line1, '\n', line2, '\n', line3, '\n')
    }
  })

  # Compute stats & histogram ####
  observeEvent(c(input$histogramType, trans$y, trans$res, trans$filter, ranges$x1, input$tab, inputs$epoch, inputs$variable, inputs$errorBar, input$sunits), {
    req(db1[[info$db1]], input$histogram)
    if (input$sunits == 1) {
      units <- "(m)"
    } else if (input$sunits == 2) {
      units <- "(mm)"
    } else {
      units <- ""
    }
    # set the type of series
    if (input$histogramType == 1) {
      values <- trans$y[trans$x >= ranges$x1[1] & trans$x <= ranges$x1[2]]
      label <- "original series"
    } else if (input$histogramType == 2 && length(trans$mod) > 0) {
      values <- trans$mod[trans$x >= ranges$x1[1] & trans$x <= ranges$x1[2]]
      label <- "model series"
    } else if (input$histogramType == 3 && length(trans$res) > 0) {
      values <- trans$res[trans$x >= ranges$x1[1] & trans$x <= ranges$x1[2]]
      label <- "model residual series"
    } else if (input$histogramType == 4 && length(trans$filter) > 0) {
      values <- trans$filter[trans$x >= ranges$x1[1] & trans$x <= ranges$x1[2]]
      label <- "filter series"
    } else if (input$histogramType == 5 && length(trans$filterRes) > 0) {
      values <- trans$filterRes[trans$x >= ranges$x1[1] & trans$x <= ranges$x1[2]]
      label <- "filter residual series"
    } else {
      updateRadioButtons(session, inputId = "histogramType", label = NULL, choices = list("None" = 0, "Original" = 1, "Model" = 2, "Model res." = 3, "Filter" = 4, "Filter res." = 5), selected = 0, inline = T, choiceNames = NULL,  choiceValues = NULL)
      req(info$stop)
    }
    removeNotification("no_histogram")
    if (isTruthy(values) && isTruthy(sd(values)) && length(values) > 1 && sd(values) > 0) {
      if (messages > 0) cat(file = stderr(), mySession, "Plotting histogram", "\n")
      output$hist1 <- output$hist2 <- output$hist3 <- renderPlot({
        title <- paste("Histogram of the", label, units)
        h <- hist(values, breaks = "FD", plot = F)
        h$density <- 100*h$density/sum(h$density) # changing the histogram units
        plot(h, col = SARIcolors[5], freq = F, xlab = paste("Values",units), ylab = "Frequency (%)", main = title)
        # estimate the normal distribution that fits the histogram
        xfit <- seq(min(values),max(values),length = 3*length(h$mids))
        yfit <- dnorm(xfit, mean = mean(values, na.rm = T), sd = sd(values, na.rm = T))
        lines(xfit, yfit*3*100/sum(yfit), col = SARIcolors[2], lwd = 3)
      }, width = reactive(info$width))
      # stationarity tests
      if (messages > 0) cat(file = stderr(), mySession, "Computing statistics", "\n")
      adf <- try(suppressWarnings(adf.test(values, alternative = "stationary")), silent = T)
      kpss <- suppressWarnings(kpss.test(values, null = "Level"))
      # getting the series statistics
      stats <- as.data.frame(psych::describe(matrix(values, ncol = 1, byrow = T), na.rm = T, interp = F, skew = T, ranges = T, trim = 0, type = 3, check = T, fast = F, quant = c(.05,.25,.75,.95), IQR = T))
      rownames(stats) <- NULL
      stats <- stats[, !names(stats) %in% "vars"]
      output$stats1 <- output$stats2 <- output$stats3 <- renderPrint({
        if (!inherits(adf,"try-error") && !is.null(adf) && isTruthy(adf$p.value) && isTruthy(kpss$p.value)) {
          cat(paste0("Statistics for the period from ", ranges$x1[1], " to ", ranges$x1[2]), "\n\n")
          if (kpss$p.value <= 0.01 && adf$p.value >= 0.01) {
            cat(paste0("WARNING: the ",label," are most certainly NOT stationary (probability > 99%)."), "\n\n")
          } else if (kpss$p.value < 0.05 && adf$p.value > 0.05) {
            cat(paste0("WARNING: the ",label," are likely NOT stationary (probability > 95%)."), "\n\n")
          } else if (kpss$p.value < 0.1 && adf$p.value > 0.1) {
            cat(paste0("WARNING: the ",label," could be NOT stationary (probability > 90%)."), "\n\n")
          } else {
            cat(paste0("The ",label," may be stationary (probability of non stationarity < 90%)."), "\n\n")
          }
        } else {
          showNotification(HTML("Unable to assess stationarity.<br>Check the input series."), action = NULL, duration = 10, closeButton = T, id = "no_stationarity", type = "error", session = getDefaultReactiveDomain())
        }
        if (input$sunits == 1) {
          cat("Series units: m", "\n\n")
        } else if (input$sunits == 2) {
          cat("Series units: mm", "\n\n")
        }
        print(stats, row.names = F)
      }, width = 280)
    } else {
      showNotification(HTML("Unable to compute the histogram.<br>Check the input series."), action = NULL, duration = 10, closeButton = T, id = "no_histogram", type = "error", session = getDefaultReactiveDomain())
      updateRadioButtons(session, inputId = "histogramType", label = NULL, choices = list("None" = 0, "Original" = 1, "Model" = 2, "Model res." = 3, "Filter" = 4, "Filter res." = 5), selected = 0, inline = T, choiceNames = NULL,  choiceValues = NULL)
    }
  })

  # Fit summary ####
  output$summary1 <- output$summary2 <- output$summary3 <- renderUI({
    req(db1[[info$db1]])
      listTag <- list()
      # compute correlation between primary and secondary series
      if (input$optionSecondary == 1 && isTruthy(trans$y2)) {
        serie1 <- data.frame(x = trans$x, y = trans$y)
        serie2 <- data.frame(x = trans$x2, y = trans$y2)
        common <- merge(serie1, serie2, by.x = "x", by.y = "x")
        if (length(common$x) > 30) {
          listTag <- list(span(paste("Pearson's correlation =", sprintf("%.3f",cor(common$y.x,common$y.y)), "from", length(common$x),"points at common epochs between the primary and secondary series.")))
        }
      }
      if (input$tunits == 1) {
        period <- "day"
      } else if (input$tunits == 2) {
        period <- "week"
      } else if (input$tunits == 3) {
        period <- "year"
      }
      if (input$sunits == 1) {
        unit <- "m"
        units <- paste0("m/",period)
      } else if (input$sunits == 2) {
        unit <- "mm"
        units <- paste0("mm/",period)
      } else {
        unit <- ""
        units <- ""
      }
      # recall the series units
      if (input$sunits > 0 && isTruthy(info$run) && length(isolate(trans$results)) > 0) {
        if (length(listTag) > 0) {
          listTag <- c(listTag, list(span("")))
        }
        listTag <- c(listTag, list(span(paste("Parameter units:", unit, "&", units))))
      }
      # show MIDAS estimate
      if (isTruthy(input$midas)) {
        if (length(listTag) > 0) {
          listTag <- c(listTag, list(span("")))
        }
        listTag <- c(listTag, list(span("MIDAS rate estimate")))
        formatted <- formatting(c(trans$midas_vel,trans$midas_sig),1)
        listTag <- c(listTag, list(span(paste(formatted[1], "+/-", formatted[2], units))))
        if (length(trans$offsetEpochs) > 0 && "Offset" %in% isolate(input$model)) {
          listTag <- c(listTag, list(span("")))
          listTag <- c(listTag, list(span("MIDAS rate estimate (discontinuities skipped)")))
          formatted <- formatting(c(trans$midas_vel2,trans$midas_sig2),1)
          listTag <- c(listTag, list(span(paste(formatted[1], "+/-", formatted[2], units))))
        }
      }
      # show entropy estimate
      if (isTruthy(input$entropy) && isTruthy(trans$entropy_vel) && isTruthy(trans$entropy_sig)) {
        if (length(listTag) > 0) {
          listTag <- c(listTag, list(span("")))
        }
        listTag <- c(listTag, list(span("Minimum entropy rate estimate")))
        formatted <- formatting(c(trans$entropy_vel,trans$entropy_sig),1)
        listTag <- c(listTag, list(span(paste(formatted[1], "+/-", formatted[2], units))))
      }
      # show fit estimate
      if (isTruthy(info$run) && length(isolate(trans$results)) > 0) {
        if (length(listTag) > 0) {
          listTag <- c(listTag, list(span("")))
        }
        if (input$fitType == 2) {
          listTag <- c(listTag, list(span("KF estimate")))
          listTag <- c(listTag, list(span(paste0(gsub(" > ", ">", gsub(" - ", "-", gsub(" \\* ", "\\*", gsub("))", ")", gsub("I\\(cos", "cos", gsub("I\\(sin", "sin", gsub("^ *|(?<= ) | *$", "", trans$equation, perl = T)))))))))))
          listTag <- c(listTag, list(span("")))
        } else if (input$fitType == 1) {
          listTag <- c(listTag, list(span("LS estimate")))
          isolate({
            trans$results$formula <- sub("y ~","Model =",trans$results$formula)
          })
        }
        options(max.print = 3000)
        listTag <- c(listTag, list(customPrint(isolate(trans$results))))
      }
      tagList(pre(listTag))
  })

  # Periodic waveform ####
  observeEvent(c(input$waveformPeriod, inputs$waveformPeriod, input$waveform, inputs$low, inputs$high, input$fitType), {
    req(trans$x)
    removeNotification("no_repeat")
    removeNotification("bad_waveform_period")
    if (isTruthy(input$correct_waveform)) {
      trans$pattern <- NULL
      trans$wave <- inputs$waveformPeriod
    } else {
      trans$wave <- NULL
      # removing the previous estimated waveform from the filter series
      if (isTruthy(trans$pattern) && length(trans$pattern) > 0 && length(trans$filterRes) > 0) {
        trans$filter <- trans$filter - trans$pattern
        trans$filterRes <- trans$filterRes + trans$pattern
      }
      if (length(trans$x) > 0 && (length(trans$res) > 0 || length(trans$filterRes) > 0) && isTruthy(input$waveform) && isTruthy(inputs$waveformPeriod)) {
        if (nchar(inputs$waveformPeriod) > 0 && !is.na(as.numeric(inputs$waveformPeriod)) && as.numeric(inputs$waveformPeriod) > 2*info$sampling  && as.numeric(inputs$waveformPeriod) < abs(info$rangex)/2) {
          withProgress(message = 'Computing the periodic waveform.',
                       detail = 'This may take a while ...', value = 0.1, {
                         x <- trans$x %% as.numeric(inputs$waveformPeriod)
                         if (length(trans$res) > 0) {
                           serie <- data.frame(x0 = trans$x, x = x, y = trans$res, sy = trans$sy)[order(x),]
                         } else if (length(trans$filterRes) > 0) {
                           serie <- data.frame(x0 = trans$x, x = x, y = trans$filterRes, sy = trans$sy)[order(x),]
                         }
                         serie$z <- floor(serie$x/info$sampling)
                         table <- as.data.table(serie, keep.rownames = T)
                         setProgress(0.2)
                         uniques <- sum(setDT(table)[, .N, z]$N ==  1)
                         average <- as.data.frame.matrix(table[,list(avg = weightedMedian(y,1/sy^2), std = sd(y)), by = z])
                         result <- merge(serie,average, by = "z")
                         if (uniques > 0) {
                           result$std[is.na(result$std)] <- result$sy[is.na(result$std)]
                           showNotification(HTML(paste0(uniques," data epochs are not repeated in the series.<br>The waveform may be wrong at these epochs.")), action = NULL, duration = 10, closeButton = T, id = "no_repeat", type = "warning", session = getDefaultReactiveDomain())
                         }
                         result <- result[order(result$x0),]
                         trans$pattern <- result$avg
                         if (messages > 0) cat(file = stderr(), mySession, "Computing periodic waveform", "\n")
                         if (length(trans$res) > 0) {
                           trans$mod <- trans$mod + trans$pattern
                           trans$res <- trans$res - trans$pattern
                         } else if (length(trans$filterRes) > 0) {
                           trans$filter <- trans$filter + trans$pattern
                           trans$filterRes <- trans$filterRes - trans$pattern
                         }
                         toplot <- !duplicated(result[,"z"])
                         output$waveform1 <- output$waveform2 <- output$waveform3 <- renderPlot({
                           if (length(trans$res) > 0 || length(trans$filterRes) > 0) {
                             if (length(trans$res) > 0) {
                               title <- "Periodic waveform from model residuals"
                             } else if (length(trans$filterRes) > 0) {
                               title <- "Periodic waveform from filter residuals"
                             }
                             if (input$symbol == 0) {
                               symbol <- 'p'
                             } else if (input$symbol == 1) {
                               symbol <- 'l'
                             } else if (input$symbol == 2) {
                               symbol <- 'o'
                             }
                             waveform <- data.frame(x = result[toplot,]$x, y = result[toplot,]$avg, sy = result[toplot,]$std)
                             waveform <- waveform[order(waveform$x),]
                             plot(waveform$x,waveform$y, type = symbol, pch = 20, xlab = "Epoch of period", ylab = "Average value", main = title)
                             ba <- waveform$y + waveform$sy
                             bb <- waveform$y - waveform$sy
                             polygon(c(waveform$x, rev(waveform$x)), c(ba, rev(bb)), col = rgb(0,0,0,0.2), border = NA)
                           }
                         }, width = reactive(info$width))
                         setProgress(0.7) # just for progress bar lovers
                         Sys.sleep(1)
                         setProgress(1)
                         Sys.sleep(1)
                       })
        } else {
          showNotification(HTML("The period of the waveform is not valid.<br>Check the input value."), action = NULL, duration = 10, closeButton = T, id = "bad_waveform_period", type = "error", session = getDefaultReactiveDomain())
          if (length(trans$pattern) > 0) {
            if (length(trans$res) > 0) {
              trans$mod <- trans$mod - trans$pattern
              trans$res <- trans$res + trans$pattern
            }
            trans$pattern <- NULL
          }
        }
      } else {
        if (length(trans$pattern) > 0) {
          if (length(trans$res) > 0) {
            trans$mod <- trans$mod - trans$pattern
            trans$res <- trans$res + trans$pattern
          }
          trans$pattern <- NULL
        }
      }
    }
    #
    if (isTruthy(debug)) {
      debugMem()
    }
  })

  # Computing spectrum ####
  observeEvent(c(input$spectrum, inputs$short_period, inputs$long_period, inputs$ofac, inputs$step), {
    req(db1[[info$db1]], input$spectrum)
    removeNotification("bad_periods")
    info$clickX <- info$clickY <- info$closestX <- info$closestY <- NULL
    if (is.na(inputs$long_period) && input$long_period != "") {
      showNotification(HTML("The longest period is not a numeric value.<br>Check the input value."), action = NULL, duration = 10, closeButton = T, id = "bad_long", type = "error", session = getDefaultReactiveDomain())
      req(info$stop)
    }
    if (is.na(inputs$short_period) && input$short_period != "") {
      showNotification(HTML("The shortest period is not a numeric value.<br>Check the input value."), action = NULL, duration = 10, closeButton = T, id = "bad_short", type = "error", session = getDefaultReactiveDomain())
      req(info$stop)
    }
    if (is.na(inputs$ofac) && input$ofac != "") {
      showNotification(HTML("The oversampling value is not numeric.<br>Check the input value."), action = NULL, duration = 10, closeButton = T, id = "bad_oversampling", type = "error", session = getDefaultReactiveDomain())
      req(info$stop)
    }
    if (messages > 0) cat(file = stderr(), mySession, "Setting periodogram limits", "\n")
    trans$fs <- NULL
    trans$title <- c("Lomb-Scargle periodogram: ")
    # max_period <- as.numeric(sprintf("%.*f", info$decimalsx, info$rangex)) # full range
    max_period <- trunc(info$rangex * 10^info$decimalsx) / 10^info$decimalsx # truncated range
    intervals <- as.data.frame(table(diff(trans$x)), stringsAsFactors = F)
    # min_period <- 2*gcd(trans$x[-1]*10^info$decimalsx-trans$x[1]*10^info$decimalsx)/10^info$decimalsx #following Eyer and Bartholdi 1999
    min_period <- 2*as.numeric(sort(intervals$Var1[intervals$Freq/(length(trans$x) - 1) >= 0.5], decreasing = T)[1]) #approximate the shortest period by twice the shortest interval repeating itself at least 50% of the time
    if (isTruthy(min_period)) {
      min_period <- as.numeric(sprintf("%.*f", info$decimalsx, min_period))
    } else {
      min_period <- as.numeric(sprintf("%.*f", info$decimalsx, 2*info$sampling_regular))
    }
    # Setting longest period
    if (isTruthy(inputs$long_period)) {
      if (inputs$long_period > max_period) {
        showNotification(HTML("The input longest period is out of bounds.<br>Using the longest valid value instead."), action = NULL, duration = 10, closeButton = T, id = "bad_long", type = "warning", session = getDefaultReactiveDomain())
        long_period <- max_period
        inputs$long_period <- long_period
        updateTextInput(session, "long_period", value = sprintf("%.*f", info$decimalsx, long_period))
        trans$fs <- NULL
        req(info$stop)
      } else {
        long_period <- inputs$long_period
      }
    } else {
      long_period <- max_period
      short_period <- min_period
      inputs$long_period <- long_period
      inputs$short_period <- short_period
      updateTextInput(session, "short_period", value = sprintf("%.*f", info$decimalsx, short_period))
      updateTextInput(session, "long_period", value = sprintf("%.*f", info$decimalsx, long_period))
      ranges$x3 <- NULL
      trans$fs <- NULL
      req(info$stop)
    }
    # Setting shortest period
    if (isTruthy(inputs$short_period)) {
      if (inputs$short_period < min_period) {
        showNotification(HTML("The input shortest period is smaller than the propossed value.<br>The periodogram may be aliased into the Nyquist period range."), action = NULL, duration = 10, closeButton = T, id = "bad_short", type = "warning", session = getDefaultReactiveDomain())
      }
      short_period <- inputs$short_period
    } else {
      long_period <- max_period
      short_period <- min_period
      inputs$long_period <- long_period
      inputs$short_period <- short_period
      updateTextInput(session, "short_period", value = sprintf("%.*f", info$decimalsx, short_period))
      updateTextInput(session, "long_period", value = sprintf("%.*f", info$decimalsx, long_period))
      ranges$x3 <- NULL
      trans$fs <- NULL
      req(info$stop)
    }
    # Setting oversampling
    if (isTruthy(inputs$ofac)) {
      if (inputs$ofac < 0.01 || inputs$ofac > 100) {
        showNotification(HTML("The input oversampling value is out of bounds [0.01 - 100].<br>Using 1 instead."), action = NULL, duration = 10, closeButton = T, id = "bad_oversampling", type = "error", session = getDefaultReactiveDomain())
        trans$fs <- NULL
        updateTextInput(session, "ofac", value = 1)
        req(info$stop)
      } else {
        ofac <- inputs$ofac
        if (isTruthy(ranges$x3) && (ranges$x3[1] != short_period || ranges$x3[2] != long_period)) {
          short_period <- ranges$x3[1]
          long_period <- ranges$x3[2]
          inputs$long_period <- long_period
          inputs$short_period <- short_period
          ranges$x3 <- NULL
          ranges$y3 <- NULL
          trans$fs <- NULL
          updateTextInput(session, "long_period", value = long_period)
          updateTextInput(session, "short_period", value = short_period)
          req(info$stop)
        }
      }
    } else {
      trans$fs <- NULL
      ofac <- 1
      inputs$ofac <- ofac
      updateTextInput(session, "ofac", value = ofac)
      req(info$stop)
    }
    # Computing periodogram if all necessary values are good
    if (input$spectrum && short_period > 0 && long_period > 0 && 1/short_period > 1/long_period + 1/(max_period*ofac)) {
      if ((input$tab == 1) || (input$format == 4)) {
        shinyjs::show(id = "res1_espectral", anim = T, animType = "fade", time = 0.5, selector = NULL)
      } else if (input$tab == 2) {
        shinyjs::show(id = "res2_espectral", anim = T, animType = "fade", time = 0.5, selector = NULL)
      } else if (input$tab == 3) {
        shinyjs::show(id = "res3_espectral", anim = T, animType = "fade", time = 0.5, selector = NULL)
      }
      f <- seq(1/long_period,1/short_period,1/(max_period*ofac)) # cycles per time unit
      if (short_period == min_period) {
        f <- f[1:length(f) - 1] # drop the shortest period just in case the series are not evenly sampled
      }
      trans$fs <- f
      trans$amp <- matrix(NA, nrow = length(f), ncol = 5)
      trans$psd <- matrix(NA, nrow = length(f), ncol = 5)
      trans$col <- c(1,2,3,4,5)
      if (any(c(input$spectrumOriginal, input$spectrumModel, input$spectrumResiduals, input$spectrumFilter, input$spectrumFilterRes))) {
        periodogram("all")
      }
    } else {
      showNotification(HTML("Negative, null or invalid period bounds for the periodogram.<br>Check the input values."), action = NULL, duration = 10, closeButton = T, id = "bad_periods", type = "error", session = getDefaultReactiveDomain())
      trans$fs <- NULL
      if ((input$tab == 1) || (input$format == 4)) {
        shinyjs::hide(id = "res1_espectral", anim = T, animType = "fade", time = 0.5, selector = NULL)
      } else if (input$tab == 2) {
        shinyjs::hide(id = "res2_espectral", anim = T, animType = "fade", time = 0.5, selector = NULL)
      } else if (input$tab == 3) {
        shinyjs::hide(id = "res3_espectral", anim = T, animType = "fade", time = 0.5, selector = NULL)
      }
    }
  })
  observeEvent(c(input$spectrumOriginal), {
    req(db1[[info$db1]])
    info$clickX <- info$clickY <- info$closestX <- info$closestY <- NULL
    if (isTruthy(trans$spectra_old[1])) {
      trans$psd[,1] <- NA
      trans$amp[,1] <- NA
      trans$spectra_old[1] <- F
      trans$title[2] <- NA
    } else {
      req(input$spectrum, input$spectrumOriginal)
      periodogram("original")
      if (input$tab == 1 || input$format == 4) {
        runjs("window.scrollTo(0,document.getElementById('lomb1').offsetTop);")
      } else if (input$tab == 2) {
        runjs("window.scrollTo(0,document.getElementById('lomb2').offsetTop);")
      } else if (input$tab == 3) {
        runjs("window.scrollTo(0,document.getElementById('lomb3').offsetTop);")
      }
    }
  })
  observeEvent(c(input$spectrumModel), {
    req(db1[[info$db1]])
    info$clickX <- info$clickY <- info$closestX <- info$closestY <- NULL
    if (isTruthy(trans$spectra_old[2])) {
      trans$psd[,2] <- NA
      trans$amp[,2] <- NA
      trans$spectra_old[2] <- F
      trans$title[3] <- NA
    } else {
      req(input$spectrum, input$spectrumModel)
      periodogram("model")
      if (input$tab == 1 || input$format == 4) {
        runjs("window.scrollTo(0,document.getElementById('lomb1').offsetTop);")
      } else if (input$tab == 2) {
        runjs("window.scrollTo(0,document.getElementById('lomb2').offsetTop);")
      } else if (input$tab == 3) {
        runjs("window.scrollTo(0,document.getElementById('lomb3').offsetTop);")
      }
    }
  })
  observeEvent(c(input$spectrumResiduals), {
    req(db1[[info$db1]])
    info$clickX <- info$clickY <- info$closestX <- info$closestY <- NULL
    if (isTruthy(trans$spectra_old[3])) {
      trans$psd[,3] <- NA
      trans$amp[,3] <- NA
      trans$spectra_old[3] <- F
      trans$title[4] <- NA
    } else {
      req(input$spectrum, input$spectrumResiduals)
      periodogram("residuals")
      if (input$tab == 1 || input$format == 4) {
        runjs("window.scrollTo(0,document.getElementById('lomb1').offsetTop);")
      } else if (input$tab == 2) {
        runjs("window.scrollTo(0,document.getElementById('lomb2').offsetTop);")
      } else if (input$tab == 3) {
        runjs("window.scrollTo(0,document.getElementById('lomb3').offsetTop);")
      }
    }
  })
  observeEvent(c(input$spectrumFilter), {
    req(db1[[info$db1]])
    info$clickX <- info$clickY <- info$closestX <- info$closestY <- NULL
    if (isTruthy(trans$spectra_old[4])) {
      trans$psd[,4] <- NA
      trans$amp[,4] <- NA
      trans$spectra_old[4] <- F
      trans$title[5] <- NA
    } else {
      req(input$spectrum, input$spectrumFilter)
      periodogram("filter")
      if (input$tab == 1 || input$format == 4) {
        runjs("window.scrollTo(0,document.getElementById('lomb1').offsetTop);")
      } else if (input$tab == 2) {
        runjs("window.scrollTo(0,document.getElementById('lomb2').offsetTop);")
      } else if (input$tab == 3) {
        runjs("window.scrollTo(0,document.getElementById('lomb3').offsetTop);")
      }
    }
  })
  observeEvent(c(input$spectrumFilterRes), {
    req(db1[[info$db1]])
    info$clickX <- info$clickY <- info$closestX <- info$closestY <- NULL
    if (isTruthy(trans$spectra_old[5])) {
      trans$psd[,5] <- NA
      trans$amp[,5] <- NA
      trans$spectra_old[5] <- F
      trans$title[6] <- NA
    } else {
      req(input$spectrum, input$spectrumFilterRes)
      periodogram("filterRes")
      if (input$tab == 1 || input$format == 4) {
        runjs("window.scrollTo(0,document.getElementById('lomb1').offsetTop);")
      } else if (input$tab == 2) {
        runjs("window.scrollTo(0,document.getElementById('lomb2').offsetTop);")
      } else if (input$tab == 3) {
        runjs("window.scrollTo(0,document.getElementById('lomb3').offsetTop);")
      }
    }
  })
  observeEvent(c(trans$y, trans$sy), {
    req(db1[[info$db1]], input$spectrum)
    info$clickX <- info$clickY <- info$closestX <- info$closestY <- NULL
    if (input$spectrumOriginal) {
      periodogram("original")
    }
  })
  observeEvent(c(trans$res, trans$model), {
    req(db1[[info$db1]], input$spectrum)
    info$clickX <- info$clickY <- info$closestX <- info$closestY <- NULL
    if (input$spectrumModel || input$spectrumResiduals) {
      periodogram(c("model","residuals"))
    }
  })
  observeEvent(c(trans$filter, trans$filterRes), {
    req(db1[[info$db1]], input$spectrum)
    info$clickX <- info$clickY <- info$closestX <- info$closestY <- NULL
    if (input$spectrumFilter || input$spectrumFilterRes) {
      periodogram(c("filter","filterRes"))
    }
  })

  # Plot spectrum ####
  output$res1_espectral <- output$res2_espectral <- output$res3_espectral <- renderPlot({
    trans$slope <- NULL
    req(db1[[info$db1]], input$spectrum, trans$fs, trans$psd)
    removeNotification("no_noise_psd")
    if (length(trans$fs) > 0) {
      if (messages > 0) cat(file = stderr(), mySession, "Plotting periodogram", "\n")
      marks <- c(1 %o% 10^(-20:20))
      if (input$tunits == 1) {
        period <- "days"
      } else if (input$tunits == 2) {
        period <- "weeks"
      } else if (input$tunits == 3) {
        period <- "years"
      }
      if (input$sunits == 1) {
        units <- "(m)"
      } else if (input$sunits == 2) {
        units <- "(mm)"
      } else {
        units <- ""
      }
      if (input$spectrumType == 0) {
        spectrum_y <- trans$amp
        trans$spectra <- cbind(1/trans$fs, trans$amp[,!is.na(colSums(trans$amp))])
        ylab <- paste("Amplitude", units)
      } else if (input$spectrumType == 1) {
        spectrum_y <- trans$psd
        trans$spectra <- cbind(1/trans$fs, trans$psd[,!is.na(colSums(trans$psd))])
        ylab <- "Power"
      }
      title <- substring(paste(trans$title[!is.na(trans$title)],collapse = ""), 1, nchar(paste(trans$title[!is.na(trans$title)],collapse = "")) - 2)
      par(mar = c(5.1,4.1,6.1,2.1))
      if (is.null(ranges$x3)) {
        matplot(x = 1/trans$fs, y = spectrum_y, type = "l", lty = 1, lwd = 2, log = "xy", col = SARIcolors[trans$col], xlab = paste0("Period (",period,")"), ylab = ylab, yaxt = 'n', xlim = rev(range(1/trans$fs)), ylim = ranges$y3)
      } else {
        matplot(x = 1/trans$fs, y = spectrum_y, type = "l", lty = 1, lwd = 2, log = "xy", col = SARIcolors[trans$col], xlab = paste0("Period (",period,")"), ylab = ylab, yaxt = 'n', xlim = rev(ranges$x3), ylim = ranges$y3)
      }
      title(title, line = 5)
      axis(2, at = marks, labels = marks)
      if (input$tunits == 1) {
        newPeriods <- sprintf('%.*f', 3, axTicks(1)/daysInYear)
        lab = "Period (years)"
      } else if (input$tunits == 2) {
        newPeriods <- sprintf('%.*f', 1, axTicks(1)*7)
        lab = "Period (days)"
      } else if (input$tunits == 3) {
        newPeriods <- sprintf('%.*f', 1, axTicks(1)*daysInYear)
        lab = "Period (days)"
      }
      axis(3, at = axTicks(1), labels = newPeriods)
      mtext(lab, side = 3, line = 3)
      c <- max(which(trans$spectra_old))
      if (input$spectrumType == 1) {
        if (input$mle && length(trans$noise) > 0 && isTruthy(trans$noise) && (isTruthy(input$spectrumResiduals) || isTruthy(input$spectrumFilterRes))) {
          if (input$tunits == 1) { #days
            f_scale <- 24*60*60
          } else if (input$tunits == 2) { #weeks
            f_scale <- 7*24*60*60
          } else if (input$tunits == 3) { #years
            f_scale <- daysInYear*24*60*60
          }
          f_hz <- trans$fs/f_scale
          if (isTruthy(info$white)) {
            wn <- noise_var(trans$noise[1],0)
          } else {
            wn <- 0
          }
          pwn <- wn * f_hz^0
          psd <- pwn
          crossover <- NULL
          type_crossover <- NULL
          if (isTruthy(info$flicker) && isTruthy(trans$noise[3])) {
            fl <- noise_var(trans$noise[3],-1)
            pfl <- fl * f_hz^-1
            psd <- psd + pfl
            if (wn > 0) {
              crossover <- suppressWarnings(min(1/trans$fs[pfl > pwn]))
              type_crossover <- "Flicker / White"
            }
            if (isTruthy(info$randomw) && isTruthy(trans$noise[5])) {
              rw <- noise_var(trans$noise[5],-2)
              prw <- rw * f_hz^-2
              psd <- psd + prw
              crossover <- c(crossover, suppressWarnings(min(1/trans$fs[prw > pfl])))
              type_crossover <- c(type_crossover, "Random walk / Flicker")
            }
          } else if (isTruthy(info$randomw) && isTruthy(trans$noise[5])) {
            rw <- noise_var(trans$noise[5],-2)
            prw <- rw * f_hz^-2
            psd <- psd + prw
            if (wn > 0) {
              crossover <- suppressWarnings(min(1/trans$fs[prw > pwn]))
              type_crossover <- "Random walk / White"
            }
          } else if (isTruthy(info$powerl) && isTruthy(trans$noise[7])) {
            pl <- noise_var(trans$noise[7],trans$noise[9])
            ppl <- pl * f_hz^trans$noise[9]
            psd <- psd + ppl
            if (wn > 0) {
              crossover <- suppressWarnings(min(1/trans$fs[ppl > pwn]))
              type_crossover <- "Power-law / White"
            }
          }
          var <- NULL
          if (isTruthy(input$spectrumResiduals) && isTruthy(trans$res)) {
            var <- var(trans$res)
          } else if (isTruthy(input$spectrumFilterRes) && isTruthy(trans$filterRes)) {
            var <- var(trans$filterRes)
          }
          psd <- psd*var/sum(psd)
          lines(1/trans$fs,psd, col = SARIcolors[6], lty = 2, lwd = 3)
          output$crossover <- renderUI({
            if (!is.null(trans$noise) && length(crossover) > 0 && var > 0) {
              line <- sprintf("<br/>Crossover period %s = %.2f %s\n", type_crossover, crossover, period)
              HTML(line)
            } else {
              NULL
            }
          })
        } else {
          p <- trans$psd[,c]
          slope <- try(lm(log10(p) ~ log10(1/trans$fs)), silent = T)
          if (isTruthy(slope) && !inherits(slope,"try-error")) {
            slope$coef[2] <- -1*slope$coef[2]
            trans$slope <- slope$coef[2]
            regression <- 10^(predict(slope, newdata = list(x = 1/trans$fs)))
            lines(1/trans$fs, regression, col = SARIcolors[c], lwd = 3)
            text(inputs$long_period/2,min(p),paste0("Slope = ",sprintf("%4.2f",slope$coef[2])," +- ",sprintf("%3.2f",summary(slope)$coefficients[2,2])), col = SARIcolors[c])
          }
          lombx <- c(inputs$long_period,inputs$short_period)
          longest <- ifelse(length(p) > 200, as.integer(length(p)/100), 10)
          start <- median(head(p, n = longest))
          lomby_flicker <- c(start,start/(inputs$long_period/inputs$short_period))
          lines(lombx,lomby_flicker, col = SARIcolors[6], lty = 2, lwd = 3)
          text(inputs$long_period/10,min(p),"Slope = -1",col = SARIcolors[6])
        }
      }
      grid(nx = NULL, ny = NULL, col = SARIcolors[8], lty = "dashed", lwd = 1, equilogs = T)
      if (isTruthy(info$closestY)) {
        points(info$closestX, info$closestY, type = "p", col = SARIcolors[c], bg = "white", pch = 21, lwd = 3)
      }
      #
      if (isTruthy(debug)) {
        debugMem()
      }
    }
  }, width = reactive(info$width))
  output$lomb1_info <- output$lomb2_info <- output$lomb3_info <- renderText({
    values <- NULL
    if (isTruthy(info$clickY)) {
      values <- c(info$clickX, info$clickY)
      if (inputs$ofac == 1) {
        if (input$spectrumType == 0) {
          amp <- as.matrix(trans$amp[,colSums(is.na(trans$amp)) < nrow(trans$amp)])[,ncol(as.matrix(trans$amp[,colSums(is.na(trans$amp)) < nrow(trans$amp)]))]
          values <- c(values, sqrt(0.5*sum(amp[trans$fs > 1/info$clickX]^2)))
        } else if (input$spectrumType == 1) {
          psd <- as.matrix(trans$psd[,colSums(is.na(trans$psd)) < nrow(trans$psd)])[,ncol(as.matrix(trans$psd[,colSums(is.na(trans$psd)) < nrow(trans$psd)]))]
          values <- c(values, sqrt(sum(psd[trans$fs > 1/info$clickX])))
        }
      }
      if (isTruthy(info$closestY)) {
        values <- c(values, info$closestX, info$closestY)
        if (isTruthy(values)) {
          strings <- format(c("Clicked periodogram coordinates = ","Closest periodogram point = "), trim = T)
          values <- format(values, trim = T, digits = 2, nsmall = 2, scientific = F)
          if (length(values) > 4) {
            if (input$sunits == 1) {
              units <- "m"
            } else if (input$sunits == 2) {
              units <- "mm"
            } else {
              units <- ""
            }
            paste0(paste(strings[1],values[1],values[2],"          Series scatter including shorter periods = ",values[3],units),"\n",paste(strings[2],values[4],values[5]))
          } else {
            paste0(paste(strings[1],values[1],values[2]),"\n",paste(strings[2],values[3],values[4]))
          }
        }
      }
    }
  })

  # Plot wavelet ####
  output$wavelet1 <- output$wavelet2 <- output$wavelet3 <- renderPlot({
    trans$wavelet <- NULL
    req(db1[[info$db1]], input$wavelet, input$waveletType)
    removeNotification("no_wavelet")
    if (isTruthy(isolate(info$run_wavelet))) {
      if (input$tunits == 1) {
        period <- "days"
        t <- 1/365.25
      } else if (input$tunits == 2) {
        period <- "weeks"
        t <- 7/365.25
      } else if (input$tunits == 3) {
        period <- "years"
        t <- 1
      }
      if (input$sunits == 1) {
        units <- "(m)"
      } else if (input$sunits == 2) {
        units <- "(mm)"
      } else {
        units <- ""
      }
      if (nchar(inputs$min_wavelet) > 0 && !is.na(inputs$min_wavelet) && nchar(inputs$max_wavelet) > 0 && !is.na(inputs$max_wavelet) && nchar(inputs$res_wavelet) > 0 && !is.na(as.numeric(inputs$res_wavelet)) && nchar(inputs$loc_wavelet) > 0 && !is.na(as.numeric(inputs$loc_wavelet)) && as.numeric(inputs$loc_wavelet) > 0 && as.numeric(inputs$loc_wavelet) <= info$rangex/2 && inputs$max_wavelet > inputs$min_wavelet) {
        min_scale <- inputs$min_wavelet*t
        max_scale <- inputs$max_wavelet*t
        num_scale <- as.integer((max_scale - min_scale)/(as.numeric(inputs$res_wavelet)*t))
        locs <- info$rangex/as.numeric(inputs$loc_wavelet)
      } else {
        min_scale <- get.min.scale(trans$x)
        max_scale <- get.max.scale(trans$x)
        num_scale <- as.integer(get.nscales(trans$x))
        res <- (max_scale - min_scale)/num_scale
        if (info$points < 500) {
          num_epochs <- info$points
        } else {
          num_epochs <- 500
        }
        loc <- info$rangex/num_epochs
        if (loc < info$sampling) {
          loc <- info$sampling
        }
        updateTextInput(session, "min_wavelet", value = sprintf("%.*f", info$decimalsx, min_scale))
        updateTextInput(session, "max_wavelet", value = sprintf("%.*f", info$decimalsx, max_scale))
        updateTextInput(session, "res_wavelet", value = res)
        updateTextInput(session, "loc_wavelet", value = sprintf("%.*f", info$decimalsx, loc))
        req(info$stop)
      }
      title <- "Wavelet transform:"
      if (input$waveletType == 1) {
        title <- paste0(title," original")
        y <- isolate(trans$y - mean(trans$y))
      } else if (input$waveletType == 2 && length(isolate(trans$mod)) > 0 && length(isolate(trans$mod)) > 0) {
        title <- paste0(title," model")
        req(trans$mod)
        y <- isolate(trans$mod - mean(trans$mod))
      } else if (input$waveletType == 3 && length(isolate(trans$res)) > 0) {
        title <- paste0(title," model residuals")
        req(trans$res)
        y <- isolate(trans$res - mean(trans$res))
      } else if (input$waveletType == 4 && length(isolate(trans$filter)) > 0) {
        title <- paste0(title," filter ")
        req(trans$filter)
        y <- isolate(trans$filter - mean(trans$filter))
      } else if (input$waveletType == 5 && length(isolate(trans$filterRes)) > 0) {
        title <- paste0(title," filter residuals")
        req(trans$filterRes)
        y <- isolate(trans$filterRes - mean(trans$filterRes))
      } else {
        updateRadioButtons(session, inputId = "waveletType", label = NULL, choices = list("None" = 0, "Original" = 1, "Model" = 2, "Model res." = 3, "Filter" = 4, "Filter res." = 5), selected = 0, inline = T, choiceNames = NULL,  choiceValues = NULL)
        req(info$stop)
      }
      if (min_scale < 0.999*get.min.scale(t*trans$x) || max_scale > 1.001*get.max.scale(t*trans$x) || num_scale > as.integer(get.nscales(t*trans$x) + 1) || num_scale < 2) {
        showNotification(HTML("The period bounds and/or resolution are not valid to compute the wavelet transform.<br>Check the input values."), action = NULL, duration = 10, closeButton = T, id = "no_wavelet", type = "error", session = getDefaultReactiveDomain())
        updateRadioButtons(session, inputId = "waveletType", label = NULL, choices = list("None" = 0, "Original" = 1, "Model" = 2, "Model res." = 3, "Filter" = 4, "Filter res." = 5), selected = 0, inline = T, choiceNames = NULL,  choiceValues = NULL)
        req(info$stop)
      }
      if (messages > 0) cat(file = stderr(), mySession, "Computing wavelet", "\n")
      if (input$waveletType > 0) {
        start.time <- Sys.time()
        suppressWarnings({
          withProgress(message = 'Computing wavelet transform.',
                       detail = 'This may take a while ...', value = 0.1, {
                         trans$wavelet <- mvcwt(t*trans$x, y, scale.exp = 0.5, nscales = num_scale, min.scale = min_scale, max.scale = max_scale, loc = regularize(t*trans$x, nsteps = locs), wave.fun = "Morlet")
                         setProgress(0.7) # just for progress bar lovers
                         Sys.sleep(1)
                         setProgress(1)
                         Sys.sleep(1)
                       })
        })
        end.time <- Sys.time()
        time.taken <- difftime(end.time, start.time, units = "secs")
        if (messages > 2) cat(file = stderr(), mySession, start.time, end.time, "Total time =", time.taken, "s\n")
      }
      isolate({
        levels <- suppressWarnings(signif(sd(trans$wavelet$z), 4))
        z.fun <- match.fun("Mod")
        attr(trans$wavelet, 'class') <- 'list'
        pal = colorRampPalette(rev(brewer.pal(11, "RdYlBu")))(1024)
        magin_in <- par("mar")
        magin_out <- par("oma")
        par(mar = magin_in + c(0, 3, 0, 3), oma = magin_out + c(1, 0, 0, 0))
        s <- info$sampling*365.25*t/7
        amplitude_approx <- s*array(t(t(as.matrix(z.fun(trans$wavelet$z[,,1]), ncols = length(trans$wavelet$y), nrows = length(trans$wavelet$x)))*(pi/2)/sqrt(trans$wavelet$y)), dim = c(length(trans$wavelet$x),length(trans$wavelet$y),1))
        trans$wavelet$x <- trans$wavelet$x/t
        trans$wavelet$y <- trans$wavelet$y/t
        if (num_scale > 10) {
          image(trans$wavelet$x, trans$wavelet$y, amplitude_approx[,,1], col = pal, xlab = "", ylab = "", log = "y")
          image.plot(zlim = range(amplitude_approx[,,1]), legend.only = T, col = pal, legend.args = list(text = paste("Amplitude", units), cex = 1, side = 2, las = 2, line = 1), legend.shrink = 0.5, legend.width = 0.5, legend.mar = 2, horizontal = T)
        } else {
          image(trans$wavelet$x, trans$wavelet$y, z.fun(trans$wavelet$z[,,1]), col = pal, xlab = "", ylab = "")
          image.plot(zlim = range(z.fun(trans$wavelet$z[,,1])), legend.only = T, col = pal, legend.args = list(text = paste("Amplitude", units), cex = 1, side = 2, las = 2, line = 1), legend.shrink = 0.5, legend.width = 0.5, legend.mar = 2, horizontal = T)
        }
        box()
        mtext(paste0("Period (",period,")"), side = 2, line = 3, outer = F)
        contour(trans$wavelet$x, trans$wavelet$y, z.fun(trans$wavelet$z[,,1]), levels = c(levels, levels*2, levels*3), add = T, labcex = 1.1, drawlabels = F)
        title(main = title)
        coord <- unlist(as.list(which(amplitude_approx == max(amplitude_approx), arr.ind = T)))
        points(trans$wavelet$x[coord[1]], trans$wavelet$y[coord[2]], pch = "*", cex = 3, col = SARIcolors[1])
        lines(min(trans$wavelet$x) + trans$wavelet$y, trans$wavelet$y, lty = 2, lwd = 3, col = SARIcolors[1])
        lines(max(trans$wavelet$x) - trans$wavelet$y, trans$wavelet$y, lty = 2, lwd = 3, col = SARIcolors[1])
      })
      if (input$tab == 1 || input$format == 4) {
        runjs("window.scrollTo(0,document.getElementById('wl1').offsetTop);")
      } else if (input$tab == 2) {
        runjs("window.scrollTo(0,document.getElementById('wl2').offsetTop);")
      } else if (input$tab == 3) {
        runjs("window.scrollTo(0,document.getElementById('wl3').offsetTop);")
      }
      #
      if (isTruthy(debug)) {
        debugMem()
      }
      output$wavelet1_info <- output$wavelet2_info <- output$wavelet3_info <- renderText({
        if (length(input$wavelet_1click$x) > 0) {
          idx <- which.min(abs(trans$wavelet$x - input$wavelet_1click$x))
          idy <- which.min(abs(trans$wavelet$y - input$wavelet_1click$y))
          paste0("\tEpoch = ", input$wavelet_1click$x, "\tPeriod (", period, ") = ", input$wavelet_1click$y, "\t\tAmplitude = ", amplitude_approx[idx,idy,1])
        }
      })
    } else {
      inputs$min_wavelet <- ""
      inputs$max_wavelet <- ""
      info$run_wavelet <- T
    }
    #
    if (isTruthy(debug)) {
      debugMem()
    }
  }, width = reactive(info$width))

  # Compute smoother ####
  observeEvent(c(input$sigmas, inputs$low, inputs$high, input$filter, trans$y, input$series2filter, trans$res), {
    req(trans$x, trans$y, trans$sy, input$series2filter)
    removeNotification("no_smooth")
    removeNotification("same_periods")
    removeNotification("no_points")
    if (isTruthy(input$filter)) {
      if (length(trans$y) < 4) {
        showNotification(HTML("Not enough points.<br>Unable to smooth the series"), action = NULL, duration = 10, closeButton = T, id = "no_smooth", type = "error", session = getDefaultReactiveDomain())
        req(info$stop)
      }
      if (inputs$high == "" || is.na(inputs$high)) {
        high <- 0
      } else {
        if (nchar(inputs$high) > 0 && !is.na(inputs$high)) {
          high <- inputs$high
        } else {
          high <- 0
        }
      }
      if (inputs$low == "" || is.na(inputs$low)) {
        low <- 0
      } else {
        if (nchar(inputs$low) > 0 && !is.na(inputs$low)) {
          low <- inputs$low
        } else {
          low <- 0
        }
      }
      filter_low <- NULL
      filter_high <- NULL
      if (low != high) {
        if (input$series2filter == 1) {
          ordinate <- mean(trans$y)
          y <- trans$y - ordinate
          sy <- trans$sy
        } else if (input$series2filter == 2 && length(trans$res) > 0) {
          ordinate <- mean(trans$res)
          y <- trans$res - ordinate
          if (input$fitType == 1) {
            sy <- trans$reserror
          } else if (input$fitType == 2) {
            sy <- trans$sy
          }
        } else {
          low <- high <- 0
        }
        if (low > 0) {
          if (messages > 0) cat(file = stderr(), mySession, "Vondrak low", low, "\n")
          filter_low <- try(vondrak(trans$x, y, sy, as.numeric(low)), silent = F)
          if (!inherits(filter_low,"try-error") && !is.null(filter_low)) {
            trans$vondrak[1] <- low
          } else {
            showNotification(HTML("Unable to smooth the series.<br>Change the filter parameters"), action = NULL, duration = 10, closeButton = T, id = "no_smooth", type = "error", session = getDefaultReactiveDomain())
          }
        } else {
          trans$vondrak[1] <- NA
        }
        if (high > 0) {
          if (messages > 0) cat(file = stderr(), mySession, "Vondrak high", high, "\n")
          filter_high <- try(vondrak(trans$x, y, sy, as.numeric(high)), silent = F)
          if (!inherits(filter_high,"try-error") && !is.null(filter_high)) {
            trans$vondrak[2] <- high
          } else {
            showNotification(HTML("Unable to smooth the series.<br>Change the filter parameters"), action = NULL, duration = 10, closeButton = T, id = "no_smooth", type = "error", session = getDefaultReactiveDomain())
          }
        } else {
          trans$vondrak[2] <- NA
        }
        if (length(filter_low) > 0 && length(filter_high) > 0) {
          if (high < low) {
            trans$filter <- y - (filter_high - filter_low) + ordinate
          } else if (high > low) {
            trans$filter <- filter_low - filter_high + ordinate
          }
          trans$filterRes <- y - trans$filter + ordinate
        } else if (length(filter_low) > 0) {
          trans$filter <- filter_low + ordinate
          trans$filterRes <- y - trans$filter + ordinate
        } else if (length(filter_high) > 0) {
          trans$filter <- y - filter_high + ordinate
          trans$filterRes <- y - trans$filter + ordinate
        } else {
          trans$filter <- NULL
          trans$filterRes <- NULL
        }
      } else if (low == 0) {
        trans$filter <- NULL
        trans$filterRes <- NULL
      } else {
        showNotification(HTML("Low-pass and high-pass periods are equal.<br>Unable to smooth the series.<br>Change the smoother parameters"), action = NULL, duration = 10, closeButton = T, id = "same_periods", type = "error", session = getDefaultReactiveDomain())
        trans$filter <- NULL
        trans$filterRes <- NULL
      }
    } else {
      trans$filter <- NULL
      trans$filterRes <- NULL
    }
    #
    if (isTruthy(debug)) {
      debugMem()
    }
  }, priority = 1)

  # Plot smoother ####
  output$vondrak1 <- output$vondrak2 <- output$vondrak3 <- output$Vondrak1 <- output$Vondrak2 <- output$Vondrak3 <- renderPlot({
    req(db1[[info$db1]],input$filter)
    if (length(trans$filterRes) > 0) {
      if (messages > 0) cat(file = stderr(), mySession, "Plotting Vondrak", "\n")
      if ((length(inputs$low) > 0 && inputs$low > 0 && !is.na(inputs$low)) || (length(inputs$high) > 0 && inputs$high > 0 && !is.na(inputs$high))) {
        title <- "Filter residuals"
        sigmas <- F
        if (isTruthy(input$sigmas) && ((input$format == 4 && isTruthy(inputs$errorBar)) || input$format != 4)) {
          sigmas <- T
        }
        if (input$series2filter == 1) {
          plot_series(trans$x,trans$filterRes,trans$sy,ranges$x2,ranges$y2,sigmas,"",input$symbol,T,"")
        } else if (input$series2filter == 2 && length(trans$res) > 0) {
          if (input$fitType == 1) {
            plot_series(trans$x,trans$filterRes,trans$reserror,ranges$x2,ranges$y2,sigmas,"",input$symbol,T,"")
          } else if (input$fitType == 2) {
            plot_series(trans$x,trans$filterRes,trans$sy,ranges$x2,ranges$y2,sigmas,"",input$symbol,T,"")
          }
        }
        title(title, line = 3)
      }
    }
  }, width = reactive(info$width))

  # Noise analysis ####
  observeEvent(input$runmle, {
    removeNotification("no_mle")
    removeNotification("no_optim")
    removeNotification("too_long")
    removeNotification("timeWillTake")
    if (length(trans$res) > 0 || length(trans$filterRes) > 0) {
      trans$noise <- vector(length = 11)
      if (length(trans$res) > 0) {
        res <- trans$res
        resError <- trans$reserror
      } else if (length(trans$filterRes) > 0) {
        res <- unlist(as.list(trans$filterRes))
        resError <- trans$sy
      }
      req(res)
      vari <- var(res)
      n <- length(res)
      n_all <- length(trans$gaps)
      component <- 0
      convergence <- 1
      withBusyIndicatorServer("runmle", {
        cat(file = stderr(), mySession, "MLE fit", "\n")
        start.time <- Sys.time()
        if (messages > 2) cat(file = stderr(), mySession, "MLE fit start:", format(Sys.time(), "%Y-%m-%dT%H:%M:%S"), "\n")
        message <- ""
        if (isTruthy(info$timeMLE)) {
          if (info$timeMLE < 60) {
            message <- paste("This should take less than 1 min")
          } else {
            message <- paste("This may take about", ceiling(info$timeMLE/60), "min")
          }
        }
        withProgress(message = 'Fitting the noise model.',
                     detail = message, value = 0, {
                       # build known covariance matrices
                       if (input$white) {
                         component <- component + 1
                         info$white <- T
                         Cwh <- diag(n)
                       } else {
                         info$white <- F
                       }
                       if (input$flicker) {
                         component <- component + 1
                         info$flicker <- T
                         Cfl <- cov_powerlaw(-1,n_all,F,trans$gaps,info$sampling)[[1]]
                       } else {
                         info$flicker <- F
                       }
                       if (input$randomw) {
                         component <- component + 1
                         info$randomw <- T
                         Crw <- cov_powerlaw(-2,n_all,F,trans$gaps,info$sampling)[[1]]
                       } else {
                         info$randomw <- F
                       }
                       if (input$powerl) {
                         component <- component + 2
                         info$powerl <- T
                         Cfl <- cov_powerlaw(-1,n_all,F,trans$gaps,info$sampling)[[1]]
                       } else {
                         info$powerl <- F
                       }

                       # Noise optimization
                       CPL <- NULL # this and next two are updated inside loglik_global and used inside grad_global
                       Qinv <- NULL
                       QinvR <- NULL
                       fitmle <- NULL
                       apriori <- NULL
                       cl <- NULL
                       scaling <- 1/sd(res)
                       resS <- res*scaling
                       if (isTruthy(input$noise_unc)) {
                         hessian <- T
                       } else {
                         hessian <- F
                       }

                       loglik_global <- function(x) {
                         h <- 0
                         k <- 0
                         CPL <<- NULL
                         Qinv <<- NULL
                         QinvR <<- NULL
                         if (white) {
                           h <- 1
                           wh <- exp(x[h])
                           Q <- wh * Cwh
                         } else {
                           Q <- matrix(0, ncol = n, nrow = n)
                         }
                         if (flicker) {
                           h <- h + 1
                           k <- -1
                           fl <- exp(x[h])
                           Q <- Q + fl * Cfl
                         }
                         if (randomw) {
                           h <- h + 1
                           k <- -2
                           rw <- exp(x[h])
                           Q <- Q + rw * Crw
                         }
                         if (powerl) {
                           h <- h + 1
                           pl <- exp(x[h])
                           h <- h + 1
                           k <- x[h] + 3
                           x <- head(x, -1)
                           CPL <<- cov_powerlaw(k,n_all,T,gaps,sampling)
                           Cpl <- CPL[[1]]
                           k_deriv <- CPL[[2]]
                           Q <- Q + pl * Cpl
                         }
                         ll_out <- loglikelihood(resS,Q,0)
                         ll <- ll_out[[1]]
                         Qinv <<- ll_out[[2]]
                         QinvR <<- ll_out[[3]]
                         if (method == "NLM") {
                           attr(ll, "gradient") <- grad_global(x)
                         }
                         if (messages > 2) cat(file = stderr(), mySession, "Std Dev noises =", sqrt(exp(x))/scaling, " (", x, ") Index =", k, " loglik =", sprintf("%f",ll), "\n")
                         ll/-1
                       }
                       grad_global <- function(x) {
                         grad <- NULL
                         h <- 0
                         trQinv <- crossprod(resS, Qinv)
                         if (white) {
                           h <- h + 1
                           wh <- exp(x[h])
                           if (exists("grad_cpp", mode = "function")) {
                             grad <- grad_cpp(Qinv,QinvR,trQinv,diag(length(resS)),wh)
                           } else {
                             grad <- -0.5*(tr(Qinv) - sum(dot(trQinv, QinvR)))[1]*wh
                           }
                         }
                         if (flicker) {
                           h <- h + 1
                           fl <- exp(x[h])
                           if (exists("grad_cpp", mode = "function")) {
                             grad <- c(grad, grad_cpp(Qinv,QinvR,trQinv,Cfl,fl))
                           } else {
                             grad <- c(grad, -0.5*(sum(dot(Qinv,Cfl)) - sum(dot(trQinv, Cfl %*% QinvR)))[1]*fl)
                           }
                         }
                         if (randomw) {
                           h <- h + 1
                           rw <- exp(x[h])
                           if (exists("grad_cpp", mode = "function")) {
                             grad <- c(grad, grad_cpp(Qinv,QinvR,trQinv,Crw,rw))
                           } else {
                             grad <- c(grad, -0.5*(sum(dot(Qinv,Crw)) - sum(dot(trQinv, Crw %*% QinvR)))[1]*rw)
                           }
                         }
                         if (powerl) {
                           h <- h + 1
                           pl <- exp(x[h])
                           h <- h + 1
                           k <- x[h] + 3
                           x <- head(x, -1)
                           Cpl <- CPL[[1]]
                           k_deriv <- pl * CPL[[2]]
                           if (exists("grad_cpp", mode = "function")) {
                             grad <- c(grad, grad_cpp(Qinv,QinvR,trQinv,Cpl,pl))
                             grad <- c(grad, grad_cpp(Qinv,QinvR,trQinv,k_deriv,1))
                           } else {
                             grad <- c(grad, -0.5*(sum(dot(Qinv,Cpl)) - sum(dot(trQinv, Cpl %*% QinvR)))[1]*pl)
                             grad <- c(grad, -0.5*(sum(dot(Qinv,k_deriv)) - sum(dot(trQinv, k_deriv %*% QinvR)))[1])
                           }
                         }
                         if (messages > 2) cat(file = stderr(), mySession, "Grads =", grad/-1, "\n")
                         grad/-1
                       }

                       ##* one noise variance with fixed spectral index, easy peasy ####
                       if (component == 1) {
                         if (isTruthy(info$white)) {
                           variance <- var(resS)
                           VtPV <- variance*n
                           fitmle$value <- 0.5*(n*log(2*pi*variance) + n)
                         } else {
                           if (isTruthy(info$flicker)) {
                             C <- Cfl
                           }
                           if (isTruthy(info$randomw)) {
                             C <- Crw
                           }
                           setProgress(0.25)
                           VtPV <- crossprod(resS, solve(C, resS))
                           setProgress(0.75)
                           variance <- VtPV/n
                           fitmle$value <- 0.5*(n*log(2*pi*variance) + determinant(C)$modulus[[1]] + n)
                         }
                         fitmle$par <- log(variance)
                         fitmle$hessian <- (-n/(2*variance^2) + VtPV/variance^3) * variance
                         convergence <- 0
                       }
                       #* more than one noise variance ####
                       else if (component > 1) {
                         # computing a priori noise variances. RW is minimized to avoid having to much contribution in the final result (gradient of RW is usually very flat)
                         if (info$white) {
                           wh <- var(res)/sqrt(component)
                           apriori <- wh
                           typsize <- 3 # scale applied to the step size defined in the optimization run (which should be 1)
                           if (isTruthy(info$flicker)) {
                             fl <- (crossprod(res, solve(Cfl, res))/n)[1]/sqrt(component)
                             apriori <- c(apriori, fl)
                             typsize <- c(typsize, 3)
                             if (isTruthy(info$randomw)) {
                               rw <- (crossprod(res, solve(Crw, res))/n)[1]/sqrt(component)/1e3
                               apriori <- c(apriori, rw)
                               typsize <- c(typsize, 20)
                             }
                           } else if (isTruthy(info$randomw)) {
                             rw <- (crossprod(res, solve(Crw, res))/n)[1]/sqrt(component)/1e3
                             apriori <- c(apriori, rw)
                             typsize <- c(typsize, 20)
                           } else if (isTruthy(info$powerl)) {
                             pl <- (crossprod(res, solve(Cfl, res))/n)[1]/sqrt(component)
                             apriori <- c(apriori, pl)
                             typsize <- c(typsize, 3)
                           }
                         } else if (info$flicker) {
                           fl <- (crossprod(res, solve(Cfl, res))/n)[1]/sqrt(component)
                           apriori <- c(apriori, fl)
                           typsize <- 3
                           rw <- (crossprod(res, solve(Crw, res))/n)[1]/sqrt(component)/1e3
                           apriori <- c(apriori, rw)
                           typsize <- c(typsize, 20)
                         } else if (isTruthy(info$powerl)) {
                           pl <- (crossprod(res, solve(Cfl, res))/n)[1]/sqrt(component)
                           apriori <- c(apriori, pl)
                           typsize <- 3
                         }
                         setProgress(0.25)
                         apriori <- log(apriori*scaling^2)
                         upper <- apriori + log(3)
                         lower <- apriori - log(10)
                         if (isTruthy(info$powerl)) {
                           if (isTruthy(trans$slope) && trans$slope < 0 && trans$slope > -4) {
                             slope <- trans$slope - 3
                           } else {
                             slope <- -4
                           }
                           apriori <- c(apriori, slope) # a priori spectral index (= k - 3)
                           typsize <- c(typsize, 3) # max step scale: large enough to get the optimum quickly, but not very large to have numerical problems with the hessian; somewhere between 0.5 and 3
                           upper <- c(upper, -3) # max expected spectral index (= k - 3)
                           lower <- c(lower, -7) # min expected spectral index (= k - 3)
                         }
                         # creating non reactive variables for running on a cluster
                         white <- info$white
                         flicker <- info$flicker
                         randomw <- info$randomw
                         powerl <- info$powerl
                         gaps <- trans$gaps
                         sampling <- info$sampling
                         tryOptim <- try({
                           # setting cluster if run is local and long
                           # if (info$local && info$timeMLE > 60) {
                           #   cl <- makeCluster(detectCores() - 1, type = "FORK")
                           #   setDefaultCluster(cl = cl)
                           # }
                           if (isTruthy(cl)) {
                             # BFGS quasi-Newton method with box (actually upper only) constraints, Byrd et. al. (1995)
                             method <- "L-BFGS-B"
                             fitmle <- optimParallel(par = apriori,
                                                     fn = loglik_global,
                                                     gr = grad_global,
                                                     lower = lower,
                                                     upper = upper,
                                                     method = "L-BFGS-B",
                                                     hessian = hessian,
                                                     control = list(fnscale = 1, pgtol = 1e1, factr = 1e11)
                             )
                             setDefaultCluster(cl = NULL)
                             stopCluster(cl)
                           } else { # standard 1 proc run
                             # BFGS quasi-Newton method with box (actually upper only) constraints, Byrd et. al. (1995)
                             # method <- "L-BFGS-B"
                             # fitmle <- optim(par = apriori,
                             #                 fn = loglik_global,
                             #                 gr = grad_global,
                             #                 lower = lower,
                             #                 upper = upper,
                             #                 method = "L-BFGS-B",
                             #                 hessian = hessian,
                             #                 control = list(fnscale = 1, pgtol = 1e1, factr = 1e13)
                             # )

                             # if (isTruthy(info$powerl)) { # does not converge for < -2 slopes, using the NLM method for now
                             # Nelder and Mead (1965) method: provides better likelihoods, but can be slow as duck if the a priori values are not good!
                             # method <- "Nelder & Mead"
                             # fitmle <- optim(par = apriori,
                             #                 fn = loglik_global,
                             #                 hessian = hessian,
                             #                 control = list(fnscale = 1, reltol = 1e-2)
                             # )

                             # } else {
                             # Quasi-Newton method as in optim, but seems to run faster
                             method <- "NLM"
                             fitmle <- nlm(loglik_global, apriori, hessian = hessian, typsize = typsize,
                                           fscale = 1, print.level = 0, ndigit = 1, gradtol = 1e-2,
                                           stepmax = 1e0, steptol = 1e-2, iterlim = 100, check.analyticals = F)
                             setProgress(0.75)
                             if (fitmle$code < 4) { # transforming nlm results into optim format
                               fitmle$convergence <- 0
                               fitmle$value <- fitmle$minimum
                               fitmle$par <- fitmle$estimate
                             }
                             # }

                             if (fitmle$convergence == 0) {
                               convergence <- 0
                             }
                           }
                         }, silent = T)
                         if (inherits(tryOptim,"try-error") || tryOptim == "") {
                           showNotification(HTML("Something went wrong with the MLE optimization.<br>The tested model parameters are probably out of bounds."), action = NULL, duration = 10, closeButton = T, id = "no_optim", type = "error", session = getDefaultReactiveDomain())
                           req(info$stop)
                         }
                       }
                       Sys.sleep(1)
                       setProgress(1)
                     })

        ##* convergence ####
        if (!is.na(convergence)) {
          if (convergence == 0) {
            if (input$wiener) {
              kk <- loglik_global(fitmle$estimate) # updating noise covariance matrix from best noise estimates
            }
            trans$mle <- T
            sd_noises <- NA
            line3 <- NULL
            if (input$noise_unc) {
              sd_noises <- suppressWarnings(sqrt(diag(solve(fitmle$hessian))))
            }
            i <- 0
            sigmaFL <- NULL
            sigmaPL <- NULL
            sigmaRW <- NULL
            sigmaK <- NULL
            if (input$sunits == 1) {
              unit <- "m"
            } else if (input$sunits == 2) {
              unit <- "mm"
            } else {
              unit <- ""
            }
            if (isTruthy(info$white)) {
              i <- i + 1
              sigmaWH <- sqrt(exp(fitmle$par[i]))/scaling
              trans$noise[1] <- sigmaWH
              if (input$noise_unc) {
                seParmsWH <- sd_noises[i]/scaling
                trans$noise[2] <- seParmsWH
                if (isTruthy(sigmaWH) && isTruthy(seParmsWH) && sigmaWH > seParmsWH * 3) {
                  updateTextInput(session, inputId = "verif_white", value = sigmaWH)
                } else {
                  updateTextInput(session, inputId = "verif_white", value = "0")
                }
              } else {
                updateTextInput(session, inputId = "verif_white", value = sigmaWH)
              }
              if (input$wiener) {
                qQ <- (exp(fitmle$par[i])*Cwh) %*% Qinv
                trans$white <- unlist(as.list(res %*% qQ))
                if (input$sigmas && length(resError) > 0) {
                  trans$white_sig <- unlist(as.list(sqrt(diag(qQ %*% diag(resError^2) %*% t(qQ)))))
                }
              }
              output$est.white <- renderUI({
                line1 <- "White noise:"
                line2 <- formatting(sigmaWH,1)
                if (input$noise_unc) {
                  line3 <- paste("+/-", formatting(seParmsWH,1))
                }
                HTML(paste(line1,'<br/>',line2,unit,'<br/>',line3))
              })
            } else {
              updateTextInput(session, inputId = "verif_white", value = "0")
              trans$noise[1] <- NA
              trans$noise[2] <- NA
            }
            if (isTruthy(info$flicker)) {
              i <- i + 1
              sigmaFL <- sqrt(exp(fitmle$par[i]))/scaling
              trans$noise[3] <- sigmaFL
              if (input$noise_unc) {
                seParmsFL <- sd_noises[i]/scaling
                trans$noise[4] <- seParmsFL
                if (isTruthy(sigmaFL) && isTruthy(seParmsFL) && sigmaFL > seParmsFL * 3) {
                  updateTextInput(session, inputId = "verif_fl", value = sigmaFL)
                } else {
                  updateTextInput(session, inputId = "verif_fl", value = "0")
                }
              } else {
                updateTextInput(session, inputId = "verif_fl", value = sigmaFL)
              }
              if (input$wiener) {
                qQ <- (exp(fitmle$par[i])*Cfl) %*% Qinv
                trans$flicker <- unlist(as.list(res %*% qQ))
                if (input$sigmas && length(resError) > 0) {
                  trans$flicker_sig <- unlist(as.list(sqrt(diag(qQ %*% diag(resError^2) %*% t(qQ)))))
                }
              }
              output$est.flicker <- renderUI({
                line1 <- "Flicker noise:"
                line2 <- formatting(sigmaFL,1)
                if (input$noise_unc) {
                  line3 <- paste("+/-", formatting(seParmsFL,1))
                }
                HTML(paste(line1,'<br/>',line2, unit, '<br/>',line3))
              })
              updateRadioButtons(session, inputId = "typeColor", selected = 1)
            } else {
              updateTextInput(session, inputId = "verif_fl", value = "0")
              trans$noise[3] <- NA
              trans$noise[4] <- NA
            }
            if (isTruthy(info$randomw)) {
              i <- i + 1
              sigmaRW <- sqrt(exp(fitmle$par[i]))/scaling
              trans$noise[5] <- sigmaRW
              if (input$noise_unc) {
                seParmsRW <- sd_noises[i]/scaling
                trans$noise[6] <- seParmsRW
                if (isTruthy(sigmaRW) && isTruthy(seParmsRW) && sigmaRW > seParmsRW * 3) {
                  updateTextInput(session, inputId = "verif_rw", value = sigmaRW)
                } else {
                  updateTextInput(session, inputId = "verif_rw", value = "0")
                }
              } else {
                updateTextInput(session, inputId = "verif_rw", value = sigmaRW)
              }
              if (input$wiener) {
                qQ <- (exp(fitmle$par[i])*Crw) %*% Qinv
                trans$randomw <- unlist(as.list(res %*% qQ))
                if (input$sigmas && length(resError) > 0) {
                  trans$randomw_sig <- unlist(as.list(sqrt(diag(qQ %*% diag(resError^2) %*% t(qQ)))))
                }
              }
              output$est.randomw <- renderUI({
                line1 <- "Random walk:"
                line2 <- formatting(sigmaRW,1)
                if (input$noise_unc) {
                  line3 <- paste("+/-", formatting(seParmsRW,1))
                }
                HTML(paste(line1,'<br/>',line2, unit, '<br/>',line3))
              })
              updateRadioButtons(session, inputId = "typeColor", selected = 1)
            } else {
              updateTextInput(session, inputId = "verif_rw", value = "0")
              trans$noise[5] <- NA
              trans$noise[6] <- NA
            }
            if (isTruthy(info$powerl)) {
              i <- i + 1
              sigmaPL <- sqrt(exp(fitmle$par[i]))/scaling
              trans$noise[7] <- sigmaPL
              if (input$noise_unc) {
                seParmsPL <- sd_noises[i]/scaling
                trans$noise[8] <- seParmsPL
                if (isTruthy(sigmaPL) && isTruthy(seParmsPL) && sigmaPL > seParmsPL * 3) {
                  updateTextInput(session, inputId = "verif_pl", value = sigmaPL)
                } else {
                  updateTextInput(session, inputId = "verif_pl", value = "0")
                }
              } else {
                updateTextInput(session, inputId = "verif_pl", value = sigmaPL)
              }
              if (input$wiener) {
                qQ <- (exp(fitmle$par[i])*CPL[[1]]) %*% Qinv
                trans$powerl <- unlist(as.list(res %*% qQ))
                if (input$sigmas && length(resError) > 0) {
                  trans$powerl_sig <- unlist(as.list(sqrt(diag(qQ %*% diag(resError^2) %*% t(qQ)))))
                }
              }
              output$est.powerl <- renderUI({
                line1 <- "Power-law:"
                line2 <- formatting(sigmaPL,1)
                if (input$noise_unc) {
                  line3 <- paste("+/-", formatting(seParmsPL,1))
                }
                HTML(paste(line1,'<br/>',line2, unit, '<br/>',line3))
              })
              updateRadioButtons(session, inputId = "typeColor", selected = 2)
              i <- i + 1
              sigmaK <- fitmle$par[i] + 3
              trans$noise[9] <- sigmaK
              if (input$noise_unc) {
                seParmsK <- sd_noises[i]
                trans$noise[10] <- seParmsK
                if (isTruthy(sigmaK) && isTruthy(seParmsK) && abs(sigmaK) > seParmsK * 3) {
                  updateTextInput(session, inputId = "verif_k", value = sigmaK)
                } else {
                  updateTextInput(session, inputId = "verif_k", value = "0")
                }
              } else {
                updateTextInput(session, inputId = "verif_k", value = sigmaK)
              }
              output$est.index <- renderUI({
                line1 <- "Spectral index:"
                line2 <- format(sigmaK, nsmall = 3, trim = F, scientific = F)
                if (input$noise_unc) {
                  if (isTruthy(seParmsK) && seParmsK <= 0.0005) {
                    seParmsK <- 0.001
                  }
                  line3 <- paste("+/-", format(seParmsK, nsmall = 3, trim = F, scientific = F))
                }
                HTML(paste(line1,'<br/>',line2, '<br/>',line3))
              })
            } else {
              updateTextInput(session, inputId = "verif_pl", value = "0")
              updateTextInput(session, inputId = "verif_k", value = "0")
              trans$noise[7] <- NA
              trans$noise[8] <- NA
              trans$noise[9] <- NA
              trans$noise[10] <- NA
            }
            end.time <- Sys.time()
            if (messages > 2) cat(file = stderr(), mySession, "MLE fit end:", format(Sys.time(), "%Y-%m-%dT%H:%M:%S"), "\n")
            time.taken <- end.time - start.time
            if (messages > 2) cat(file = stderr(), mySession, "Total time =", time.taken, units(time.taken), "\n")
            if (isTruthy(info$white) || isTruthy(info$flicker) || isTruthy(info$randomw) || isTruthy(info$powerl)) {
              if (length(fitmle$value) > 0) {
                trans$noise[11] <- fitmle$value
              } else {
                trans$noise[11] <- NA
              }
              output$est.mle <- renderUI({
                if (isTruthy(trans$mle)) {
                  line1 <- sprintf("<br/>log-Likelihood = %.4f",fitmle$value/-1)
                  HTML(line1)
                } else {
                  NULL
                }
              })
            }
            output$est.unc <- renderUI({
              if ("Linear" %in% input$model && input$fitType == 1) {
                req(trans$unc)
                isolate({
                  estimateFormalUncertainty <- function() {
                    unc_pl <- 0
                    if (isTruthy(sigmaFL)) {
                      unc_pl <- pl_trend_unc(sigmaFL,-1,info$sampling,points) # general power-law trend uncertainty
                      # unc_pl <- sqrt( 1.78 * sigmaFL^2 * info$sampling^0.22 / ((info$points - 1) * info$sampling)^2 ) # from Mao et al. (1999)
                      # unc_pl <- sqrt( 9 * sigmaFL^2*samplingScale^(-1/4) / (16 * (info$sampling)^2 * (info$points^2 - 1)) ) # from Zhang et al. (1997)
                    }
                    if (isTruthy(sigmaRW)) {
                      unc <- pl_trend_unc(sigmaRW,-2,info$sampling,points) # general power-law trend uncertainty
                      # unc <- sqrt( sigmaRW^2*samplingScale^(-2/4) / (info$points - 1) ) # from Zhang et al. (1997)
                      unc_pl <- sqrt(unc_pl^2 + unc^2)
                    }
                    if (isTruthy(sigmaPL)) {
                      # unc <- pl_trend_unc(sigmaPL*samplingScale^(sigmaK/4),sigmaK,info$sampling) # general power-law trend uncertainty
                      unc <- pl_trend_unc(sigmaPL,sigmaK,info$sampling,points) # general power-law trend uncertainty
                      unc_pl <- sqrt(unc_pl^2 + unc^2)
                    }
                    unc_white <- sqrt( 12 * sd(res)^2 / (points * ((points - 1) * info$sampling)^2) )
                    return(list(unc_pl,unc_white))
                  }
                  rate_ids <- which(grepl("Rate",rownames(trans$LScoefs)))
                  if (input$breaking && length(trans$breakEpochs) > 0 && input$trendType > 0) {
                    if (length(rate_ids) == (length(trans$breakEpochs) + 1)) {
                      line <- ""
                      for (breaks in seq_len(length(trans$breakEpochs) + 1)) {
                        if (breaks == 1) {
                          points <- sum(trans$x <= trans$breakEpochs[breaks])
                        } else if (breaks == length(trans$breakEpochs) + 1) {
                          points <- sum(trans$x > trans$breakEpochs[breaks - 1])
                        } else {
                          points <- sum(trans$x > trans$breakEpochs[breaks - 1] & trans$x <= trans$breakEpochs[breaks])
                        }
                        if (isTruthy(trans$mle)) {
                          unc <- estimateFormalUncertainty()
                          unc_pl <- unc[[1]]
                          unc_white <- unc[[2]]
                          if (isTruthy(unc_pl) && unc_pl > 0) {
                            trans$LScoefs[rate_ids[breaks],2] <- sqrt(unc_pl^2 + trans$unc[breaks]^2)
                            # trans[[paste0("plotInfo", input$tab)]][[info$db1]][2] <- trans$LScoefs[2,2]
                            trans$results$coefficients[rate_ids[breaks],2] <- sqrt(unc_pl^2 + trans$unc[breaks]^2)
                            trans$results$coefficients[rate_ids[breaks],3] <- abs(trans$results$coefficients[rate_ids[breaks],1]) / trans$results$coefficients[rate_ids[breaks],2]
                            trans$results$coefficients[rate_ids[breaks],4] <- 2 * pt(abs(trans$results$coefficients[rate_ids[breaks],3]), trans$results$df , lower.tail = F)[2]
                            line1 <- sprintf("<br/>Colored/white rate error ratio %d = %.2f", breaks,unc_pl/unc_white)
                          } else {
                            line1 <- NULL
                          }
                        } else {
                          if (isTruthy(trans$LScoefs[rate_ids[breaks],2])) {
                            trans$LScoefs[rate_ids[breaks],2] <- trans$unc[breaks]
                            # trans[[paste0("plotInfo", input$tab)]][[info$db1]][2] <- trans$LScoefs[2,2]
                          }
                          if (isTruthy(trans$results$coefficients[rate_ids[breaks],2])) {
                            trans$results$coefficients[rate_ids[breaks],2] <- trans$unc[breaks]
                            trans$results$coefficients[rate_ids[breaks],3] <- abs(trans$results$coefficients[rate_ids[breaks],1]) / trans$results$coefficients[rate_ids[breaks],2]
                            trans$results$coefficients[rate_ids[breaks],4] <- 2 * pt(abs(trans$results$coefficients[rate_ids[breaks],3]), trans$results$df , lower.tail = F)[2]
                          }
                          line1 <- NULL
                        }
                        line <- paste(line, line1, sep = "<br/>")
                      }
                      updateOverview() # updating the overview plot
                      HTML(line)
                    }
                  } else {
                    points <- info$points
                    if (isTruthy(trans$mle)) {
                      unc <- estimateFormalUncertainty()
                      unc_pl <- unc[[1]]
                      unc_white <- unc[[2]]
                      if (isTruthy(unc_pl) && unc_pl > 0) {
                        trans$LScoefs[rate_ids,2] <- sqrt(unc_pl^2 + trans$unc^2)
                        trans[[paste0("plotInfo", input$tab)]][[info$db1]][2] <- trans$LScoefs[rate_ids,2]
                        trans$results$coefficients[rate_ids,2] <- sqrt(unc_pl^2 + trans$unc^2)
                        trans$results$coefficients[rate_ids,3] <- abs(trans$results$coefficients[rate_ids,1]) / trans$results$coefficients[rate_ids,2]
                        trans$results$coefficients[rate_ids,4] <- 2 * pt(abs(trans$results$coefficients[rate_ids,3]), trans$results$df , lower.tail = F)[2]
                        line1 <- sprintf("<br/>Colored/white rate error ratio = %.2f", unc_pl/unc_white)
                      } else {
                        line1 <- NULL
                      }
                    } else {
                      if (isTruthy(trans$LScoefs[rate_ids,2])) {
                        trans$LScoefs[rate_ids,2] <- trans$unc
                        trans[[paste0("plotInfo", input$tab)]][[info$db1]][2] <- trans$LScoefs[rate_ids,2]
                      }
                      if (isTruthy(trans$results$coefficients[rate_ids,2])) {
                        trans$results$coefficients[rate_ids,2] <- trans$unc
                        trans$results$coefficients[rate_ids,3] <- abs(trans$results$coefficients[rate_ids,1]) / trans$results$coefficients[rate_ids,2]
                        trans$results$coefficients[rate_ids,4] <- 2 * pt(abs(trans$results$coefficients[rate_ids,3]), trans$results$df , lower.tail = F)[2]
                      }
                      line1 <- NULL
                    }
                    updateOverview() # updating the overview plot
                    HTML(line1)
                  }
                })
              }
            })
          } else {
            trans$mle <- F
            showNotification(HTML("The MLE optimization did not converge.<br>The tested model parameters are probably out of bounds."), action = NULL, duration = 10, closeButton = T, id = "no_mle", type = "error", session = getDefaultReactiveDomain())
          }
        }
      })
    }
    #
    if (isTruthy(debug)) {
      debugMem()
    }
  })

  # Search offsets ####
  observeEvent(input$search, {
    req(db1$original)
    removeNotification("bad_search")
    removeNotification("no_search")
    if (length(trans$res) > 0) {
      if (messages > 0) cat(file = stderr(), mySession, "Searching offsets", "\n")
      output$offsetFound <- renderUI({
        NULL
      })
      if (length(trans$x) < 40) {
        piece <- length(trans$x)/2 - 1
      } else {
        piece <- as.integer(length(trans$x)/20)
      }
      if (length(trans$x) < 20) {
        extension <- 2
      } else {
        extension <- as.integer(length(trans$x)/10)
      }
      segment <- input$segmentLength/100
      if (segment*length(trans$x) < 3) {
        showNotification(HTML("The segment size is too small for the series sampling.<br>Consider using a larger segment size."), action = NULL, duration = 10, closeButton = T, id = "bad_search", type = "error", session = getDefaultReactiveDomain())
        req(info$stop)
      }
      lag <- 1
      withBusyIndicatorServer("search", {
        center_ini <- mean(trans$res[1:piece])
        disp_ini <- sd(trans$res[1:piece])/2
        center_end <- mean(trans$res[(length(trans$res) - piece):length(trans$res)])
        disp_end <- sd(trans$res[(length(trans$res) - piece):length(trans$res)])/2
        extended_series <- ts(c(rnorm(extension,center_ini,disp_ini),trans$res, rnorm(extension,center_end,disp_end)))
        extended_series <- cbind(extended_series, lag(extended_series, k = -lag))
        colnames(extended_series) <- c("y", "ylag1")
        withProgress(message = 'Searching discontinuities.',
                     detail = 'This may take a while ...', value = 0.1, {
                       breaks <- breakpoints(y ~ ylag1, data = extended_series, h = segment)
                       setProgress(0.7) # just for progress bar lovers
                       Sys.sleep(1)
                       setProgress(1)
                       Sys.sleep(1)
                     })
        output$offsetFound <- renderUI({
          if (isTruthy(breaks$breakpoints)) {
            line <- paste(0.5*info$sampling + trans$x[(breaks$breakpoints + 1 - extension)[which((breaks$breakpoints + 1 - extension) > 0 & (breaks$breakpoints + 1 - extension) < length(trans$x))]],collapse = ", ")
          } else {
            line <- "None found"
          }
          HTML(line)
        })
      })
    } else {
      showNotification("Finding discontinuities is only possible from detrended series or, more generally, residual series.", action = NULL, duration = 10, closeButton = T, id = "no_search", type = "error", session = getDefaultReactiveDomain())
    }
    #
    if (isTruthy(debug)) {
      debugMem()
    }
  })

  # Download results ####
  ## Local directory ####
  output$localDirectory <- renderPrint({
    if (isTruthy(info$directory)) {
      cat(info$directory)
    }
  })
  observeEvent(input$autoDownload, {
    removeNotification("no_directory")
    withBusyIndicatorServer("autoDownload", {
      if (isTruthy(info$directory)) {
        if (input$format != 4) {
          if (any(grepl("East", info$components))) {
            file_out <- paste0(info$directory, "\\", file$primary$name, "_", strsplit(info$components[as.numeric(input$tab)], " ")[[1]][1], ".sari")
          } else {
            file_out <- paste0(info$directory, "\\", file$primary$name, "_", input$tab, ".sari")
          }
        } else {
          file_out <- paste0(info$directory, "\\", file$primary$name, ".sari")
        }
        collect(file_out)
      } else {
        showNotification(HTML("Download directory not found.<br>File download skipped."), action = NULL, duration = 10, closeButton = T, id = "no_directory", type = "error", session = getDefaultReactiveDomain())
      }
    })
  })
  ## Save series ####
  output$download <- output$downloadAs <- downloadHandler(
    filename = function() {
      if (input$format != 4) {
        if (input$tab == 4) {
          paste0(file$primary$name, "_3D.sari")
        } else if (input$tab == 5) {
          paste0(file$primary$name, "_res.sari")
        } else {
          if (any(grepl("East", info$components))) {
            paste0(file$primary$name, "_", strsplit(info$components[as.numeric(input$tab)], " ")[[1]][1], ".sari")
          } else {
            paste0(file$primary$name, "_", input$tab, ".sari")
          }
        }
      } else {
        paste0(file$primary$name, ".sari")
      }
    },
    content = function(file) {
      collect(file)
    }
  )
  ## Save spectrum ####
  output$downloadSpectrum1 <- output$downloadSpectrum2 <- output$downloadSpectrum3 <- downloadHandler(
    filename = function() {
      if (input$format != 4) {
        if (any(grepl("East", info$components))) {
          paste0(file$primary$name, "_", strsplit(info$components[as.numeric(input$tab)], " ")[[1]][1], ".periodogram.sari")
        } else {
          paste0(file$primary$name, "_", input$tab, ".periodogram.sari")
        }
      } else {
        paste0(file$primary$name, ".periodogram.sari")
      }
    },
    content = function(file) {
      collect_periodogram(file)
    }
  )
  ## Save help file ####
  #Based on https://stackoverflow.com/questions/40420450/how-to-download-a-pdf-file-in-a-shiny-app
  output$print_out <- downloadHandler(
    filename = function() {
      paste0(gsub(" ", "_", version),".pdf")
    },
    content = function(file) {
      if (messages > 0) cat(file = stderr(), mySession, "Downloading help file", "\n")
      file.copy("www/about.pdf", file)
    }
  )

  # Control plots ####
  output$showHeader <- renderText({
    req(input$header, file$primary)
    if (input$tab < 4 && length(trans$x) > 0 && input$format < 4) {
      if (input$sigmas) {
        header <- data.frame(x = sprintf("%.*f", info$decimalsx, trans$x), y = sprintf("%.*f", info$decimalsy, trans$y), sy = sprintf("%.*f", info$decimalsy, trans$sy))[1:input$lines,]
      } else {
        header <- data.frame(x = sprintf("%.*f", info$decimalsx, trans$x), y = sprintf("%.*f", info$decimalsy, trans$y))[1:input$lines,]
      }
      tmpfile <- tempfile()
      write.table(header, file = tmpfile, append = F, sep = "\t", quote = F, na = "NA", row.names = F, col.names = F)
      noquote(paste(readLines(con = tmpfile, ok = T, warn = F, skipNul = F, encoding = "UTF8"), collapse = "\n"))
    } else if (input$tab == 5) {
      NULL
    } else {
      noquote(paste(readLines(con = file$primary$datapath, n = input$lines, ok = T, warn = F, skipNul = F, encoding = "UTF8"), collapse = "\n"))
    }
  })
  observeEvent(input$remove3D, {
    req(db1$original)
    if (messages > 0) cat(file = stderr(), mySession, "Removing from all series is", input$remove3D, "\n")
  })
  observeEvent(input$permanent, {
    req(input$permanent)
    if (messages > 0) cat(file = stderr(), mySession, "Deleting next points\n")
  })
  observeEvent(input$plot_2click, {
    req(db1[[info$db1]])
    if (input$tab == 1) {
      values_now <- db1[[info$db1]]$status1
    } else if (input$tab == 2) {
      values_now <- db1[[info$db1]]$status2
    } else if (input$tab == 3) {
      values_now <- db1[[info$db1]]$status3
    }
    brush <- input$plot_brush
    if (!is.null(brush) && isTruthy(trans$y0[trans$x0 >= brush$xmin & trans$x0 <= brush$xmax]) && !all(is.na(values_now[trans$x0[!is.na(trans$y0)] > brush$xmin & trans$x0[!is.na(trans$y0)] < brush$xmax]))) {
      ranges$x1 <- c(brush$xmin, brush$xmax)
      ids <- trans$x >= ranges$x1[1] & trans$x <= ranges$x1[2]
      if (length(trans$y[ids & trans$y >= brush$ymin & trans$y <= brush$ymax]) > 0) {
        ranges$y1 <- c(brush$ymin, brush$ymax)
      } else {
        ranges$y1 <- range(trans$y[ids], na.rm = T)
        if (any(is.na(ranges$y1)) || any(is.infinite(ranges$y1))) {
          ranges$y1 <- range(trans$y, na.rm = T)
        }
      }
      if (length(file$secondary) > 0 && input$optionSecondary == 1 && any(!is.na(trans$y2))) {
        ids <- trans$x2 >= ranges$x1[1] & trans$x2 <= ranges$x1[2]
        if (sum(ids) > 0) {
          ranges$y12 <- range(trans$y2[ids], na.rm = T)
          if (any(is.na(ranges$y12)) || any(is.infinite(ranges$y12))) {
            ranges$y12 <- range(trans$y2, na.rm = T)
          }
        } else {
          ranges$y12 <- range(trans$y2, na.rm = T)
        }
      }
      ranges$x2 <- ranges$x4 <- ranges$x1
      ranges$y2 <- NULL
    } else {
      ranges$x1 <- c(info$minx, info$maxx)
      ranges$y1 <- c(info$miny, info$maxy)
      ranges$y12 <- NULL
      ranges$x2 <- NULL
      ranges$y2 <- NULL
      ranges$x4 <- NULL
      ranges$y4 <- NULL
    }
  })
  observeEvent(c(input$plot41_2click, input$plot42_2click, input$plot43_2click, input$plot51_2click, input$plot52_2click, input$plot53_2click), {
    req(db1[[info$db1]])
    brush <- NULL
    if (length(input$plot41_brush) > 0) {
      brush <- input$plot41_brush
    } else if (length(input$plot42_brush) > 0) {
      brush <- input$plot42_brush
    } else if (length(input$plot43_brush) > 0) {
      brush <- input$plot43_brush
    } else if (length(input$plot51_brush) > 0) {
      brush <- input$plot51_brush
    } else if (length(input$plot52_brush) > 0) {
      brush <- input$plot52_brush
    } else if (length(input$plot53_brush) > 0) {
      brush <- input$plot53_brush
    }
    statusAll <- colSums(t(cbind(db1[[info$db1]]$status1, db1[[info$db1]]$status2, db1[[info$db1]]$status3))) > 0
    x0 <- db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(statusAll)]
    if (!is.null(brush) && !all(is.na(x0[x0 > brush$xmin & x0 < brush$xmax]))) {
      ranges$x1 <- ranges$x2 <- ranges$x4 <- c(brush$xmin, brush$xmax)
      ranges$y1 <- ranges$y2 <- NULL
    } else {
      ranges$x1 <- c(info$minx, info$maxx)
      ranges$y1 <- NULL
      ranges$y12 <- NULL
      ranges$x2 <- NULL
      ranges$y2 <- NULL
      ranges$x4 <- NULL
      ranges$y4 <- NULL
    }
  })
  observeEvent(input$res_2click, {
    req(db1[[info$db1]])
    brush <- NULL
    if (isTruthy(input$res_brush)) {
      brush <- input$res_brush
      res <- trans$res
    } else if (isTruthy(input$vondrak_brush)) {
      brush <- input$vondrak_brush
      res <- trans$filterRes
    }
    if (input$tab == 1) {
      values_now <- db1[[info$db1]]$status1
    } else if (input$tab == 2) {
      values_now <- db1[[info$db1]]$status2
    } else if (input$tab == 3) {
      values_now <- db1[[info$db1]]$status3
    }
    if (!is.null(brush) && isTruthy(trans$y0[trans$x0 > brush$xmin & trans$x0 < brush$xmax]) && !all(is.na(values_now[trans$x0[!is.na(trans$y0)] > brush$xmin & trans$x0[!is.na(trans$y0)] < brush$xmax]))) {
      ranges$x2 <- c(brush$xmin, brush$xmax)
      ids <- trans$x >= ranges$x2[1] & trans$x <= ranges$x2[2]
      if (sum(res[ids & res >= brush$ymin & res <= brush$ymax]) > 0) {
        ranges$y2 <- c(brush$ymin, brush$ymax)
      } else {
        ranges$y2 <- range(res[ids], na.rm = T)
        if (any(is.na(ranges$y2)) || any(is.infinite(ranges$y2))) {
          ranges$y2 <- range(res, na.rm = T)
        }
      }
      ranges$x1 <- ranges$x4 <- ranges$x2
      ids <- trans$x0 > ranges$x1[1] & trans$x0 < ranges$x1[2]
      ranges$y1 <- range(trans$y0[ids], na.rm = T)
      if (length(file$secondary) > 0 && input$optionSecondary == 1 && any(!is.na(trans$y2))) {
        ids <- trans$x2 >= ranges$x1[1] & trans$x2 <= ranges$x1[2]
        if (sum(ids) > 0) {
          ranges$y12 <- range(trans$y2[ids], na.rm = T)
          if (any(is.na(ranges$y12)) || any(is.infinite(ranges$y12))) {
            ranges$y12 <- range(trans$y2, na.rm = T)
          }
        } else {
          ranges$y12 <- range(trans$y2, na.rm = T)
        }
      }
    } else {
      ranges$x4 <- NULL
      ranges$y4 <- NULL
      ranges$x2 <- NULL
      ranges$y2 <- NULL
      ranges$x1 <- c(info$minx, info$maxx)
      ranges$y1 <- c(info$miny, info$maxy)
      ranges$y12 <- NULL
    }
  })
  observeEvent(input$lomb_2click, {
    req(db1[[info$db1]])
    brush <- input$lomb_brush
    if (!is.null(brush) && length(1/trans$fs[1/trans$fs >= brush$xmin & 1/trans$fs <= brush$xmax]) > 0) {
      ranges$x3 <- c(brush$xmin, brush$xmax)
      ranges$y3 <- c(brush$ymin, brush$ymax)
    } else {
      ranges$x3 <- NULL
      ranges$y3 <- NULL
    }
  })
  observeEvent(input$rate_2click, {
    req(db1[[info$db1]])
    brush <- input$rate_brush
    if (!is.null(brush)) {
      ranges$x4 <- c(brush$xmin, brush$xmax)
      ranges$y4 <- c(brush$ymin, brush$ymax)
      ranges$x1 <- ranges$x2 <- ranges$x4
      ids <- trans$x > ranges$x1[1] & trans$x < ranges$x1[2]
      ranges$y1 <- range(trans$y[ids])
      if (length(file$secondary) > 0 && input$optionSecondary == 1 && any(!is.na(trans$y2))) {
        ids <- trans$x0 >= ranges$x1[1] & trans$x0 <= ranges$x1[2]
        if (sum(ids) > 0) {
          ranges$y12 <- range(trans$y2[ids], na.rm = T)
          if (any(is.na(ranges$y12)) || any(is.infinite(ranges$y12))) {
            ranges$y12 <- range(trans$y2, na.rm = T)
          }
        } else {
          ranges$y12 <- range(trans$y2, na.rm = T)
        }
      }
    } else {
      ranges$x4 <- NULL
      ranges$y4 <- NULL
      ranges$x2 <- NULL
      ranges$y2 <- NULL
      ranges$x1 <- c(info$minx, info$maxx)
      ranges$y1 <- c(info$miny, info$maxy)
      ranges$y12 <- NULL
    }
  })

  # Enable/disable options ####
  observe({
    if (input$tab == "6") {
      disable("fitType")
      disable("autoDownload")
      disable("white")
      disable("reset")
      disable("cut")
      disable("strip")
      disable("delete_excluded")
      disable("loadSARI")
      disable("ids")
      disable("correct_waveform")
      disable("custom")
      disable("downloadAs")
      disable("printCustom")
      disable("printLog")
      disable("printSinfo")
      disable("printSoln")
      disable("spectrum")
      disable("spectrumFilter")
      disable("spectrumFilterRes")
      disable("spectrumModel")
      disable("spectrumOriginal")
      disable("spectrumResiduals")
      disable("spectrumType")
      disable("est.mle")
      disable("remove")
      disable("remove3D")
      disable("removeAuto")
      disable("series")
      disable("filter")
      disable("flicker")
      disable("format")
      disable("format2")
      disable("tunits")
      disable("sunits")
      disable("histogram")
      disable("histogramType")
      disable("log")
      disable("average")
      disable("midas")
      disable("entropy")
      disable("mle")
      disable("wiener")
      disable("model")
      disable("wavelet")
      disable("waveletType")
      disable("optionSecondary")
      disable("waveform")
      disable("plot")
      disable("plotAll")
      disable("overflow")
      disable("add_excluded")
      disable("permanent")
      disable("cut")
      disable("strip")
      disable("powerl")
      disable("randomw")
      disable("runVerif")
      disable("runmle")
      disable("noise_unc")
      disable("series2")
      disable("separator")
      disable("separator2")
      disable("ne")
      disable("series2filter")
      disable("typeSecondary")
      disable("fullSeries")
      disable("sigmas")
      disable("symbol")
      disable("sinfo")
      disable("soln")
      disable("header")
      disable("traceCustom")
      disable("traceLog")
      disable("traceSinfo")
      disable("traceSoln")
      disable("thresholdRes")
      disable("thresholdResN")
      disable("units")
      disable("verif_offsets")
      disable("euler")
      disable("gia")
      disable("server1")
      disable("station1")
      disable("product1")
      disable("server2")
      disable("station2")
      disable("product2")
      disable("swap")
      disable("step")
      disable("step2")
      disable("scaleFactor")
      disable("GPSdrac")
      disable("GALdrac")
      disable("BDSdrac")
      disable("GLOdrac")
      disable("trendType")
      disable("sinusoidType")
      disable("polyType")
    } else {
      # if (input$tab == 4 || input$tab == 5) {
        # runjs("document.getElementsByClassName('panel-primary')[3].classList.add('hidden');")
        # runjs("document.getElementsByClassName('panel-primary')[4].classList.add('hidden');")
      # } else {
        # runjs("document.getElementsByClassName('panel-primary')[3].classList.remove('hidden');")
        # runjs("document.getElementsByClassName('panel-primary')[4].classList.remove('hidden');")
      # }
      if (length(file$primary) > 0) {
        if (!isTruthy(db1$original)) {
          info$menu <- unique(c(info$menu, 2))
          updateCollapse(session, id = "menu", open = info$menu)
        }
        disable("server1")
        disable("station1")
        disable("product1")
        enable("reset")
        enable("ids")
        enable("symbol")
        enable("header")
        enable("separator")
        enable("format")
        enable("tunits")
        enable("sunits")
        enable("units")
        enable("plot")
        if (isTruthy(info$errorbars)) {
          enable("sigmas")
        } else {
          updateCheckboxInput(session, inputId = "sigmas", value = F)
          disable("sigmas")
        }
        if (input$sigmas == T) {
          enable("errorBar")
        } else {
          disable("errorBar")
        }
        if (isTruthy(db1[[info$db1]])) {
          disable("plot")
          disable("series")
          disable("format")
          disable("separator")
          if (isTruthy(info$product1) || isTruthy(url$server)) {
            disable("sunits")
          } else {
            enable("sunits")
          }
          enable("overflow")
          enable("cut")
          enable("strip")
          enable("log")
          enable("sinfo")
          enable("soln")
          enable("custom")
          enable("printLog")
          enable("printSinfo")
          enable("printSoln")
          enable("printCustom")
          enable("traceLog")
          enable("traceSinfo")
          enable("traceSoln")
          enable("traceCustom")
          enable("permanent")
          if (input$tab == 4 || input$tab == 5) {
            disable("loadSARI")
            disable("printLog")
            disable("printSinfo")
            disable("printSoln")
            disable("printCustom")
            if (!isTruthy(input$remove3D)) {
              updateCheckboxInput(session, inputId = "remove3D", value = T)
            }
            disable("remove3D")
          } else {
            enable("loadSARI")
            enable("printLog")
            enable("printSinfo")
            enable("printSoln")
            enable("printCustom")
            if (sum(db1[[info$db1]]$status1, na.rm = T) == sum(db1[[info$db1]]$status2, na.rm = T) && sum(db1[[info$db1]]$status1, na.rm = T) == sum(db1[[info$db1]]$status3, na.rm = T)) {
              enable("remove3D")
            } else {
              disable("remove3D")
            }
          }
          enable("midas")
          enable("entropy")
          enable("reset")
          if (isTruthy(input$station_lat) && isTruthy(input$station_lon)) {
            enable("showmap")
          } else {
            disable("showmap")
          }
          enable("average")
          if (!isTruthy(input$average) && length(inputs$step) > 0) {
            updateTextInput(session, inputId = "step", value = "")
          }
          # plate and GIA options
          enable("euler")
          enable("gia")
          if (input$format == 4 && input$eulerType == 1 && input$giaType == 1) {
            updateRadioButtons(session, inputId = "giaType", selected = 0)
          } else {
            if (!isTruthy(input$gia)) {
              updateRadioButtons(session, inputId = "giaType", selected = 0)
              updateTextInput(session, inputId = "giaTrend", value = "")
              updateSelectInput(session, inputId = "giaModel", selected = "")
              disable("giaType")
            } else {
              if (!is.na(inputs$giaTrend) && input$optionSecondary < 2 && info$db1 != "merged") {
                enable("giaType")
              } else {
                disable("giaType")
              }
            }
            if (!isTruthy(input$euler)) {
              enable("neuenu")
              updateRadioButtons(session, inputId = "eulerType", selected = 0)
              updateTextInput(inputId = "plate", value = "")
            } else {
              disable("neuenu")
              if ((((isTruthy(inputs$station_x) && isTruthy(inputs$station_y) && isTruthy(inputs$station_z)) || (isTruthy(inputs$station_lat) && isTruthy(inputs$station_lon))) ||
                   ((isTruthy(inputs$station_x2) && isTruthy(inputs$station_y2) && isTruthy(inputs$station_z2)) || (isTruthy(inputs$station_lat2) && isTruthy(inputs$station_lon2)))) &&
                  ((isTruthy(inputs$pole_x) && isTruthy(inputs$pole_y) && isTruthy(inputs$pole_z)) || (isTruthy(inputs$pole_lat) && isTruthy(inputs$pole_lon) && isTruthy(inputs$pole_rot))) &&
                  (input$optionSecondary < 2 && info$db1 != "merged")) {
                enable("eulerType")
              } else {
                disable("eulerType")
              }
            }
          }
          if (input$format == 4) {
            disable("plotAll")
            if (isTruthy(input$remove3D)) {
              updateCheckboxInput(session, inputId = "remove3D", value = F)
            }
            disable("remove3D")
          } else {
            enable("plotAll")
          }
          if (length(input$plot_brush) > 0 || length(input$res_brush) > 0 || length(input$vondrak_brush) > 0 ||
              length(input$plot41_brush) > 0 || length(input$plot42_brush) > 0 || length(input$plot43_brush) > 0 ||
              length(input$plot51_brush) > 0 || length(input$plot52_brush) > 0 || length(input$plot53_brush) > 0) {
            enable("remove")
          } else {
            disable("remove")
          }
          if (any(c(db1[[info$db1]]$status1, db1[[info$db1]]$status2, db1[[info$db1]]$status3) %in% F)) {
            enable("add_excluded")
            enable("delete_excluded")
          } else {
            disable("add_excluded")
            disable("delete_excluded")
          }
          enable("histogram")
          enable("histogramType")
          enable("filter")
          enable("series2filter")
          enable("spectrum")
          enable("spectrumType")
          enable("spectrumOriginal")
          if (!isTruthy(input$spectrum)) {
            updateCheckboxInput(session, inputId = "spectrumOriginal", value = F)
            updateCheckboxInput(session, inputId = "spectrumResiduals", value = F)
            updateCheckboxInput(session, inputId = "spectrumModel", value = F)
            updateCheckboxInput(session, inputId = "spectrumFilter", value = F)
            updateCheckboxInput(session, inputId = "spectrumFilterRes", value = F)
            updateTextInput(session, inputId = "ofac", value = "")
            updateTextInput(session, inputId = "long_period", value = "")
            updateTextInput(session, inputId = "short_period", value = "")
          }
          enable("wavelet")
          enable("waveletType")
          enable("series2")
          enable("server2")
          if (isTruthy(input$server2)) {
            enable("product2")
            if (isTruthy(input$product2)) {
              enable("station2")
            } else {
              file$secondary <- NULL
              info$last_optionSecondary <- 0
              updateRadioButtons(inputId = "optionSecondary", selected = 0)
              output$showStation2 <- renderUI({
                textInput(inputId = "station2", label = "Station", value = "")
              })
              disable("station2")
            }
          } else {
            disable("station2")
            disable("product2")
          }
          if (length(file$secondary) > 0) {
            enable("format2")
            if (input$format == 4) {
              updateRadioButtons(session, inputId = "format2", label = NULL, choices = list("NEU/ENU" = 1, "PBO" = 2, "NGL" = 3, "1D" = 4), selected = 4, inline = T)
              disable("server2")
              shinyjs::delay(100, disable("format2"))
              disable("ne")
            } else {
              enable("format2")
              enable("server2")
              enable("ne")
            }
            enable("scaleFactor")
            enable("step2")
            enable("optionSecondary")
            enable("separator2")
            enable("epoch2")
            enable("variable2")
            if (input$sigmas == T) {
              enable("errorBar2")
            } else {
              disable("errorBar2")
            }
            if (input$optionSecondary > 0 && input$format < 4) {
              enable("ne")
            } else {
              disable("ne")
            }
            if (input$optionSecondary == 0 && info$last_optionSecondary > 0) {
              # setting new axis limits
              if (input$tab == 4 || input$tab == 5) {
                info$minx <- min(db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status1)],
                                 db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status2)],
                                 db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status3)])
                info$maxx <- max(db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status1)],
                                 db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status2)],
                                 db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status3)])
              } else {
                req(db2[[info$db2]])
                info$minx <- suppressWarnings(min(db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]][[paste0("status", input$tab)]])]))
                info$maxx <- suppressWarnings(max(db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]][[paste0("status", input$tab)]])]))
              }
              ranges$x1 <- c(info$minx, info$maxx)
              ranges$y1 <- NULL
            }
            if (input$optionSecondary == 1) {
              if (isTruthy(input$fullSeries) ||
                  any(db2[[info$db2]][[paste0("x",input$tunits)]] < ranges$x0[1]) || any(db2[[info$db2]][[paste0("x",input$tunits)]] > ranges$x0[2]) ||
                  any(db2[[info$db2]][[paste0("y",input$tab)]] < ranges$y12[1]) || any(db2[[info$db2]][[paste0("y",input$tab)]] > ranges$y12[2]) ||
                  any(db2[[info$db2]]$y1 < ranges$y3D12[1]) || any(db2[[info$db2]]$y1 > ranges$y3D12[2]) ||
                  any(db2[[info$db2]]$y2 < ranges$y3D22[1]) || any(db2[[info$db2]]$y2 > ranges$y3D22[2]) ||
                  any(db2[[info$db2]]$y3 < ranges$y3D32[1]) || any(db2[[info$db2]]$y3 > ranges$y3D32[2])) {
                enable("fullSeries")
              } else {
                disable("fullSeries")
              }
              if (isTruthy(input$sameScale)) {
                disable("same_axis")
              } else {
                enable("same_axis")
              }
              if (isTruthy(input$same_axis)) {
                disable("sameScale")
              } else {
                enable("sameScale")
              }
              if (input$tab == 5) {
                disable("swap")
              } else {
                enable("swap") 
              }
            } else {
              updateCheckboxInput(session, inputId = "fullSeries", value = F)
              updateCheckboxInput(session, inputId = "sameScale", value = F)
              updateCheckboxInput(session, inputId = "same_axis", value = F)
              updateCheckboxInput(session, inputId = "ne", value = F)
              disable("fullSeries")
              disable("sameScale")
              disable("same_axis")
              disable("ne")
              disable("swap")
            }
          } else {
            disable("optionSecondary")
            disable("ne")
            disable("format2")
            disable("scaleFactor")
            disable("step2")
            disable("sameScale")
            disable("same_axis")
            disable("separator2")
            disable("fullSeries")
            disable("epoch2")
            disable("variable2")
            disable("errorBar2")
            disable("swap")
          }
          if (isTruthy(db1[[info$db1]]$res1) && isTruthy(db1[[info$db1]]$res2) && isTruthy(db1[[info$db1]]$res3) &&
              sum(abs(db1[[info$db1]]$res1), na.rm = T) > 0 && sum(abs(db1[[info$db1]]$res2), na.rm = T) > 0 && sum(abs(db1[[info$db1]]$res3), na.rm = T) > 0) {
            showTab(inputId = "tab", target = "5", session = getDefaultReactiveDomain())
          } else {
            hideTab(inputId = "tab", target = "5", session = getDefaultReactiveDomain())
          }
          enable("fitType")
          enable("model")
          if (input$breaking && length(trans$breakEpochs) > 0) {
            enable("trendType")
            enable("sinusoidType")
            enable("polyType")
          } else {
            disable("trendType")
            disable("sinusoidType")
            disable("polyType")
          }
          enable("GPSdrac")
          enable("GALdrac")
          enable("BDSdrac")
          enable("GLOdrac")
          if (input$fitType == 1 || input$fitType == 2) {
            if (length(trans$mod) > 0 && length(trans$res) > 0) {
              enable("spectrumModel")
              enable("spectrumResiduals")
              shinyjs::show(id = "res", anim = T, animType = "fade", time = 0.5, selector = NULL)
              shinyjs::show(id = "res1", anim = T, animType = "fade", time = 0.5, selector = NULL)
              shinyjs::show(id = "res2", anim = T, animType = "fade", time = 0.5, selector = NULL)
              shinyjs::show(id = "res3", anim = T, animType = "fade", time = 0.5, selector = NULL)
              if (length(trans$offsetEpochs) > 0) {
                enable("verif_offsets")
                if (isTRUE(input$verif_offsets)) {
                  if ( (nchar(inputs$verif_white) > 0 && !is.na(as.numeric(inputs$verif_white)) && as.numeric(inputs$verif_white) > 0) ||
                       (nchar(input$verif_pl) > 0 && nchar(input$verif_k) > 0 && !is.na(as.numeric(inputs$verif_pl)) && !is.na(as.numeric(inputs$verif_k)) && as.numeric(inputs$verif_pl) > 0 && as.numeric(inputs$verif_k) <= 0) ||
                       (nchar(input$verif_fl) > 0 && !is.na(as.numeric(inputs$verif_fl)) && as.numeric(inputs$verif_fl) > 0) ||
                       (nchar(input$verif_rw) > 0 && !is.na(as.numeric(inputs$verif_rw)) && as.numeric(inputs$verif_rw) > 0) ) {
                    enable("runVerif")
                  } else {
                    disable("runVerif")
                  }
                }
              } else {
                updateCheckboxInput(session, inputId = "verif_offsets", label = NULL, value = F)
                updateTextInput(session, inputId = "verif_white", value = "")
                updateTextInput(session, inputId = "verif_fl", value = "")
                updateTextInput(session, inputId = "verif_rw", value = "")
                updateTextInput(session, inputId = "verif_pl", value = "")
                updateTextInput(session, inputId = "verif_k", value = "")
                disable("verif_offsets")
                disable("runVerif")
              }
            } else {
              disable("correct_waveform")
              shinyjs::hide(id = "res", anim = T, animType = "fade", time = 0.5, selector = NULL)
              shinyjs::hide(id = "res1", anim = T, animType = "fade", time = 0.5, selector = NULL)
              shinyjs::hide(id = "res2", anim = T, animType = "fade", time = 0.5, selector = NULL)
              shinyjs::hide(id = "res3", anim = T, animType = "fade", time = 0.5, selector = NULL)
              updateCheckboxInput(session, inputId = "spectrumResiduals", value = F)
              updateCheckboxInput(session, inputId = "spectrumModel", value = F)
              info$run <- F
              disable("mle")
              disable("spectrumModel")
              disable("spectrumResiduals")
            }
          } else {
            if (isTruthy(input$model)) {
              updateCheckboxGroupInput(session, inputId = "model", label = "", choices = list("Linear","Polynomial","Sinusoidal","Offset","Exponential","Logarithmic"), selected = NULL, inline = T)
            }
            shinyjs::hide(id = "res", anim = T, animType = "fade", time = 0.5, selector = NULL)
            shinyjs::hide(id = "res1", anim = T, animType = "fade", time = 0.5, selector = NULL)
            shinyjs::hide(id = "res2", anim = T, animType = "fade", time = 0.5, selector = NULL)
            shinyjs::hide(id = "res3", anim = T, animType = "fade", time = 0.5, selector = NULL)
            updateCheckboxInput(session, inputId = "spectrumResiduals", value = F)
            updateCheckboxInput(session, inputId = "spectrumModel", value = F)
            info$run <- F
            disable("mle")
            disable("spectrumModel")
            disable("spectrumResiduals")
            disable("GPSdrac")
            disable("GALdrac")
            disable("BDSdrac")
            disable("GLOdrac")
          }
          if (length(trans$filter) > 0) {
            enable("spectrumFilter")
            enable("spectrumFilterRes")
          } else {
            updateCheckboxInput(session, inputId = "spectrumFilter", value = F)
            updateCheckboxInput(session, inputId = "spectrumFilterRes", value = F)
            disable("spectrumFilter")
            disable("spectrumFilterRes")
          }
          if (input$series2filter == 2 && input$fitType == 0) {
            updateRadioButtons(session, inputId = "series2filter", label = NULL, choices = list("Original" = 1, "Residual" = 2), selected = 1, inline = T)
          }
          if ((length(trans$mod) > 0 && length(trans$res) > 0) || (length(trans$filter) > 0)) {
            enable("mle")
            enable("waveform")
            if (isTruthy(input$waveform)) {
              if (isTruthy(input$correct_waveform) || length(trans$pattern) > 0 && length(trans$res) > 0) {
                enable("correct_waveform")
              } else {
                disable("correct_waveform")
              }
            } else {
              updateTextInput(session, inputId = "waveformPeriod", value = "")
              if (isTruthy(input$correct_waveform)) {
                updateCheckboxInput(session, inputId = "correct_waveform", value = F)
              }
            }
            if (isTruthy(input$mle)) {
              enable("white")
              enable("flicker")
              enable("randomw")
              enable("powerl")
              disable("runmle")
              disable("noise_unc")
              enable("est.mle")
              if (sum(input$white,input$flicker,input$randomw,input$powerl) > 1) {
                enable("wiener")
              } else {
                if (input$wiener) {
                  updateCheckboxInput(session, inputId = "wiener", value = F)
                }
                disable("wiener")
              }
              if (input$flicker || input$randomw || input$white || input$powerl) {
                enable("runmle")
              } else {
                disable("runmle")
              }
              if (input$powerl) {
                updateCheckboxInput(session, inputId = "flicker", label = NULL, value = F)
                disable("flicker")
                disable("randomw")
              } else {
                enable("flicker")
                enable("randomw")
              }
              if (input$flicker || input$randomw) {
                disable("powerl")
              } else {
                enable("powerl")
              }
              if ((input$white && !input$flicker && !input$randomw && !input$powerl) ||
                  (!input$white && input$flicker && !input$randomw && !input$powerl) ||
                  (!input$white && !input$flicker && input$randomw && !input$powerl)) {
                disable("noise_unc")
                updateCheckboxInput(session, inputId = "noise_unc", value = T)
              } else {
                enable("noise_unc")
              }
            } else {
              disable("white")
              disable("flicker")
              disable("randomw")
              disable("powerl")
              disable("runmle")
              disable("noise_unc")
              disable("est.mle")
              trans$mle <- F
              if (isTruthy(input$white)) {
                updateCheckboxInput(session, inputId = "white", label = NULL, value = F)
              }
              if (isTruthy(input$flicker)) {
                updateCheckboxInput(session, inputId = "flicker", label = NULL, value = F)
              }
              if (isTruthy(input$randomw)) {
                updateCheckboxInput(session, inputId = "randomw", label = NULL, value = F)
              }
              if (isTruthy(input$powerl)) {
                updateCheckboxInput(session, inputId = "powerl", label = NULL, value = F)
              }
              trans$noise <- NULL
            }
            enable("downloadAs")
            if (isTruthy(info$directory)) {
              enable("autoDownload")
            } else {
              disable("autoDownload")
            }
          } else {
            disable("waveform")
            if (isTruthy(input$waveform)) {
              updateCheckboxInput(session, inputId = "waveform", label = NULL, value = F)
            }
            disable("correct_waveform")
            disable("runmle")
            disable("downloadAs")
            disable("autoDownload")
          }
          if ((length(trans$mod) > 0 && length(trans$res) > 0) || (input$fitType == 0 && length(trans$filter) > 0)) {
            if (length(input$plot_brush) > 0 || length(input$res_brush) > 0 || length(input$vondrak_brush) > 0) {
              enable("remove")
            } else {
              disable("remove")
            }
            if (isTruthy(trans$xe)) {
              enable("delete_excluded")
            } else {
              disable("delete_excluded")
            }
            enable("thresholdRes")
            if (length(trans$filter) > 0) {
              disable("thresholdResN")
            } else {
              if (input$sigmas == T) {
                enable("thresholdResN")
              } else {
                disable("thresholdResN")
              }
            }
          } else {
            disable("thresholdRes")
            disable("thresholdResN")
          }
          if (!is.na(inputs$thresholdRes) || !is.na(inputs$thresholdResN)) {
            enable("removeAuto")
          } else {
            disable("removeAuto")
          }
          if (!isTruthy(input$wavelet) && input$waveletType > 0) {
            updateTextInput(session, "corto_wavelet", value = "")
            updateTextInput(session, "largo_wavelet", value = "")
            updateRadioButtons(session, inputId = "waveletType", label = NULL, list("None" = 0, "Original" = 1, "Model" = 2, "Model res." = 3, "Filter" = 4, "Filter res." = 5), selected = 0, inline = T, choiceNames = NULL, choiceValues = NULL)
            shinyjs::delay(100, disable("waveletType"))
          }
        } else {
          if (input$fitType > 0) {
            updateRadioButtons(session, inputId = "fitType", label = NULL, list("None" = 0, "LS" = 1, "KF" = 2), selected = 0, inline = T, choiceNames = NULL, choiceValues = NULL)
          }
          shinyjs::delay(100, disable("fitType"))
          if (input$optionSecondary > 0) {
            info$last_optionSecondary <- 0
            updateRadioButtons(session, inputId = "optionSecondary", selected = 0)
          }
          disable("traceLog")
          disable("traceSinfo")
          disable("traceSoln")
          disable("traceCustom")
          disable("filter")
          disable("spectrum")
          disable("wavelet")
          # updateRadioButtons(session, inputId = "waveletType", label = NULL, choices = list("None" = 0, "Original" = 1, "Model" = 2, "Model res." = 3, "Filter" = 4, "Filter res." = 5), selected = 0, inline = T, choiceNames = NULL,  choiceValues = NULL)
          shinyjs::delay(100, disable("waveletType"))
          updateTextInput(session, "corto_wavelet", value = "")
          updateTextInput(session, "largo_wavelet", value = "")
          disable("midas")
          disable("entropy")
          disable("spectrumModel")
          disable("spectrumResiduals")
          disable("spectrumFilter")
          disable("spectrumFilterRes")
          enable("plot")
          disable("cut")
          disable("strip")
          disable("plotAll")
          enable("series")
          disable("series2")
          disable("separator2")
          enable("format")
          disable("average")
          disable("server2")
          disable("swap")
        }
      } else {
        hideTab(inputId = "tab", target = "7", session = getDefaultReactiveDomain())
        # updateRadioButtons(session, inputId = "waveletType", label = NULL, choices = list("None" = 0, "Original" = 1, "Model" = 2, "Model res." = 3, "Filter" = 4, "Filter res." = 5), selected = 0, inline = T, choiceNames = NULL,  choiceValues = NULL)
        shinyjs::delay(100, disable("waveletType"))
        updateTextInput(session, "corto_wavelet", value = "")
        updateTextInput(session, "largo_wavelet", value = "")
        enable("series")
        enable("server1")
        disable("fitType")
        disable("autoDownload")
        disable("white")
        disable("reset")
        disable("delete_excluded")
        disable("loadSARI")
        disable("correct_waveform")
        disable("custom")
        disable("downloadAs")
        disable("printCustom")
        disable("printLog")
        disable("printSinfo")
        disable("printSoln")
        disable("spectrum")
        disable("spectrumFilter")
        disable("spectrumFilterRes")
        disable("spectrumModel")
        disable("spectrumOriginal")
        disable("spectrumResiduals")
        disable("spectrumType")
        disable("est.mle")
        disable("remove")
        disable("remove3D")
        disable("add_excluded")
        disable("cut")
        disable("strip")
        disable("permanent")
        disable("removeAuto")
        disable("filter")
        disable("flicker")
        disable("format")
        disable("format2")
        disable("tunits")
        disable("sunits")
        disable("ids")
        disable("histogram")
        disable("histogramType")
        disable("log")
        disable("average")
        disable("midas")
        disable("entropy")
        disable("mle")
        disable("model")
        disable("wavelet")
        disable("waveletType")
        disable("optionSecondary")
        disable("sameScale")
        disable("same_axis")
        disable("waveform")
        disable("plot")
        disable("powerl")
        disable("randomw")
        disable("runVerif")
        disable("runmle")
        disable("noise_unc")
        disable("series2")
        disable("separator")
        disable("separator2")
        disable("euler")
        disable("gia")
        disable("series2filter")
        disable("typeSecondary")
        disable("sigmas")
        disable("symbol")
        disable("sinfo")
        disable("soln")
        disable("header")
        disable("traceCustom")
        disable("traceLog")
        disable("traceSinfo")
        disable("traceSoln")
        disable("thresholdRes")
        disable("thresholdResN")
        disable("units")
        disable("verif_offsets")
        if (isTruthy(input$server1)) {
          enable("station1")
          enable("product1")
        } else {
          disable("station1")
          disable("product1")
        }
        disable("station2")
        disable("server2")
        disable("product2")
        disable("swap")
        disable("GPSdrac")
        disable("GALdrac")
        disable("BDSdrac")
        disable("GLOdrac")
      }
    }
  }, priority = 100)

  # Observe screen ####
  observeEvent(c(session$clientData$pixelratio, session$clientData$output_plot1_width, session$clientData$output_plot41_width, session$clientData$output_plot51_width), {
    info$pixelratio <- session$clientData$pixelratio
    if (input$tab < 4) {
      info$width <- session$clientData$output_plot1_width
    } else if (input$tab == 4) {
      info$width <- session$clientData$output_plot41_width
    } else if (input$tab == 5) {
      info$width <- session$clientData$output_plot51_width
    }
    # if (messages > 5) cat(file = stderr(), mySession, "Screen size change:", info$pixelratio, info$width, "\n")
  }, priority = 2000)

  # Observe URL ####
  observeEvent(c(session$clientData$url_search), {
    if (length(input$isMobile) > 0 && !isTruthy(input$isMobile)) {
      if (!isTruthy(url$station)) {
        query <- parseQueryString(session$clientData$url_search)
        if (length(query) > 0) {
          removeNotification("parsing_url1")
          removeNotification("parsing_url2")
          removeNotification("no_local")
          if (messages > 0) cat(file = stderr(), mySession, "Analyzing URL from", toupper(query[['server']]), "&", toupper(query[['product']]), "\n")
          info$local = Sys.getenv('SHINY_PORT') == "" || session$clientData$url_hostname == "127.0.0.1" # info$local needs to be set here too
          if (!is.null(query[['server']]) && !is.null(query[['station']]) && !is.null(query[['product']])) {
            removeNotification("bad_url")
            if (!isTruthy(info$local) && tolower(query[['server']]) == "local") {
              showNotification(paste0("Local server is not available on remote connections."), action = NULL, duration = 10, closeButton = T, id = "no_local", type = "warning", session = getDefaultReactiveDomain())
              url$station <- NULL
              url$file <- NULL
              req(info$stop)
            }
            url_info <- unlist(get_URL_info(query[['server']],query[['station']],query[['product']],1))
            if (isTruthy(url_info)) {
              url$station <- url_info[1]
              url$file <- url_info[2]
              url$server <- toupper(query[['server']])
              file$primary$name <- url_info[3]
              info$format <- url_info[4]
              url$logfile <- url_info[5]
              info$product1 <- toupper(query[['product']])
              if (tolower(query[['server']]) == "local") {
                if (!isTruthy(file.exists(url$file))) {
                  showNotification(paste0("Local file ",url$file," not found."), action = NULL, duration = 10, closeButton = T, id = "bad_url", type = "error", session = getDefaultReactiveDomain())
                  url$station <- NULL
                  url$file <- NULL
                  req(info$stop)
                }
                showNotification(paste0("Uploading series file ",file$primary$name," from ",toupper(query[['server']]),"."), action = NULL, duration = 30, closeButton = T, id = "parsing_url1", type = "warning", session = getDefaultReactiveDomain())
                down <- 0
                file$primary$datapath <- url$file
              } else {
                showNotification(paste0("Downloading series file ",file$primary$name," from ",toupper(query[['server']]),"."), action = NULL, duration = 30, closeButton = T, id = "parsing_url1", type = "warning", session = getDefaultReactiveDomain())
                file$primary$datapath <- paste0("www/tempFiles/",file$primary$name)
                down <- download(url$server, url$file, file$primary$datapath)
                if (file.exists(file$primary$datapath)) {
                  downloaded <- try(fromJSON(file$primary$datapath), silent = T)
                  if (!isTruthy(downloaded) || inherits(downloaded,"try-error")) {
                    downloaded <- readLines(file$primary$datapath, n = 2, warn = F)
                    if (grepl("DOCTYPE", downloaded[1], ignore.case = F) ||
                        length(downloaded) < 2) {
                      down <- 1
                    }
                  }
                }
              }
              if (isTruthy(down) && down == 0) {
                # if (messages > 0) cat(file = stderr(), mySession, "Primary series downloaded in", file$primary$datapath, "\n")
                # update format for primary series
                shinyjs::delay(100, updateRadioButtons(session, inputId = "format", selected = info$format))
                # download associated logfile
                if (isTruthy(url$logfile)) {
                  showNotification(paste0("Downloading logfile for ",toupper(url$station),"."), action = NULL, duration = 5, closeButton = T, id = "parsing_log1", type = "warning", session = getDefaultReactiveDomain())
                  file$primary$logfile <- paste0("www/tempFiles/",basename(url$logfile))
                  down <- download("", url$logfile, file$primary$logfile)
                  if (down == 0) {
                    file$sitelog <- NULL
                    session$sendCustomMessage("log", basename(url$logfile))
                    shinyjs::delay(100, updateCheckboxInput(inputId = "traceLog", value = T))
                  } else {
                    showNotification(HTML(paste0("Logfile not found in ", url$server,".<br>No file was downloaded.")), action = NULL, duration = 10, closeButton = T, id = "bad_url", type = "error", session = getDefaultReactiveDomain())
                    file$primary$logfile <- NULL
                    url$logfile <- NULL
                  }
                }
                # processing secondary series
                if (!is.null(query[['server2']]) && !is.null(query[['station2']]) && !is.null(query[['product2']])) {
                  if (messages > 0) cat(file = stderr(), mySession, "Analyzing secondary URL from", toupper(query[['server2']]), "&", toupper(query[['product2']]), "\n")
                  url_info <- unlist(get_URL_info(query[['server2']],query[['station2']],query[['product2']],2))
                  if (isTruthy(url_info)) {
                    url$station2 <- url_info[1]
                    url$file2 <- url_info[2]
                    url$server2 <- toupper(query[['server2']])
                    file$secondary$name <- url_info[3]
                    info$format2 <- url_info[4]
                    url$logfile2 <- url_info[5]
                    info$product2 <- toupper(query[['product2']])
                    shinyjs::delay(100, updateRadioButtons(session, inputId = "format2", label = NULL, selected = info$format2))
                    if (tolower(query[['server2']]) == "local") {
                      if (!isTruthy(file.exists(url$file2))) {
                        showNotification(paste0("Local file ",url$file2," not found."), action = NULL, duration = 10, closeButton = T, id = "bad_url", type = "error", session = getDefaultReactiveDomain())
                        url$station2 <- NULL
                        url$file2 <- NULL
                        req(info$stop)
                      }
                      showNotification(paste0("Uploading series file ",file$secondary$name," from ",toupper(query[['server']]),"."), action = NULL, duration = 30, closeButton = T, id = "parsing_url2", type = "warning", session = getDefaultReactiveDomain())
                      down <- 0
                      file$secondary$datapath <- url$file2
                    } else {
                      showNotification(paste0("Downloading secondary series file ",file$secondary$name," from ",toupper(query[['server2']]),"."), action = NULL, duration = 30, closeButton = T, id = "parsing_url2", type = "warning", session = getDefaultReactiveDomain())
                      file$secondary$datapath <- tempfile()
                      down <- download(url$server2, url$file2, file$secondary$datapath)
                      if (file.exists(file$secondary$datapath)) {
                        downloaded <- try(fromJSON(file$secondary$datapath), silent = T)
                        if (!isTruthy(downloaded) || inherits(downloaded,"try-error")) {
                          downloaded <- readLines(file$secondary$datapath, n = 2, warn = F)
                          if (grepl("DOCTYPE", downloaded[1], ignore.case = F) ||
                              length(downloaded) < 2) {
                            down <- 1
                          }
                        }
                      }
                    }
                    if (isTruthy(down) && down == 0) {
                      # if (messages > 0) cat(file = stderr(), mySession, "Secondary series downloaded in", file$secondary$datapath, "\n")
                      info$menu <- unique(c(info$menu, 3))
                      updateCollapse(session, id = "menu", open = info$menu)
                      if (url$server2 == "LOCAL") {
                        filename2 <- basename(url$file2)
                      } else {
                        filename2 <- file$secondary$name
                      }
                      session$sendCustomMessage("filename2", filename2)
                      if (isTruthy(url$logfile2) && !isTruthy(url$logfile)) {
                        showNotification(paste0("Downloading logfile for ",toupper(url$station2),"."), action = NULL, duration = 5, closeButton = T, id = "parsing_log2", type = "warning", session = getDefaultReactiveDomain())
                        file$secondary$logfile <- paste0("www/tempFiles/",basename(url$logfile2))
                        down <- download("", url$logfile2, file$secondary$logfile)
                        if (down == 0) {
                          file$sitelog <- NULL
                          session$sendCustomMessage("log", basename(url$logfile2))
                          shinyjs::delay(100, updateCheckboxInput(inputId = "traceLog", value = T))
                        } else {
                          showNotification(HTML(paste0("Logfile not found in ", url$server2,".<br>No file was downloaded.")), action = NULL, duration = 10, closeButton = T, id = "bad_url", type = "error", session = getDefaultReactiveDomain())
                          file$secondary$logfile <- NULL
                        }
                      }
                    } else {
                      removeNotification("parsing_url2")
                      showNotification(HTML(paste0("File ",file$secondary$name," not found in ",toupper(query[['server2']]),".<br>No file was downloaded.")), action = NULL, duration = 10, closeButton = T, id = "bad_url", type = "error", session = getDefaultReactiveDomain())
                    }
                  }
                }
                shinyjs::delay(1500, {
                  if (messages > 4) cat(file = stderr(), mySession, "From: observe url\n")
                  db1$original <- db1$resampled <- db1$merged <- NULL
                  digest(1)
                  if (isTruthy(url$station2) && isTruthy(url$file2) && isTruthy(url$server2)) {
                    db2$original <- db2$resampled <- NULL
                    digest(2)
                  }
                  if (url$server == "LOCAL") {
                    filename <- basename(url$file)
                  } else {
                    filename <- file$primary$name
                  }
                  session$sendCustomMessage("filename", filename)
                })
              } else {
                removeNotification("parsing_url1")
                showNotification(HTML(paste0("File ",file$primary$name," is empty or is not found in ",toupper(query[['server']]),".<br>No file was downloaded.")), action = NULL, duration = 10, closeButton = T, id = "bad_url", type = "error", session = getDefaultReactiveDomain())
                url$station <- NULL
                url$file <- NULL
              }
            }
          } else {
            showNotification(HTML(paste0("At least one missing argument in the URL (station, server and product).<br>No file was downloaded.")), action = NULL, duration = 10, closeButton = T, id = "bad_url", type = "error", session = getDefaultReactiveDomain())
            url$station <- NULL
            url$file <- NULL
          }
        } else {
          url$station <- NULL
          url$file <- NULL
        }
      }
    }
  })

  # Observe remote series ####
  observeEvent(input$server1, {
    if (input$server1 == "RENAG") {
      updateSelectizeInput(session, inputId = "product1", choices = list("UGA"), selected = "UGA")
    } else if (input$server1 == "FORMATERRE") {
      updateSelectizeInput(session, inputId = "product1", choices = list("SPOTGINS", "UGA", "IGS20", "ENS"), selected = "")
    } else if (input$server1 == "IGS") {
      updateSelectizeInput(session, inputId = "product1", choices = list("IGS20"), selected = "IGS20")
    } else if (input$server1 == "EUREF") {
      updateSelectizeInput(session, inputId = "product1", choices = list("IGB14"), selected = "IGB14")
    } else if (input$server1 == "EPOS") {
      updateSelectizeInput(session, inputId = "product1", choices = list("INGV", "ROB-EUREF", "SGO-EPND", "UGA-CNRS"), selected = "")
    } else if (input$server1 == "NGL") {
      updateSelectizeInput(session, inputId = "product1", choices = list("IGS20", "IGS14", "RAPID"), selected = "")
    } else if (input$server1 == "JPL") {
      updateSelectizeInput(session, inputId = "product1", choices = list("REPRO2018A"), selected = "REPRO2018A")
    } else if (input$server1 == "EOSTLS") {
      updateSelectizeInput(session, inputId = "product1", choices = list("ATMIB", "ATMIB(d)", "ATMMO(o)", "ECCO(o)", "ECCO2", "ERA5IB", "ERA5IB(d)", "ERA5TUGO", "ERA5TUGO(d)", "ERA5HYD", "ERA5HYD(d)", "ERA5LAND", "GRACE", "GLDAS2", "GLDAS2(d)", "GLORYS(o)", "MERRA2ATM", "MERRA2ATM(d)", "MERRA2HYD", "MERRA2HYD(d)"), selected = "")
    } else if (input$server1 == "SONEL") {
      updateSelectizeInput(session, inputId = "product1", choices = list("ULR7A"), selected = "ULR7A")
    } else if (input$server1 == "SIRGAS") {
      updateSelectizeInput(session, inputId = "product1", choices = list("IGB14"), selected = "IGB14")
    } else if (input$server1 == "EARTHSCOPE") {
      updateSelectizeInput(session, inputId = "product1", choices = list("CWU", "PBO", "NMT"), selected = "")
    } else if (input$server1 == "PSMSL") {
      updateSelectizeInput(session, inputId = "product1", choices = list("RLR"), selected = "RLR")
    } else if (input$server1 == "DORIS") {
      updateSelectizeInput(session, inputId = "product1", choices = list("ESA", "GOP", "GRG", "GSC", "IDS", "IGN"), selected = "")
    }
    output$showStation1 <- renderUI({
      textInput(inputId = "station1", label = "Station", value = "")
    })
  })
  observeEvent(input$server2, {
    req(db1[[info$db1]])
    info$last_optionSecondary <- 0
    updateRadioButtons(inputId = "optionSecondary", selected = 0)
    if (input$server2 == "RENAG") {
      updateSelectizeInput(session, inputId = "product2", choices = list("UGA"), selected = "UGA")
    } else if (input$server2 == "FORMATERRE") {
      updateSelectizeInput(session, inputId = "product2", choices = list("SPOTGINS", "UGA", "IGS20", "ENS"), selected = "")
    } else if (input$server2 == "IGS") {
      updateSelectizeInput(session, inputId = "product2", choices = list("IGS20"), selected = "IGS20")
    } else if (input$server2 == "EUREF") {
      updateSelectizeInput(session, inputId = "product2", choices = list("IGB14"), selected = "IGB14")
    } else if (input$server2 == "EPOS") {
      updateSelectizeInput(session, inputId = "product2", choices = list("INGV", "ROB-EUREF", "SGO-EPND", "UGA-CNRS"), selected = "")
    } else if (input$server2 == "NGL") {
      updateSelectizeInput(session, inputId = "product2", choices = list("IGS20", "IGS14", "RAPID"), selected = "")
    } else if (input$server2 == "JPL") {
      updateSelectizeInput(session, inputId = "product2", choices = list("REPRO2018A"), selected = "REPRO2018A")
    } else if (input$server2 == "EOSTLS") {
      updateSelectizeInput(session, inputId = "product2", choices = list("ATMIB", "ATMIB(d)", "ATMMO(o)", "ECCO(o)", "ECCO2", "ERA5IB", "ERA5IB(d)", "ERA5TUGO", "ERA5TUGO(d)", "ERA5HYD", "ERA5HYD(d)", "ERA5LAND", "GRACE", "GLDAS2", "GLDAS2(d)", "GLORYS(o)", "MERRA2ATM", "MERRA2ATM(d)", "MERRA2HYD", "MERRA2HYD(d)"), selected = "", options = list(maxItems = 12))
    } else if (input$server2 == "SONEL") {
      updateSelectizeInput(session, inputId = "product2", choices = list("ULR7A"), selected = "ULR7A")
    } else if (input$server2 == "SIRGAS") {
      updateSelectizeInput(session, inputId = "product2", choices = list("IGB14"), selected = "IGB14")
    } else if (input$server2 == "EARTHSCOPE") {
      updateSelectizeInput(session, inputId = "product2", choices = list("CWU", "PBO", "NMT"), selected = "")
    } else if (input$server2 == "PSMSL") {
      updateSelectizeInput(session, inputId = "product2", choices = list("RLR"), selected = "RLR")
    } else if (input$server2 == "DORIS") {
      updateSelectizeInput(session, inputId = "product2", choices = list("ESA", "GOP", "GRG", "GSC", "IDS", "IGN"), selected = "")
    }
    output$showStation2 <- renderUI({
      textInput(inputId = "station2", label = "Station", value = "")
    })
    if (input$server2 != "") {
      file$secondary <- NULL
    }
  })
  observeEvent(c(input$product1), {
    req(input$server1,input$product1)
    removeNotification("bad_remote")
    removeNotification("bad_url")
    removeNotification("parsing_url1")
    removeNotification("no_answer")
    info$product1 <- input$product1
    get_URL_info(input$server1,NULL,input$product1,1)
  })
  ## station1 ####
  observeEvent(c(inputs$station1), {
    if (isTruthy(inputs$station1) && isTruthy(input$server1) && isTruthy(input$product1)) {
      removeNotification("bad_remote")
      removeNotification("bad_url")
      removeNotification("parsing_url1")
      url_info <- unlist(get_URL_info(input$server1,inputs$station1,input$product1,1))
      if (isTruthy(url_info)) {
        url$station <- url_info[1]
        url$file <- url_info[2]
        url$server <- input$server1
        file$primary$name <- url_info[3]
        info$format <- url_info[4]
        url$logfile <- url_info[5]
        showNotification(paste0("Downloading series file ",file$primary$name," from ",toupper(input$server1),"."), action = NULL, duration = 30, closeButton = T, id = "parsing_url1", type = "warning", session = getDefaultReactiveDomain())
        if (messages > 0) cat(file = stderr(), mySession, "Downloading series from", toupper(input$server1), "&", toupper(input$product1), "\n")
        file$primary$datapath <- paste0("www/tempFiles/",file$primary$name)
        down <- download(url$server, url$file, file$primary$datapath)
        if (file.exists(file$primary$datapath)) {
          downloaded <- try(fromJSON(file$primary$datapath), silent = T)
          if (!isTruthy(downloaded) || inherits(downloaded,"try-error")) {
            downloaded <- readLines(file$primary$datapath, n = 2, warn = F)
            if (grepl("DOCTYPE", downloaded[1], ignore.case = F) ||
                length(downloaded) < 2) {
              down <- 1
            }
          }
        }
        if (isTruthy(down) && down == 0) {
          shinyjs::delay(1500, {
            # if (messages > 0) cat(file = stderr(), mySession, "Primary series downloaded in", file$primary$datapath, "\n")
            if (messages > 4) cat(file = stderr(), mySession, "From: observe remote series (primary)\n")
            updateRadioButtons(session, inputId = "format", label = NULL, selected = info$format)
            shinyjs::delay(1500, {
              db1$original <- db1$resampled <- db1$merged <- NULL
              digest(1)
              filename <- file$primary$name
              session$sendCustomMessage("filename", filename)
              if (isTruthy(url$logfile)) {
                showNotification(paste0("Downloading logfile for ",toupper(input$station1),"."), action = NULL, duration = 5, closeButton = T, id = "parsing_log1", type = "warning", session = getDefaultReactiveDomain())
                file$primary$logfile <- paste0("www/tempFiles/",basename(url$logfile))
                down <- download("", url$logfile, file$primary$logfile)
                if (down == 0) {
                  file$sitelog <- NULL
                  session$sendCustomMessage("log", basename(url$logfile))
                  updateCheckboxInput(inputId = "traceLog", value = T)
                } else {
                  showNotification(HTML(paste0("Logfile not found in ",input$server,".<br>No file was downloaded.")), action = NULL, duration = 10, closeButton = T, id = "bad_url", type = "error", session = getDefaultReactiveDomain())
                  file$primary$logfile <- NULL
                  url$logfile <- NULL
                }
              }
            })
          })
        } else {
          removeNotification("parsing_url1")
          showNotification(HTML(paste0("File ",file$primary$name," is empty or is not found in ",toupper(input$server1),".<br>No file was downloaded.")), action = NULL, duration = 10, closeButton = T, id = "bad_url", type = "error", session = getDefaultReactiveDomain())
          updateSelectInput(session, inputId = "station1", selected = "")
          file$primary <- NULL
        }
      } else {
        showNotification(paste0("Product ", input$product1, "for station ", inputs$station1," not found in ",toupper(input$server1)," server"), action = NULL, duration = 10, closeButton = T, id = "bad_remote", type = "error", session = getDefaultReactiveDomain())
        updateSelectInput(session, inputId = "station1", selected = "")
      }
    }
  })
  observeEvent(c(input$product2), {
    req(input$server2)
    removeNotification("bad_remote")
    removeNotification("bad_url")
    removeNotification("no_answer")
    file$secondary <- NULL
    info$last_optionSecondary <- 0
    updateRadioButtons(inputId = "optionSecondary", selected = 0)
    req(input$product2)
    get_URL_info(input$server2,NULL,input$product2,2)
  })
  ## station2 ####
  observeEvent(c(inputs$station2), {
    req(db1[[info$db1]])
    if (input$station2 != "") {
      file$secondary <- NULL
    }
    if (isTruthy(inputs$station2) && isTruthy(input$server2) && isTruthy(input$product2)) {
      removeNotification("bad_remote")
      removeNotification("bad_url")
      url_info <- get_URL_info(input$server2,inputs$station2,input$product2,2)
      if (isTruthy(url_info)) {
        url$station2 <- url_info[[1]]
        url$file2 <- url_info[[2]]
        url$server2 <- input$server2
        file$secondary$name <- url_info[[3]]
        info$format2 <- url_info[[4]]
        url$logfile2 <- url_info[[5]]
        file$secondary$datapath <- c()
        secondary_files <- 0
        for (f in 1:length(url$file2)) {
          if (length(url$file2) > 1) {
            file$secondary$datapath <- c(file$secondary$datapath, tempfile())
          } else {
            file$secondary$datapath <- paste0("www/tempFiles/",file$secondary$name)
          }
          showNotification(paste0("Downloading secondary series file ",file$secondary$name[f]," from ",toupper(input$server2),"."), action = NULL, duration = NULL, closeButton = T, id = paste0("parsing_url2_",f), type = "warning", session = getDefaultReactiveDomain())
          if (messages > 0) cat(file = stderr(), mySession, "Downloading secondary series from", toupper(input$server2), "&", toupper(input$product2), "\n")
          down <- download(url$server2, url$file2[f], file$secondary$datapath[f])
          if (file.exists(file$secondary$datapath[f])) {
            downloaded <- try(fromJSON(file$secondary$datapath[f]), silent = T)
            if (!isTruthy(downloaded) || inherits(downloaded,"try-error")) {
              downloaded <- readLines(file$secondary$datapath[f], n = 2, warn = F)
              if (grepl("DOCTYPE", downloaded[1], ignore.case = F) ||
                  length(downloaded) < 2) {
                down <- 1
              }
            }
          }
          if (isTruthy(down) && down == 0) {
            secondary_files <- secondary_files + 1
            # if (messages > 0) cat(file = stderr(), mySession, "Secondary series downloaded in", file$secondary$datapath[f], "\n")
          } else {
            file$secondary$datapath <- file$secondary$datapath[-length(file$secondary$datapath)]
            removeNotification(paste0("parsing_url2_",f))
            showNotification(HTML(paste0("File ",file$secondary$name[f]," not found in ",input$server2,".<br>No file was downloaded.")), action = NULL, duration = 10, closeButton = T, id = "bad_url", type = "error", session = getDefaultReactiveDomain())
          }
        }
        if (secondary_files > 0) {
          if (length(file$secondary$name) > 1) {
            filename2 <- paste0(paste(input$station2, paste(input$product2, collapse = "_"), sep = "_"), ".enu")
            file$secondary$datapath <- as.matrix(file$secondary$datapath)
          } else {
            filename2 <- file$secondary$name
            if (isTruthy(url$logfile2) && !isTruthy(url$logfile)) {
              showNotification(paste0("Downloading logfile for ",toupper(input$station2),"."), action = NULL, duration = 5, closeButton = T, id = "parsing_log2", type = "warning", session = getDefaultReactiveDomain())
              file$secondary$logfile <- paste0("www/tempFiles/",basename(url$logfile2))
              down <- download("", url$logfile2, file$secondary$logfile)
              if (down == 0) {
                file$sitelog <- NULL
                session$sendCustomMessage("log", basename(url$logfile2))
                updateCheckboxInput(inputId = "traceLog", value = T)
              } else {
                showNotification(HTML(paste0("Logfile not found in ",input$server2,".<br>No file was downloaded.")), action = NULL, duration = 10, closeButton = T, id = "bad_url", type = "error", session = getDefaultReactiveDomain())
                file$secondary$logfile <- NULL
              }
            }
          }
          file$secondary$newname <- filename2
          file$secondary$newpath <- paste0("www/tempFiles/",file$secondary$newname)
          session$sendCustomMessage("filename2", filename2)
          updateRadioButtons(session, inputId = "format2", selected = info$format2)
          shinyjs::delay(1500, {
            if (messages > 4) cat(file = stderr(), mySession, "From: observe remote series (secondary)\n")
            db2$original <- db2$resampled <- NULL
            digest(2)
          })
        } else {
          updateSelectInput(session, inputId = "station2", selected = "")
          file$secondary <- NULL
        }
      } else {
        showNotification(paste("Product", input$product2, "for station", inputs$station2, "not found in", input$server2, "server."), action = NULL, duration = 10, closeButton = T, id = "bad_remote", type = "error", session = getDefaultReactiveDomain())
        updateSelectInput(session, inputId = "station2", selected = "")
      }
    } else {
      url$station2 <- url$file2 <- url$server2 <- file$secondary$name <- info$format2 <- file$secondary$datapath <- NULL
      if (info$db1 == "merged") {
        if (isTruthy(input$step) && isTruthy(db1$resampled)) {
          info$db1 <- "resampled"
        } else {
          info$db1 <- "original"
        }
      }
      info$last_optionSecondary <- 0
      updateRadioButtons(session, inputId = "optionSecondary", label = NULL, selected = 0)
    }
  })

  # Observe Euler ####
  observeEvent(c(input$euler), {
    req(db1[[info$db1]])
    if (input$euler) {
      runjs("
        let element = document.getElementById('euler');
        element.scrollIntoView({
          behavior: 'smooth'
        });
        ")
    }
  })
  observeEvent(c(input$plateModel), {
    req(db1[[info$db1]], input$euler)
    if (messages > 0) cat(file = stderr(), mySession, "Plate model:", input$plateModel, "\n")
    if (input$plateModel == "ITRF2020") {
      info$plateFile <- "www/ITRF2020-PMM.dat"
      updateSelectizeInput(session, inputId = "plate", choices = read.table(file = info$plateFile, header = F, skip = 5)$V5, selected = "")
    } else if (input$plateModel == "NNR-MORVEL56") {
      info$plateFile <- "www/NNR-MORVEL56.txt"
      updateSelectizeInput(session, inputId = "plate", choices = read.table(file = info$plateFile, header = F, skip = 5, sep = "\t", comment.char = "#")$V2, selected = "")
    } else if (input$plateModel == "NNR-GSRM") {
      info$plateFile <- "www/NNR-GSRM_v2.1.txt"
      updateSelectizeInput(session, inputId = "plate", choices = read.table(file = info$plateFile, header = F, skip = 2)$V1, selected = "")
    } else {
      info$plateFile <- NULL
      updateSelectizeInput(session, inputId = "plate", choices = list(), selected = "")
    }
  })
  observeEvent(c(input$plate), {
    req(db1[[info$db1]], input$euler, info$plateFile)
    if (messages > 0) cat(file = stderr(), mySession, "Plate:", input$plate, "\n")
    removeNotification("bad_plate")
    if (isTruthy(input$plate)) {
      record <- grep(input$plate, grep("^#", readLines(con = info$plateFile, n = -1L, ok = T, warn = F, skipNul = T), perl = T, value = T, invert = T), fixed = F, ignore.case = T, perl = F, value = T)
      if (length(record) == 1) {
        elements <- NULL
        if ((((isTruthy(inputs$station_x) && isTruthy(inputs$station_y) && isTruthy(inputs$station_z)) || (isTruthy(inputs$station_lat) && isTruthy(inputs$station_lon))) ||
             ((isTruthy(inputs$station_x2) && isTruthy(inputs$station_y2) && isTruthy(inputs$station_z2)) || (isTruthy(inputs$station_lat2) && isTruthy(inputs$station_lon2))))
        ) {
          updateRadioButtons(session, inputId = "eulerType", selected = 1)
        }
        if (input$plateModel == "ITRF2020") {
          elements <- unlist(strsplit(record, "\\s+", fixed = F, perl = T, useBytes = F))[c(3,4,5,2)]
          updateRadioButtons(session, inputId = "pole_coordinates", selected = 1)
          inputs$pole_x <- inputs$pole_y <- inputs$pole_z <- inputs$pole_lat <- inputs$pole_lon <- inputs$pole_rot <- NULL
          updateTextInput(session, inputId = "pole_x", value = elements[1])
          updateTextInput(session, inputId = "pole_y", value = elements[2])
          updateTextInput(session, inputId = "pole_z", value = elements[3])
          updateTextInput(session, inputId = "pole_lat", value = "")
          updateTextInput(session, inputId = "pole_lon", value = "")
          updateTextInput(session, inputId = "pole_rot", value = "")
        } else if (input$plateModel == "NNR-MORVEL56") {
          elements <- unlist(strsplit(record, "\\t+", fixed = F, perl = T, useBytes = F))[c(4,5,6,2)]
          updateRadioButtons(session, inputId = "pole_coordinates", selected = 2)
          inputs$pole_x <- inputs$pole_y <- inputs$pole_z <- inputs$pole_lat <- inputs$pole_lon <- inputs$pole_rot <- NULL
          updateTextInput(session, inputId = "pole_lat", value = elements[1])
          updateTextInput(session, inputId = "pole_lon", value = elements[2])
          updateTextInput(session, inputId = "pole_rot", value = elements[3])
          updateTextInput(session, inputId = "pole_x", value = "")
          updateTextInput(session, inputId = "pole_y", value = "")
          updateTextInput(session, inputId = "pole_z", value = "")
        } else if (input$plateModel == "NNR-GSRM") {
          elements <- unlist(strsplit(record, "\\s+", fixed = F, perl = T, useBytes = F))[c(6,7,8,1)]
          updateRadioButtons(session, inputId = "pole_coordinates", selected = 2)
          inputs$pole_x <- inputs$pole_y <- inputs$pole_z <- inputs$pole_lat <- inputs$pole_lon <- inputs$pole_rot <- NULL
          updateTextInput(session, inputId = "pole_lat", value = elements[1])
          updateTextInput(session, inputId = "pole_lon", value = elements[2])
          updateTextInput(session, inputId = "pole_rot", value = elements[3])
          updateTextInput(session, inputId = "pole_x", value = "")
          updateTextInput(session, inputId = "pole_y", value = "")
          updateTextInput(session, inputId = "pole_z", value = "")
        }
      } else {
        trans$plate <- NULL
        trans$plate2 <- NULL
        showNotification(paste("Plate", input$plate, "not found in the", plateModel, "plate model file"), action = NULL, duration = 10, closeButton = T, id = "bad_plate", type = "error", session = getDefaultReactiveDomain())
      }
    }
  })
  observeEvent(c(inputs$station_lat, inputs$station_lon), {
    coordinates <- NULL
    if (isTruthy(inputs$station_lat) && isTruthy(inputs$station_lon)) {
      coordinates <- latlon2xyz(inputs$station_lat*pi/180,inputs$station_lon*pi/180,1)
      if (isTruthy(coordinates) && length(coordinates) == 3) {
        if (!isTruthy(inputs$station_x) || !isTruthy(inputs$station_y) || !isTruthy(inputs$station_z)) {
          updateTextInput(session, inputId = "station_x", value = coordinates[1])
          updateTextInput(session, inputId = "station_y", value = coordinates[2])
          updateTextInput(session, inputId = "station_z", value = coordinates[3])
        }

      }
    }
  }, priority = 5)
  observeEvent(c(inputs$station_x, inputs$station_y, inputs$station_z), {
    if (isTruthy(inputs$station_x) && isTruthy(inputs$station_y) && isTruthy(inputs$station_z) && (!isTruthy(inputs$station_lat) || !isTruthy(inputs$station_lon))) {
      stationGeo <- do.call(xyz2llh,as.list(as.numeric(c(inputs$station_x,inputs$station_y,inputs$station_z))))
      coordinates <- c(sprintf("%.6f", stationGeo[1] * 180/pi), sprintf("%.6f", stationGeo[2] * 180/pi))
      if (length(coordinates) == 2 && (!isTruthy(inputs$station_lat) || !isTruthy(inputs$station_lon))) {
        updateTextInput(session, inputId = "station_lat", value = coordinates[1])
        updateTextInput(session, inputId = "station_lon", value = coordinates[2])
      }
    }
  }, priority = 5)
  observeEvent(c(inputs$station_lat2, inputs$station_lon2), {
    coordinates <- NULL
    if (isTruthy(inputs$station_lat2) && isTruthy(inputs$station_lon2) && !isTruthy(inputs$station_x2) && !isTruthy(inputs$station_y2) && !isTruthy(inputs$station_z2)) {
      coordinates <- latlon2xyz(inputs$station_lat2*pi/180,inputs$station_lon2*pi/180,1)
      if (length(coordinates) == 3) {
        updateTextInput(session, inputId = "station_x2", value = coordinates[1])
        updateTextInput(session, inputId = "station_y2", value = coordinates[2])
        updateTextInput(session, inputId = "station_z2", value = coordinates[3])
      }
    }
  }, priority = 5)
  observeEvent(c(inputs$station_x2, inputs$station_y2, inputs$station_z2), {
    if (isTruthy(inputs$station_x2) && isTruthy(inputs$station_y2) && isTruthy(inputs$station_z2) && !isTruthy(inputs$station_lat2) && !isTruthy(inputs$station_lon2)) {
      stationGeo <- do.call(xyz2llh,as.list(as.numeric(c(inputs$station_x2,inputs$station_y2,inputs$station_z2))))
      coordinates <- c(sprintf("%.6f", stationGeo[1] * 180/pi), sprintf("%.6f", stationGeo[2] * 180/pi))
      if (length(coordinates) == 2) {
        updateTextInput(session, inputId = "station_lat2", value = coordinates[1])
        updateTextInput(session, inputId = "station_lon2", value = coordinates[2])
      }
    }
  }, priority = 5)
  observeEvent(c(inputs$station_lat, inputs$station_lon, inputs$station_lat2, inputs$station_lon2, input$showmap), {
    req(db1[[info$db1]])
    if (isTruthy(inputs$station_lat) && isTruthy(inputs$station_lon) && input$showmap) {
      # Mapping the station positions
      # Plate polygons and boundaries come from Hugo Ahlenius, Nordpil and Peter Bird (https://github.com/fraxen/tectonicplates)
      if (exists("leaflet", mode = "function") && file.exists("www/PB2002_boundaries.json")) {
        if (messages > 0) cat(file = stderr(), mySession, "Location map", "\n")
        lat <- inputs$station_lat
        lon <- inputs$station_lon
        lon <- ifelse(lon > 180, lon - 360, lon)
        lon <- ifelse(lon < -180, lon + 360, lon)
        if (exists("geojson_read", mode = "function") && file.exists("www/PB2002_plates.json")) {
          plates <- geojsonio::geojson_read("www/PB2002_plates.json", what = "sp")
          map <- leaflet(plates, options = leafletOptions(dragging = F, zoomControl = F, doubleClickZoom = F, scrollWheelZoom = "center", minZoom = 1)) %>%
            addTiles() %>%
            addPolygons(
              fillColor = "white",
              weight = 1,
              opacity = 1,
              color = "black",
              dashArray = "1",
              fillOpacity = 0,
              highlightOptions = highlightOptions(
                weight = 3,
                color = "#DF536B",
                dashArray = "",
                fillOpacity = 0,
                bringToFront = TRUE),
              label = plates$PlateName,
              labelOptions = labelOptions(
                style = list("font-weight" = "normal", padding = "3px 8px"),
                textsize = "15px",
                direction = "auto")
            ) %>%
            setView(lng = lon, lat = lat, zoom = 10) %>%
            addMarkers(icon = list(iconUrl = "www/GNSS_marker.png", iconSize = c(50,50)), lng = lon, lat = lat, label = file$id1)
        } else {
          boundaries <- readLines("www/PB2002_boundaries.json") %>% paste(collapse = "\n")
          map <- leaflet(options = leafletOptions(dragging = F, zoomControl = F, scrollWheelZoom = "center")) %>%
            addTiles() %>%
            addGeoJSON(boundaries, weight = 3, color = "#DF536B", fill = FALSE) %>%
            setView(lng = lon, lat = lat, zoom = 10) %>%
            addMarkers(icon = list(iconUrl = "www/GNSS_marker.png", iconSize = c(50,50)), lng = lon, lat = lat, label = file$id1)
        }
        if (isTruthy(inputs$station_lat2) && isTruthy(inputs$station_lon2)) {
          lat2 <- inputs$station_lat2
          lon2 <- inputs$station_lon2
          lon2 <- ifelse(lon2 > 180, lon2 - 360, lon2)
          lon2 <- ifelse(lon2 < -180, lon2 + 360, lon2)
          map <- addMarkers(map = map, icon = list(iconUrl = "www/GNSS_marker.png", iconSize = c(25,25)), lng = lon2, lat = lat2, label = isolate(file$id2))
        }
        output$myMap <- renderLeaflet(map)
        output$map <- renderUI({
          runjs("var h1 = document.getElementById('information1').offsetHeight;
                var h2 = document.getElementById('showmap').offsetHeight;
                var h = h1 + h2 + h2;
                Shiny.onInputChange('hmap', h);")
          height <- paste0(ifelse(isTruthy(input$hmap),input$hmap,0),"px")
          suppressWarnings(leafletOutput(outputId = "myMap", width = "100%", height = height))
        })
        shinyjs::delay(5000, {runjs("document.getElementsByClassName('leaflet-control-attribution')[0].style.visibility = 'hidden';")})
      }
    } else {
      output$map <- renderUI({ NULL })
    }
  }, priority = 3)
  observeEvent(c(input$neuenu, input$tunits, input$sunits, allCoordinates()), {
    req(db1[[info$db1]], input$euler)
    removeNotification("unknown_units")
    removeNotification("no_rotation")
    if (((isTruthy(inputs$pole_x) && isTruthy(inputs$pole_y) && isTruthy(inputs$pole_z)) || (isTruthy(inputs$pole_lat) && isTruthy(inputs$pole_lon) && isTruthy(inputs$pole_rot))) &&
        (((isTruthy(inputs$station_x) && isTruthy(inputs$station_y) && isTruthy(inputs$station_z)) || (isTruthy(inputs$station_lat) && isTruthy(inputs$station_lon))) ||
         ((isTruthy(inputs$station_x2) && isTruthy(inputs$station_y2) && isTruthy(inputs$station_z2)) || (isTruthy(inputs$station_lat2) && isTruthy(inputs$station_lon2))))
    ) {
      stationCartesian <- c()
      stationCartesian2 <- c()
      stationGeo <- c()
      stationGeo2 <- c()
      poleCartesian <- c()
      if (messages > 0) cat(file = stderr(), mySession, "Compute plate rotation", "\n")
      if (input$sunits == 1) {
        scaling <- 1
      } else if (input$sunits == 2) {
        scaling <- 1000
      } else { #guessing the series units
        if (isTruthy(input$plateModel)) {
          showNotification(HTML("The series units have not been defined on the left panel.<br>Unable to set the correct units of the plate motion rate."), action = NULL, duration = 15, closeButton = T, id = "unknown_units", type = "error", session = getDefaultReactiveDomain())
          shinyjs::delay(10000, updateSelectInput(session, inputId = "plateModel", selected = ""))
        }
        req(info$stop)
        if (input$tunits == 1) {
          period <- daysInYear
          x <- db1[[info$db1]]$x1
        } else if (input$tunits == 2) {
          period <- 365.25/7
          x <- db1[[info$db1]]$x2
        } else if (input$tunits == 3) {
          period <- 1
          x <- db1[[info$db1]]$x3
        }
        if (input$format == 4) {
          selected <- db1[[info$db1]]$y1 # current series
        } else {
          selected <- db1[[info$db1]]$y3 # up series
        }
        if (diff(range(x))/period < 1 || length(x) < 6) {
          rate <- (mean(selected[-1*as.integer(length(x)*0.1):length(x)]) - mean(selected[1:as.integer(length(x)*0.1)])) / (mean(x[-1*as.integer(length(x)*0.1):length(x)]) - mean(x[1:as.integer(length(x)*0.1)]))
        } else {
          withProgress(message = 'Series units not defined.',
                       detail = 'Trying to guess the units ...', value = 0, {
                         setProgress(0)
                         vel <- sapply(1:length(x), function(i) midas_vel(m = i, t = period, disc = 0, x, selected))
                         vel <- c(vel[1,],vel[2,])
                         vel <- vel[vel > -999999]
                         vel_sig <- 1.4826*mad(vel, na.rm = T)
                         vel_lim <- c(median(vel) + 2*vel_sig, median(vel) - 2*vel_sig)
                         vel_good <- vel[vel < vel_lim[1] & vel > vel_lim[2]]
                         rate <- median(vel_good, na.rm = T)
                       })
        }
        if (abs(rate) > 0.05 && sum(abs(selected) > 3*0.05)*100/length(selected) > 10) {
          scaling <- 1000 # series units are mm most likely
          updateRadioButtons(session, inputId = "sunits", selected = 2)
        } else if (abs(rate) > 0.05 || sum(abs(selected) > 3*0.05)*100/length(selected) > 10) {
          # ambiguous time units
        } else {
          scaling <- 1 # series units are m most likely
          updateRadioButtons(session, inputId = "sunits", selected = 1)
        }
      }
      stationCartesian <- c(inputs$station_x,inputs$station_y,inputs$station_z)
      stationGeo <- c(inputs$station_lat*pi/180,inputs$station_lon*pi/180)
      if (input$pole_coordinates == 2) {
        poleCartesian <- inputs$pole_rot*degMa2radyr * c(cos(inputs$pole_lat*pi/180)*cos(inputs$pole_lon*pi/180),cos(inputs$pole_lat*pi/180)*sin(inputs$pole_lon*pi/180),sin(inputs$pole_lat*pi/180))
      } else {
        poleCartesian <- c(inputs$pole_x,inputs$pole_y,inputs$pole_z)*degMa2radyr
      }
      if (length(stationCartesian[!is.na(stationCartesian)]) == 3 && length(stationGeo[!is.na(stationGeo)]) == 2 && length(poleCartesian[!is.na(poleCartesian)]) == 3) {
        if (stationGeo[1] < -pi/2 || stationGeo[1] > pi/2 || stationGeo[2] > 2*pi || stationGeo[2] < -2*pi) {
          showNotification(HTML("Station coordinates are missing or out of bounds.<br>Check the input values."), action = NULL, duration = 15, closeButton = T, id = "bad_coordinates", type = "error", session = getDefaultReactiveDomain())
          updateRadioButtons(session, inputId = "eulerType", selected = 0)
          req(info$stop)
        }
        if (sqrt(stationCartesian[1]^2 + stationCartesian[2]^2 + stationCartesian[3]^2) < 6355000 || sqrt(stationCartesian[1]^2 + stationCartesian[2]^2 + stationCartesian[3]^2) > 6385000) {
          showNotification(HTML("Station coordinates are missing or out of bounds.<br>Check the input values."), action = NULL, duration = 15, closeButton = T, id = "bad_coordinates", type = "error", session = getDefaultReactiveDomain())
          updateRadioButtons(session, inputId = "eulerType", selected = 0)
          req(info$stop)
        }
        if (sqrt(poleCartesian[1]^2 + poleCartesian[2]^2 + poleCartesian[3]^2) > 2) {
          showNotification(HTML("Euler pole parameters missing or out of bounds.<br>Check the input values."), action = NULL, duration = 15, closeButton = T, id = "bad_pole", type = "error", session = getDefaultReactiveDomain())
          updateRadioButtons(session, inputId = "eulerType", selected = 0)
          req(info$stop)
        }
        plateCartesian <- cross(poleCartesian,stationCartesian)
        # Applying the ORB correction
        if (input$plateModel == "ITRF2020") {
          plateCartesian <- plateCartesian + c(0.37, 0.35, 0.74)/1000
        }
        # rotation <- matrix(data = c(-1*sin(stationGeo[1])*cos(stationGeo[2]),-1*sin(stationGeo[2]),-1*cos(stationGeo[1])*cos(stationGeo[2]),-1*sin(stationGeo[1])*sin(stationGeo[2]),cos(stationGeo[2]),-1*cos(stationGeo[1])*sin(stationGeo[2]),cos(stationGeo[1]),0,-1*sin(stationGeo[1])), nrow = 3, ncol = 3) #NEU
        rotation <- matrix(data = c(-1*sin(stationGeo[2]),-1*sin(stationGeo[1])*cos(stationGeo[2]),-1*cos(stationGeo[1])*cos(stationGeo[2]),cos(stationGeo[2]),-1*sin(stationGeo[1])*sin(stationGeo[2]),-1*cos(stationGeo[1])*sin(stationGeo[2]),0,cos(stationGeo[1]),-1*sin(stationGeo[1])), nrow = 3, ncol = 3) #ENU
        plate_neu <- c(rotation %*% plateCartesian)
        if ((input$format == 1 && input$neuenu == 1) || input$format == 2 || input$format == 3 || input$format == 4) { #ENU
          trans$plate <- plate_neu
        } else if ((input$format == 1 && input$neuenu == 2)) { #NEU
          trans$plate <- c(plate_neu[2],plate_neu[1],plate_neu[3])
        }
        # Forcing the Up velocity to zero, especially if an ORB was corrected
        trans$plate[3] <- 0
        if (input$tunits == 1) {
          trans$plate <- trans$plate/daysInYear
        } else if (input$tunits == 2) {
          trans$plate <- trans$plate*7/daysInYear
        }
        # changing between m/yr and mm/yr
        trans$plate <- trans$plate * scaling
        # plate motion for the secondary series
        if (isTruthy(inputs$station_x2) && isTruthy(inputs$station_y2) && isTruthy(inputs$station_z2) && isTruthy(inputs$station_lat2) && isTruthy(inputs$station_lon2)) {
          stationCartesian2 <- c(inputs$station_x2,inputs$station_y2,inputs$station_z2)
          stationGeo2 <- c(inputs$station_lat2*pi/180,inputs$station_lon2*pi/180)
          plateCartesian2 <- cross(poleCartesian,stationCartesian2)
          if (input$plateModel == "ITRF2020") {
            plateCartesian2 <- plateCartesian2 + c(0.37, 0.35, 0.74)/1000
          }
          rotation2 <- matrix(data = c(-1*sin(stationGeo2[2]),-1*sin(stationGeo2[1])*cos(stationGeo2[2]),-1*cos(stationGeo2[1])*cos(stationGeo2[2]),cos(stationGeo2[2]),-1*sin(stationGeo2[1])*sin(stationGeo2[2]),-1*cos(stationGeo2[1])*sin(stationGeo2[2]),0,cos(stationGeo2[1]),-1*sin(stationGeo2[1])), nrow = 3, ncol = 3) #ENU
          plate_neu2 <- c(rotation2 %*% plateCartesian2)
          if ((input$format2 == 1 && input$neuenu == 1) || input$format2 == 2 || input$format2 == 3 || input$format2 == 4) { #ENU
            trans$plate2 <- plate_neu2
          } else if ((input$format2 == 1 && input$neuenu == 2)) { #NEU
            trans$plate2 <- c(plate_neu2[2],plate_neu2[1],plate_neu2[3])
          }
          if (isTruthy(input$ne)) {
            trans$plate2 <- c(plate_neu2[2],plate_neu2[1],plate_neu2[3])
          }
          trans$plate2[3] <- 0
          if (input$tunits == 1) {
            trans$plate2 <- trans$plate2/daysInYear
          } else if (input$tunits == 2) {
            trans$plate2 <- trans$plate2*7/daysInYear
          }
          trans$plate2 <- trans$plate2 * scaling
        }
      } else {
        showNotification(HTML("Problem reading the station coordinates and/or the Euler pole parameters.<br>Check the input values."), action = NULL, duration = 15, closeButton = T, id = "no_rotation", type = "warning", session = getDefaultReactiveDomain())
        updateRadioButtons(session, inputId = "eulerType", selected = 0)
        trans$plate <- NULL
        trans$plate2 <- NULL
      }
    } else {
      trans$plate <- NULL
      trans$plate2 <- NULL
    }
  }, priority = 4)
  observeEvent(c(input$eulers), {
    if (!is.null(file$id1)) {
      pattern <- paste0("^",file$id1)
      record <- grep(pattern, readLines(con = input$eulers$datapath, n = -1L, ok = T, warn = F, skipNul = T), ignore.case = F, perl = T, value = T)
      l <- length(record)
      if (l > 0) {
        elements <- unlist(strsplit(record[[l]], "\\s+", fixed = F, perl = T, useBytes = F))
        if (length(elements) == 7) { # Cartesian
          if (!isTruthy(inputs$station_x) || !isTruthy(inputs$station_y) || !isTruthy(inputs$station_z)) {
            stationCartesian <- c(elements[2],elements[3],elements[4])
            updateRadioButtons(session, inputId = "station_coordinates", selected = 1)
            updateTextInput(session, inputId = "station_x", value = stationCartesian[1])
            updateTextInput(session, inputId = "station_y", value = stationCartesian[2])
            updateTextInput(session, inputId = "station_z", value = stationCartesian[3])
          }
          if (sqrt(as.numeric(elements[5])^2 + as.numeric(elements[6])^2 + as.numeric(elements[7])^2) > 2) { #Geographic
            polo_geo <- c(elements[5],elements[6],elements[7])
            updateRadioButtons(session, inputId = "pole_coordinates", selected = 2)
            inputs$pole_x <- inputs$pole_y <- inputs$pole_z <- NULL
            updateTextInput(session, inputId = "pole_lat", value = polo_geo[1])
            updateTextInput(session, inputId = "pole_lon", value = polo_geo[2])
            updateTextInput(session, inputId = "pole_rot", value = polo_geo[3])
          } else { # Cartesian
            poleCartesian <- c(elements[5],elements[6],elements[7])
            updateRadioButtons(session, inputId = "pole_coordinates", selected = 1)
            inputs$pole_lat <- inputs$pole_lon <- inputs$pole_rot <- NULL
            updateTextInput(session, inputId = "pole_x", value = poleCartesian[1])
            updateTextInput(session, inputId = "pole_y", value = poleCartesian[2])
            updateTextInput(session, inputId = "pole_z", value = poleCartesian[3])
          }
        } else if (length(elements) == 6) { #Geographic
          if (!isTruthy(inputs$station_lat) || !isTruthy(inputs$station_lon)) {
            stationGeo <- c(elements[2],elements[3])
            updateRadioButtons(session, inputId = "station_coordinates", selected = 2)
            updateTextInput(session, inputId = "station_lat", value = stationGeo[1])
            updateTextInput(session, inputId = "station_lon", value = stationGeo[2])
          }
          if (sqrt(as.numeric(elements[4])^2 + as.numeric(elements[5])^2 + as.numeric(elements[6])^2) > 2) { #Geographic
            polo_geo <- c(elements[4],elements[5],elements[6])
            updateRadioButtons(session, inputId = "pole_coordinates", selected = 2)
            inputs$pole_x <- inputs$pole_y <- inputs$pole_z <- NULL
            updateTextInput(session, inputId = "pole_lat", value = polo_geo[1])
            updateTextInput(session, inputId = "pole_lon", value = polo_geo[2])
            updateTextInput(session, inputId = "pole_rot", value = polo_geo[3])
          } else { # Cartesian
            poleCartesian <- c(elements[4],elements[5],elements[6])
            updateRadioButtons(session, inputId = "pole_coordinates", selected = 1)
            inputs$pole_lat <- inputs$pole_lon <- inputs$pole_rot <- NULL
            updateTextInput(session, inputId = "pole_x", value = poleCartesian[1])
            updateTextInput(session, inputId = "pole_y", value = poleCartesian[2])
            updateTextInput(session, inputId = "pole_z", value = poleCartesian[3])
          }
        }
        updateSelectInput(inputId = "plateModel", selected = "")
        updateRadioButtons(session, inputId = "eulerType", selected = 1)
      }
    }
  }, priority = 200)
  observeEvent(input$eulerType, {
    req(db1[[info$db1]])
    if (input$eulerType == 2 || info$last_eulerType == 2) {
      db1[[info$db1]]$mod1 <- db1[[info$db1]]$mod2 <- NULL
      db1[[info$db1]]$res1 <- db1[[info$db1]]$res2 <- NULL
    }
    if (messages > 0) cat(file = stderr(), mySession, paste("Plate rotation option", input$eulerType), "\n")
    # updating the overview plot only for 3D plots
    if (input$tab == 4 && info$last_eulerType != input$eulerType) {
      updateOverview()
    }
    info$last_eulerType <- input$eulerType
  })

  # Observe GIA ####
  observeEvent(c(input$gia), {
    req(db1[[info$db1]])
    if (input$gia) {
      runjs("
        let element = document.getElementById('gia');
        element.scrollIntoView({
          behavior: 'smooth'
        });
        ")
    }
  })
  observeEvent(c(input$giaModel, inputs$station_lon, inputs$station_lat, inputs$station_lat2, inputs$station_lon2, input$tunits), {
    req(db1[[info$db1]])
    if (isTruthy(input$gia) || isTruthy(trans$gia)) {
      if (messages > 0) cat(file = stderr(), mySession, "GIA model:", input$giaModel, "\n")
      removeNotification("unknown_units")
      removeNotification("bad_coordinates")
      z1 <- z2 <- NULL
      if (input$tunits == 1) {
        scaling <- 1/daysInYear
        x <- db1[[info$db1]]$x1
      } else if (input$tunits == 2) {
        scaling <- 7/daysInYear
        x <- db1[[info$db1]]$x2
      } else {
        scaling <- 1
        x <- db1[[info$db1]]$x3
      }
      if (input$sunits == 1) {
        scaling <- scaling/1000
      } else if (input$sunits == 2) {
        scaling <- scaling
      } else { #guessing the series units
        if (isTruthy(input$giaModel)) {
          showNotification(HTML("The series units have not been defined on the left panel.<br>Unable to set the correct units of the GIA rate."), action = NULL, duration = 15, closeButton = T, id = "unknown_units", type = "error", session = getDefaultReactiveDomain())
          shinyjs::delay(10000, updateSelectInput(session, inputId = "giaModel", selected = ""))
        }
        req(info$stop)
        if (input$tunits == 1) {
          period <- 365.25
        } else if (input$tunits == 2) {
          period <- 365.25/7
        } else if (input$tunits == 3) {
          period <- 1
        }
        if (input$format == 4) {
          selected <- db1[[info$db1]]$y1 # current series
        } else {
          selected <- db1[[info$db1]]$y3 # up series
        }
        if (diff(range(x))/period < 1 || length(x) < 6) {
          rate <- (mean(selected[-1*as.integer(length(x)*0.1):length(x)]) - mean(selected[1:as.integer(length(x)*0.1)])) / (mean(x[-1*as.integer(length(x)*0.1):length(x)]) - mean(x[1:as.integer(length(x)*0.1)]))
        } else {
          withProgress(message = 'Series units not defined.',
                       detail = 'Trying to guess the units ...', value = 0, {
                         setProgress(0)
                         vel <- sapply(1:length(x), function(i) midas_vel(m = i, t = period, disc = 0, x, selected))
                         vel <- c(vel[1,],vel[2,])
                         vel <- vel[vel > -999999]
                         vel_sig <- 1.4826*mad(vel, na.rm = T)
                         vel_lim <- c(median(vel) + 2*vel_sig, median(vel) - 2*vel_sig)
                         vel_good <- vel[vel < vel_lim[1] & vel > vel_lim[2]]
                         rate <- median(vel_good, na.rm = T)
                       })
        }
        if (abs(rate) > 0.1 && sum(abs(selected) > 3*0.05)*100/length(selected) > 10) {
          scaling <- 1000 # series units are mm most likely
          updateRadioButtons(session, inputId = "sunits", selected = 2)
        } else if (abs(rate) > 0.1 || sum(abs(selected) > 3*0.05)*100/length(selected) > 10) {
          # ambiguous time units
        } else {
          scaling <- 1 # series units are m most likely
          updateRadioButtons(session, inputId = "sunits", selected = 1)
        }
      }
      withBusyIndicatorServer("giaModel", {
        if (isTruthy(inputs$station_lat) && isTruthy(inputs$station_lon)) {
          if (inputs$station_lon < 0) {
            x1 <- inputs$station_lon + 360
          } else {
            x1 <- inputs$station_lon
          }
          y1 <- inputs$station_lat
          z1 <- interpolateGIA(x1,y1,1)
          if (isTruthy(z1)) {
            z1 <- z1 * scaling
          }
        }
        if (isTruthy(z1)) {
          updateTextInput(session, inputId = "giaTrend", value = sprintf('%.6f', z1))
          if (input$giaType == 0) {
            updateRadioButtons(session, inputId = "giaType", selected = 1)
          }
        }
        if (isTruthy(inputs$station_lat2) && isTruthy(inputs$station_lon2)) {
          if (inputs$station_lon2 < 0) {
            x2 <- inputs$station_lon2 + 360
          } else {
            x2 <- inputs$station_lon2
          }
          y2 <- inputs$station_lat2
          z2 <- interpolateGIA(x2,y2,2)
          if (isTruthy(z2)) {
            z2 <- z2 * scaling
          }
        }
        if (isTruthy(z2)) {
          updateTextInput(session, inputId = "giaTrend2", value = sprintf('%.6f', z2))
          if (input$giaType == 0) {
            updateRadioButtons(session, inputId = "giaType", selected = 1)
          }
        }
      })
    }
  })
  observeEvent(inputs$giaTrend, {
    req(db1[[info$db1]])
    if (isTruthy(inputs$giaTrend)) {
      trans$gia <- c(0,0,inputs$giaTrend)
    } else {
      trans$gia <- NULL
    }
  })
  observeEvent(inputs$giaTrend2, {
    req(db2[[info$db2]])
    if (isTruthy(inputs$giaTrend2)) {
      trans$gia2 <- c(0,0,inputs$giaTrend2)
    } else {
      trans$gia2 <- NULL
    }
  })
  observeEvent(input$giaType, {
    req(db1[[info$db1]])
    if (input$giaType == 2 || info$last_giaType == 2) {
      db1[[info$db1]]$mod3 <- NULL
      db1[[info$db1]]$res3 <- NULL
    }
    if (messages > 0) cat(file = stderr(), mySession, paste("GIA rate option", input$giaType), "\n")
    # updating the overview plot only for 3D plots
    if (input$tab == 4 && info$last_giaType != input$giaType) {
      updateOverview()
    }
    info$last_giaType <- input$giaType
  })

  # Observe wavelet ####
  observeEvent(c(inputs$min_wavelet, inputs$max_wavelet, inputs$res_wavelet, inputs$loc_wavelet),{
    req(db1[[info$db1]])
    if (isTruthy(inputs$min_wavelet) && isTruthy(inputs$max_wavelet) && isTruthy(inputs$res_wavelet) && isTruthy(inputs$loc_wavelet)) {
      removeNotification("bad_wavelet")
      if (inputs$max_wavelet > 0 && inputs$min_wavelet > 0 && inputs$res_wavelet > 0 && inputs$loc_wavelet >= info$sampling && inputs$loc_wavelet <= info$rangex/2) {
        removeNotification("time_wavelet")
        num_scale <- as.integer((inputs$max_wavelet - inputs$min_wavelet)/as.numeric(inputs$res_wavelet))
        num_epochs <- info$rangex/as.numeric(inputs$loc_wavelet)
        time_needed <- ceiling(0.000588*num_scale*num_epochs/60)
        if (time_needed > 29) {
          if (isTruthy(info$local)) {
            shinyjs::delay(500, showNotification(paste0("The time needed to compute the wavelet with the current parameters is around ",time_needed," min."), action = NULL, duration = 10, closeButton = T, id = "time_wavelet", type = "warning", session = getDefaultReactiveDomain()))
          } else {
            shinyjs::delay(500, showNotification(HTML(paste0("The time needed to compute the wavelet with the current parameters is around ",time_needed," min.<br><br>WARNING: the server may kill the connection before the wavelet finishes!")), action = NULL, duration = 10, closeButton = T, id = "time_wavelet", type = "error", session = getDefaultReactiveDomain()))
          }
        } else {
          shinyjs::delay(500, showNotification(paste0("The time needed to compute the wavelet with the current parameters is around ",time_needed," min."), action = NULL, duration = 10, closeButton = T, id = "time_wavelet", type = "warning", session = getDefaultReactiveDomain()))
        }
      } else {
        showNotification(HTML(paste0("Invalid bounds to compute the wavelet.<br>Check the input values.")), action = NULL, duration = 10, closeButton = T, id = "bad_wavelet", type = "error", session = getDefaultReactiveDomain())
      }
    } else {
      updateRadioButtons(session, inputId = "waveletType", selected = 0)
    }
  })

  # Observe time units ####
  observeEvent(input$tunits, {
    req(db1[[info$db1]], input$tunits != info$tunits.last)
    if (input$tunits == 1) {
      x1 <- db1[[info$db1]]$x1
      x2 <- db2[[info$db2]]$x1
      if (info$tunits.last == 2) {
        fun <- "week2mjd"
        scale <- 7
      } else if (info$tunits.last == 3) {
        fun <- "year2mjd"
        scale <- daysInYear
      }
    } else if (input$tunits == 2) {
      x1 <- db1[[info$db1]]$x2
      x2 <- db2[[info$db2]]$x2
      if (info$tunits.last == 1) {
        fun <- "mjd2week"
        scale <- 1/7
      } else if (info$tunits.last == 3) {
        fun <- "year2week"
        scale <- daysInYear/7
      }
    } else if (input$tunits == 3) {
      x1 <- db1[[info$db1]]$x3
      x2 <- db2[[info$db2]]$x3
      if (info$tunits.last == 1) {
        fun <- "mjd2year"
        scale <- 1/daysInYear
      } else if (info$tunits.last == 2) {
        fun <- "week2year"
        scale <- 7/daysInYear
      }
    }
    if (isTruthy(info$step)) {
      decimals <- decimalplaces(x1,0)
      session$sendCustomMessage("step", sprintf("%.*f",decimals, info$step * scale))
      info$step <- info$step * scale
    }
    if (isTruthy(inputs$step2)) {
      decimals <- decimalplaces(x2,0)
      session$sendCustomMessage("step2", sprintf("%.*f",decimals, info$step2 * scale))
      info$step2 <- info$step2 * scale
    }
    if (isTruthy(inputs$trendRef)) {
      if (info$tunits.last == 1) {
        if (input$tunits == 2) {
          new <- mjd2week(inputs$trendRef)
        } else if (input$tunits == 3) {
          new <- mjd2year(inputs$trendRef)
        }
      } else if (info$tunits.last == 2) {
        if (input$tunits == 1) {
          new <- week2mjd(inputs$trendRef)
        } else if (input$tunits == 3) {
          new <- week2year(inputs$trendRef)
        }
      } else if (info$tunits.last == 3) {
        if (input$tunits == 1) {
          new <- year2mjd(inputs$trendRef)
        } else if (input$tunits == 2) {
          new <- year2week(inputs$trendRef)
        }
      }
      if (isTruthy(new)) {
        # session$sendCustomMessage("trendRef", new)
      }
    }
    # Setting plot limits
    if (isTruthy(input$remove3D)) {
      info$minx <- min(x1[!is.na(db1[[info$db1]]$status1)], na.rm = T)
      info$maxx <- max(x1[!is.na(db1[[info$db1]]$status1)], na.rm = T)
      ranges$x0 <- c(info$minx, info$maxx)
      if (isTruthy(input$fullSeries)) {
        # show all points from primary & secondary series
        info$minx <- min(x1[!is.na(db1[[info$db1]]$status1)], x2, na.rm = T)
        info$maxx <- max(x1[!is.na(db1[[info$db1]]$status1)], x2, na.rm = T)
      }
      ranges$x1 <- c(info$minx, info$maxx)
    }
    if (input$fitType == 2 && length(trans$mod) > 0 && length(trans$res) > 0) {
      info$run <- F
      trans$mod <- trans$mod0 <- NULL
      trans$res <- trans$res0 <- NULL
      trans$kalman <- trans$kalman0 <- NULL
      trans$kalman_unc <- trans$kalman_unc0 <- NULL
    }
    if (isTruthy(inputs$trendRef)) {
      info$trendRef <- F
    }
    if (isTruthy(inputs$PolyRef)) {
      info$PolyRef <- F
    }
    if (isTruthy(inputs$periodRef)) {
      info$periodRef <- F
    }
    if (isTruthy(info$sampling0) && info$sampling0 > 0) {
      info$sampling0 <- info$sampling0*scale
    }
    if (length(trans$offsetEpochs) > 0) {
      inputs$offsetEpoch <- paste(sapply(trans$offsetEpochs, fun), collapse = ", ")
      updateTextInput(inputId = "offsetEpoch", value = inputs$offsetEpoch)
    }
    if (length(trans$breakEpochs) > 0) {
      inputs$breakEpoch <- paste(sapply(trans$breakEpochs, fun), collapse = ", ")
      updateTextInput(inputId = "breakEpoch", value = inputs$breakEpoch)
    }
    if (length(inputs$ExponenRef) > 0) {
      inputs$ExponenRef <- paste(sapply(as.numeric(unlist(strsplit(inputs$ExponenRef,","))), fun), collapse = ", ")
      inputs$TE0 <- paste(as.numeric(unlist(strsplit(inputs$TE0,",")))*scale, collapse = ", ")
      updateTextInput(inputId = "ExponenRef", value = inputs$ExponenRef)
      updateTextInput(inputId = "TE0", value = inputs$TE0)
    }
    if (length(inputs$LogariRef) > 0) {
      inputs$LogariRef <- paste(sapply(as.numeric(unlist(strsplit(inputs$LogariRef,","))), fun), collapse = ", ")
      inputs$TL0 <- paste(as.numeric(unlist(strsplit(inputs$TL0,",")))*scale, collapse = ", ")
      updateTextInput(inputId = "LogariRef", value = inputs$LogariRef)
      updateTextInput(inputId = "TL0", value = inputs$TL0)
    }
    if (isTruthy(input$wavelet)) {
      updateRadioButtons(session, inputId = "waveletType", selected = 0)
      min_wavelet <- as.numeric(inputs$min_wavelet)*scale
      min_scale <- get.min.scale(x1)
      if (min_scale > min_wavelet) {
        min_wavelet <- min_scale
      }
      max_wavelet <- as.numeric(inputs$max_wavelet)*scale
      max_scale <- get.max.scale(x1)
      if (max_scale > max_wavelet) {
        max_wavelet <- max_scale
      }
      res_wavelet <- as.numeric(inputs$res_wavelet)*scale
      loc_wavelet <- as.numeric(inputs$loc_wavelet)*scale
      shinyjs::delay(500,{
        updateTextInput(session, "min_wavelet", value = sprintf("%.*f", info$decimalsx, min_wavelet))
        updateTextInput(session, "max_wavelet", value = sprintf("%.*f", info$decimalsx, max_wavelet))
        updateTextInput(session, "res_wavelet", value = res_wavelet)
        updateTextInput(inputId = "loc_wavelet", value = sprintf("%.*f", info$decimalsx, loc_wavelet))
      })
    }
    if (isTruthy(inputs$waveformPeriod)) {
      inputs$waveformPeriod <- as.numeric(inputs$waveformPeriod)*scale
      updateTextInput(inputId = "waveformPeriod", value = "")
      shinyjs::delay(100, updateTextInput(inputId = "waveformPeriod", value = inputs$waveformPeriod))
    }
    if (isTruthy(input$mle)) {
      updateCheckboxInput(session, inputId = "mle", value = F)
    }
    if (isTruthy(input$spectrum)) {
      trans$fs <- NULL
      inputs$long_period <- as.numeric(inputs$long_period)*scale
      inputs$short_period <- as.numeric(inputs$short_period)*scale
      updateTextInput(inputId = "long_period", value = inputs$long_period)
      updateTextInput(inputId = "short_period", value = inputs$short_period)
    }
    if (isTruthy(input$filter)) {
      trans$filter <- NULL
      inputs$low <- as.numeric(inputs$low)*scale
      inputs$high <- as.numeric(inputs$high)*scale
      updateTextInput(inputId = "low", value = inputs$low)
      updateTextInput(inputId = "high", value = inputs$high)
    }
    if (isTruthy(info$custom) && length(info$custom) > 0) {
      tmp_custom <- info$custom
      for (d in 1:length(info$custom_years)) {
        if (isTruthy(info$custom_years[[d]])) {
          if (input$tunits == 1) {
            tmp_custom[[d]] <- year2mjd(info$custom_years[[d]])
          } else if (input$tunits == 2) {
            tmp_custom[[d]] <- year2week(info$custom_years[[d]])
          } else if (input$tunits == 3) {
            tmp_custom[[d]] <- info$custom_years[[d]]
          }
        }
      }
      info$custom <- tmp_custom
    }
    if (isTruthy(info$soln) && length(info$soln) > 0) {
      tmp_soln <- info$soln
      for (d in 1:length(info$soln_years)) {
        if (isTruthy(info$soln_years[[d]])) {
          if (input$tunits == 1) {
            tmp_soln[[d]] <- year2mjd(info$soln_years[[d]])
          } else if (input$tunits == 2) {
            tmp_soln[[d]] <- year2week(info$soln_years[[d]])
          } else if (input$tunits == 3) {
            tmp_soln[[d]] <- info$soln_years[[d]]
          }
        }
      }
      info$soln <- tmp_soln
    }
    if (length(info$log) > 0) {
      tmp_log <- info$log
      for (d in 1:length(info$log_years)) {
        if (isTruthy(info$log_years[[d]])) {
          if (input$tunits == 1) {
            tmp_log[[d]] <- year2mjd(info$log_years[[d]])
          } else if (input$tunits == 2) {
            tmp_log[[d]] <- year2week(info$log_years[[d]])
          } else if (input$tunits == 3) {
            tmp_log[[d]] <- info$log_years[[d]]
          }
        }
      }
      info$log <- tmp_log
    }
    if (length(info$sinfo) > 0) {
      tmp_sinfo <- info$sinfo
      for (d in 1:length(info$sinfo_years)) {
        if (isTruthy(info$sinfo_years[[d]])) {
          if (input$tunits == 1) {
            tmp_sinfo[[d]] <- year2mjd(info$sinfo_years[[d]])
          } else if (input$tunits == 2) {
            tmp_sinfo[[d]] <- year2week(info$sinfo_years[[d]])
          } else if (input$tunits == 3) {
            tmp_sinfo[[d]] <- info$sinfo_years[[d]]
          }
        }
      }
      info$sinfo <- tmp_sinfo
    }
    info$tunits.last <- input$tunits
  }, priority = 100)

  # Observe tab ####
  observeEvent(input$tab, {
    req(db1$original)
    ranges$y1 <- NULL
    ranges$y2 <- NULL
    ranges$y12 <- NULL
    trans$midas_vel <- NULL
    trans$midas_all <- NULL
    trans$res <- trans$res0 <- NULL
    trans$reserror <- NULL
    trans$results <- NULL
    trans$mod <- trans$mod0 <- NULL
    trans$kalman <- trans$kalman0 <- NULL
    trans$kalman_unc <- trans$kalman_unc0 <- NULL
    trans$equation <- NULL
    trans$mle <- F
    info$run <- F
    trans$verif <- NULL
    trans$pattern <- NULL
    trans$names <- NULL
    trans$noise <- NULL
    inputs$min_wavelet <- ""
    if (nchar(input$ObsError) > 0) {
      updateTextInput(session, "ObsError", value = "")
    }
    if (isTruthy(input$white)) {
      updateCheckboxInput(session, inputId = "white", label = NULL, value = F)
    }
    if (isTruthy(input$flicker)) {
      updateCheckboxInput(session, inputId = "flicker", label = NULL, value = F)
    }
    if (isTruthy(input$randomw)) {
      updateCheckboxInput(session, inputId = "randomw", label = NULL, value = F)
    }
    if (isTruthy(input$powerl)) {
      updateCheckboxInput(session, inputId = "powerl", label = NULL, value = F)
    }
    if (input$waveletType > 0) {
      updateRadioButtons(session, inputId = "waveletType", label = NULL, selected = 0)
    }
    if (input$tab < 4) {
      updateCollapse(session, id = "menu", open = c(2,4,5), close = 1)
    } else if (input$tab == 4) {
      updateCollapse(session, id = "menu", open = c(1,2), close = c(4,5))
      if (!isTruthy(ranges$x1)) {
        info$minx <- min(db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status1)],
                         db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status2)],
                         db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status3)])
        info$maxx <- max(db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status1)],
                         db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status2)],
                         db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status3)])
        ranges$x1 <- c(info$minx, info$maxx)
      }
      info$decimalsy <- info$decimalsyList[as.numeric(input$tab)]
      info$scientific <- info$scientificList[as.numeric(input$tab)]
    } else if (input$tab == 5) {
      updateCollapse(session, id = "menu", open = c(2), close = c(1,4,5))
      info$decimalsy <- info$decimalsyList[4]
      info$scientific <- info$scientificList[4]
    }
  }, priority = 100)

  # Observe ancillary files ####
  observeEvent(input$log, {
    req(db1$original)
    file$sitelog <- isolate(input$log)
    file$sitelog$datapath <- paste0("www/tempFiles/",input$log$name)
    file.copy(input$log$datapath, file$sitelog$datapath, overwrite = T, recursive = F, copy.mode = T, copy.date = T)
  }, priority = 8)
  observeEvent(input$sinfo, {
    req(db1$original)
    file$sinfo <- isolate(input$sinfo)
    file$sinfo$datapath <- paste0("www/tempFiles/",input$sinfo$name)
    file.copy(input$sinfo$datapath, file$sinfo$datapath, overwrite = T, recursive = F, copy.mode = T, copy.date = T)
  }, priority = 8)
  observeEvent(input$soln, {
    req(db1$original)
    file$soln <- isolate(input$soln)
    file.copy(file$soln$datapath, paste0("www/tempFiles/",input$soln$name), overwrite = T, recursive = F, copy.mode = T, copy.date = T)
    file$soln$datapath <- paste0("www/tempFiles/",input$soln$name)
  }, priority = 8)
  observeEvent(input$custom, {
    req(db1$original)
    file$custom <- isolate(input$custom)
    file.copy(file$custom$datapath, paste0("www/tempFiles/",input$custom$name), overwrite = T, recursive = F, copy.mode = T, copy.date = T)
    file$custom$datapath <- paste0("www/tempFiles/",input$custom$name)
  }, priority = 8)

  # Observe series info ####
  observeEvent(c(input$tab, input$format, input$format2), {
    if (input$tab == "6") {
      if (messages > 0) cat(file = stderr(), mySession, "Showing help file", "\n")
    } else {
      req(db1[[info$db1]])
      info$tab <- input$tab
      info$format <- input$format
      info$format2 <- input$format2
      printInfo("CHANGE")
    }
  }, priority = 7)
  observeEvent(c(input$tunits, input$sunits, input$sigmas, file$secondary, input$optionSecondary, input$log, input$sinfo, file$soln, file$custom, inputs$step, input$separator, inputs$epoch, inputs$variable, inputs$errorBar, inputs$scaleFactor, inputs$step2, input$separator2, inputs$epoch2, inputs$variable2, inputs$errorBar2, input$fullSeries, input$sameScale, input$same_axis, input$ne), {
    if (input$tab == "6") {
      if (messages > 0) cat(file = stderr(), mySession, "Showing help file", "\n")
    } else {
      req(db1[[info$db1]])
      updateOverview()
      printInfo("CHANGE")
    }
  }, priority = 7)

  # Observe primary file ####
  observeEvent(input$series, {
    file$primary <- isolate(input$series)
    header <- readLines(input$series$datapath, n = 1)
    if (grepl(".tenv3$", file$primary$name, perl = T) && grepl("site YYMMMDD ", header, fixed = T)) {
      updateRadioButtons(inputId = "format", selected = 3)
      updateRadioButtons(inputId = "sunits", selected = 1)
      updateRadioButtons(inputId = "tunits", selected = 3)
    } else if (grepl(".pos$", file$primary$name, perl = T) && grepl("PBO Station Position Time Series", header, fixed = T)) {
      updateRadioButtons(inputId = "format", selected = 2)
      updateRadioButtons(inputId = "sunits", selected = 1)
      updateRadioButtons(inputId = "tunits", selected = 3)
    } else if (grepl(".pos$", file$primary$name, perl = T) && grepl("GeoCSV", header, fixed = T)) {
      updateRadioButtons(inputId = "format", selected = 1)
      updateRadioButtons(inputId = "sunits", selected = 1)
      updateRadioButtons(inputId = "tunits", selected = 3)
      url$server <- "EARTHSCOPE"
      url$file <- file$primary
    } else if (grepl(".enu$", file$primary$name, perl = T) && grepl("SPOTGINS SOLUTION [POSITION]", header, fixed = T)) {
      updateRadioButtons(inputId = "format", selected = 1)
      updateRadioButtons(inputId = "sunits", selected = 1)
      updateRadioButtons(inputId = "tunits", selected = 3)
      info$product1 <- "SPOTGINS"
    } else if (grepl(".PLH$", file$primary$name, perl = T) && grepl("^DGFI-TUM:", header, perl = T)) {
      updateRadioButtons(inputId = "format", selected = 1)
      updateRadioButtons(inputId = "sunits", selected = 1)
      updateRadioButtons(inputId = "tunits", selected = 3)
      url$server <- "SIRGAS"
      url$file <- file$primary
    } else if (grepl(".series$", file$primary$name, perl = T) && grepl(pattern = "\\.00\\s{2}\\d{4}\\s{1,2}\\d{1,2}\\s{1,2}\\d{1,2}\\s{1,2}\\d{1,2}\\s{1,2}\\d{1,2}\\s{1,2}\\d{1,2}$", header, perl = T)) {
      updateRadioButtons(inputId = "format", selected = 1)
      updateRadioButtons(inputId = "sunits", selected = 1)
      updateRadioButtons(inputId = "tunits", selected = 3)
      url$server <- "JPL"
      url$file <- file$primary
    } else if (grepl("rlrdata", file$primary$name, perl = T) && grepl(";", header, perl = T)) {
      updateRadioButtons(inputId = "format", selected = 4)
      updateSelectInput(inputId = "separator", selected = 3)
      updateCheckboxInput(inputId = "sigmas", value = F)
      updateRadioButtons(inputId = "sunits", selected = 2)
      updateRadioButtons(inputId = "tunits", selected = 3)
      url$server <- "PSMSL"
      url$file <- file$primary
    } else if (grepl("_igs.plh$", file$primary$name, perl = T)) {
      updateRadioButtons(inputId = "format", selected = 1)
      updateRadioButtons(inputId = "sunits", selected = 1)
      updateRadioButtons(inputId = "tunits", selected = 3)
      url$server <- "IGS"
      url$file <- file$primary
    } else if (grepl(".stcd.", file$primary$name, perl = T)) {
      updateRadioButtons(inputId = "format", selected = 1)
      updateRadioButtons(inputId = "sunits", selected = 1)
      updateRadioButtons(inputId = "tunits", selected = 1)
      url$server <- "DORIS"
      url$file <- file$primary
    } else {
      updateRadioButtons(inputId = "format", selected = 1)
      updateRadioButtons(inputId = "sunits", selected = 0)
    }
    info$run <- NULL
    trans$x <- NULL
    trans$y <- NULL
    trans$sy <- NULL
    trans$xe <- NULL
    trans$ye <- NULL
    trans$sye <- NULL
    trans$res <- NULL
    trans$reserror <- NULL
    trans$results <- NULL
    trans$mod <- NULL
    trans$filter <- NULL
    trans$filterRes <- NULL
    trans$kalman <- NULL
    trans$equation <- NULL
    trans$ordinate <- NULL
    trans$midas_vel <- NULL
    trans$midas_all <- NULL
    info$points <- NULL
    info$log <- NULL
    trans$mle <- F
    trans$verif <- NULL
    trans$pattern <- NULL
    updateTabsetPanel(session, inputId = "tab", selected = "1")
    updateTextInput(session, "ObsError", value = "")
    updateTextInput(session, "waveformPeriod", value = "")
    if (isTruthy(input$correct_waveform)) {
      updateCheckboxInput(session, inputId = "correct_waveform", value = F)
    }
  }, priority = 6)

  # Observe format 1D ####
  observeEvent(c(inputs$epoch, inputs$variable, inputs$errorBar, input$separator), {
    req(db1[[info$db1]])
    trans$x <- NULL
    trans$y <- NULL
    trans$sy <- NULL
    if (isTruthy(inputs$long_period)) {
      trans$fs <- NULL
      updateTextInput(session, "long_period", value = "")
    }
    if (messages > 4) cat(file = stderr(), mySession, "From: observe format 1D\n")
    db1$original <- db1$resampled <- db1$merged <- NULL
    digest(1)
    if (input$fitType == 2) {
      trans$midas_vel <- NULL
      trans$midas_all <- NULL
      trans$res <- NULL
      trans$reserror <- NULL
      trans$results <- NULL
      trans$mod <- NULL
      trans$kalman <- NULL
      trans$equation <- NULL
      trans$mle <- F
      trans$verif <- NULL
      trans$pattern <- NULL
      trans$names <- NULL
      trans$noise <- NULL
      updateTextInput(session, "ObsError", value = "")
      updateTextInput(session, inputId = "Intercept0", value = "")
      updateTextInput(session, inputId = "eIntercept0", value = "")
      updateTextInput(session, inputId = "Trend0", value = "")
      updateTextInput(session, inputId = "eTrend0", value = "")
    }
    if (isTruthy(input$white)) {
      updateCheckboxInput(session, inputId = "white", label = NULL, value = F)
    }
    if (isTruthy(input$flicker)) {
      updateCheckboxInput(session, inputId = "flicker", label = NULL, value = F)
    }
    if (isTruthy(input$randomw)) {
      updateCheckboxInput(session, inputId = "randomw", label = NULL, value = F)
    }
    if (isTruthy(input$powerl)) {
      updateCheckboxInput(session, inputId = "powerl", label = NULL, value = F)
    }
  }, priority = 6)
  observeEvent(c(inputs$epoch2, inputs$variable2, inputs$errorBar2), {
    req(db2[[info$db2]])
    if (messages > 4) cat(file = stderr(), mySession, "From: observe format 1D secondary\n")
    db2$original <- db2$resampled <- NULL
    digest(2)
  }, priority = 6)

  # Observe averaging ####
  observeEvent(c(inputs$step), {
    req(db1$original)
    removeNotification("bad_window")
    if (nchar(input$step) > 0 && is.na(inputs$step)) {
      info$step <- NULL
      showNotification(HTML("The resampling period is not numeric.<br>Check input value."), action = NULL, duration = 10, closeButton = T, id = "bad_window", type = "error", session = getDefaultReactiveDomain())
    } else if (isTruthy(inputs$step)) {
      info$step <- inputs$step
    } else {
      info$db1 <- "original"
      updateTextInput(session, inputId = "step", value = "")
      info$step <- NULL
      if (input$optionSecondary > 1) {
        info$last_optionSecondary <- 1
        updateRadioButtons(session, inputId = "optionSecondary", label = NULL, selected = 1)
      }
      req(info$stop)
    }
    if (isTruthy(inputs$step) && abs(inputs$step - info$sampling) < info$tol) req(info$stop)
    if (messages > 0) cat(file = stderr(), mySession, "Averaging primary series", "\n")
    if (input$fitType == 2) {
      info$run <- NULL
      trans$res <- NULL
      trans$reserror <- NULL
      trans$results <- NULL
      trans$mod <- NULL
      trans$kalman <- NULL
      trans$equation <- NULL
      trans$ordinate <- NULL
      trans$filter <- NULL
      trans$filterRes <- NULL
    }
    trans$midas_vel <- NULL
    trans$midas_all <- NULL
    info$points <- NULL
    info$log <- NULL
    trans$mle <- F
    trans$verif <- NULL
    trans$pattern <- NULL
    db1[[info$db1]]$mod1 <- db1[[info$db1]]$mod2 <- db1[[info$db1]]$mod3 <- NULL
    db1[[info$db1]]$res1 <- db1[[info$db1]]$res2 <- db1[[info$db1]]$res3 <- NULL
    updateCheckboxInput(session, inputId = "mle", value = F)
    if (isTruthy(input$correct_waveform)) {
      updateCheckboxInput(session, inputId = "correct_waveform", value = F)
    }
    updateTextInput(session, "short_period", value = "")
    updateTextInput(session, "ObsError", value = "")
    if (input$tunits == 1) {
      x <- db1$original$x1
    } else if (input$tunits == 2) {
      x <- db1$original$x2
    } else if (input$tunits == 3) {
      x <- db1$original$x3
    }
    db1$resampled <- NULL
    if (inputs$step > info$sampling0 && inputs$step <= (max(x) - min(x))/2) {
      tolerance <- min(diff(x,1))/3
      info$step <- inputs$step
      info$stepUnit <- input$tunits
      withProgress(message = 'Averaging the series.',
                   detail = 'This may take a while ...', value = 0, {
                     w <- as.integer((max(x) - min(x))/inputs$step)
                     if (info$format == 4) {
                       if (input$sigmas) {
                         averaged <- sapply(1:w, function(p) average(p, x = x, y1 = db1$original$y1, y2 = NULL, y3 = NULL, sy1 = db1$original$sy1, sy2 = NULL, sy3 = NULL, tol = tolerance, w = w, s = inputs$step, second = F, sigmas = T), simplify = T)
                         db1$resampled <- na.omit(data.frame(x1 = averaged[1,], y1 = averaged[2,], sy1 = averaged[3,]))
                         db1$resampled$x1 <- as.numeric(format(db1$resampled$x1, digits = 2, nsmall = info$decimalsx, trim = F, scientific = F, width = info$decimalsx))
                         db1$resampled$y1 <- as.numeric(format(db1$resampled$y1, digits = 2, nsmall = info$decimalsy, trim = F, scientific = info$scientific, width = info$decimalsy))
                         db1$resampled$sy1 <- as.numeric(format(db1$resampled$sy1, digits = 2, nsmall = info$decimalsy, trim = F, scientific = info$scientific, width = info$decimalsy))
                       } else {
                         averaged <- sapply(1:w, function(p) average(p, x = x, y1 = db1$original$y1, y2 = NULL, y3 = NULL, sy1 = NULL, sy2 = NULL, sy3 = NULL, tol = tolerance, w = w, s = inputs$step, second = F, sigmas = F), simplify = T)
                         db1$resampled <- na.omit(data.frame(x1 = averaged[1,], y1 = averaged[2,], sy1 = rep(1, length(averaged[1,]))))
                         db1$resampled$x1 <- as.numeric(format(db1$resampled$x1, digits = 2, nsmall = info$decimalsx, trim = F, scientific = F, width = info$decimalsx))
                         db1$resampled$y1 <- as.numeric(format(db1$resampled$y1, digits = 2, nsmall = info$decimalsy, trim = F, scientific = info$scientific, width = info$decimalsy))
                       }
                     } else {
                       if (input$sigmas) {
                         averaged <- sapply(1:w, function(p) average(p, x = x, y1 = db1$original$y1, y2 = db1$original$y2, y3 = db1$original$y3, sy1 = db1$original$sy1, sy2 = db1$original$sy2, sy3 = db1$original$sy3, tol = tolerance, w = w, s = inputs$step, second = F, sigmas = T), simplify = T)
                         db1$resampled <- na.omit(data.frame(x1 = averaged[1,], y1 = averaged[2,], y2 = averaged[3,], y3 = averaged[4,], sy1 = averaged[5,], sy2 = averaged[6,], sy3 = averaged[7,]))
                         db1$resampled$x1 <- as.numeric(format(db1$resampled$x1, digits = 2, nsmall = info$decimalsx, trim = F, scientific = F, width = info$decimalsx))
                         db1$resampled$y1 <- as.numeric(format(db1$resampled$y1, digits = 2, nsmall = info$decimalsy, trim = F, scientific = info$scientific, width = info$decimalsy))
                         db1$resampled$y2 <- as.numeric(format(db1$resampled$y2, digits = 2, nsmall = info$decimalsy, trim = F, scientific = info$scientific, width = info$decimalsy))
                         db1$resampled$y3 <- as.numeric(format(db1$resampled$y3, digits = 2, nsmall = info$decimalsy, trim = F, scientific = info$scientific, width = info$decimalsy))
                         db1$resampled$sy1 <- as.numeric(format(db1$resampled$sy1, digits = 2, nsmall = info$decimalsy, trim = F, scientific = info$scientific, width = info$decimalsy))
                         db1$resampled$sy2 <- as.numeric(format(db1$resampled$sy2, digits = 2, nsmall = info$decimalsy, trim = F, scientific = info$scientific, width = info$decimalsy))
                         db1$resampled$sy3 <- as.numeric(format(db1$resampled$sy3, digits = 2, nsmall = info$decimalsy, trim = F, scientific = info$scientific, width = info$decimalsy))
                       } else {
                         averaged <- sapply(1:w, function(p) average(p, x = x, y1 = db1$original$y1, y2 = db1$original$y2, y3 = db1$original$y3, sy1 = NULL, sy2 = NULL, sy3 = NULL, tol = tolerance, w = w, s = inputs$step, second = F, sigmas = F), simplify = T)
                         db1$resampled <- na.omit(data.frame(x1 = averaged[1,], y1 = averaged[2,], y2 = averaged[3,], y3 = averaged[4,], sy1 = rep(1, length(averaged[1,])), sy2 = rep(1, length(averaged[1,])), sy3 = rep(1, length(averaged[1,]))))
                         db1$resampled$x1 <- as.numeric(format(db1$resampled$x1, digits = 2, nsmall = info$decimalsx, trim = F, scientific = F, width = info$decimalsx))
                         db1$resampled$y1 <- as.numeric(format(db1$resampled$y1, digits = 2, nsmall = info$decimalsy, trim = F, scientific = info$scientific, width = info$decimalsy))
                         db1$resampled$y2 <- as.numeric(format(db1$resampled$y2, digits = 2, nsmall = info$decimalsy, trim = F, scientific = info$scientific, width = info$decimalsy))
                         db1$resampled$y3 <- as.numeric(format(db1$resampled$y3, digits = 2, nsmall = info$decimalsy, trim = F, scientific = info$scientific, width = info$decimalsy))
                       }
                     }
                   })
      if (input$tunits == 1) {
        db1$resampled$x2 <- mjd2week(db1$resampled$x1)
        db1$resampled$x3 <- mjd2year(db1$resampled$x1)
      } else if (input$tunits == 2) {
        db1$resampled$x2 <- db1$resampled$x1
        db1$resampled$x3 <- week2year(db1$resampled$x1)
        db1$resampled$x1 <- week2mjd(db1$resampled$x1)
      } else if (input$tunits == 3) {
        db1$resampled$x3 <- db1$resampled$x1
        db1$resampled$x2 <- year2week(db1$resampled$x1)
        db1$resampled$x1 <- year2mjd(db1$resampled$x1)
      }
      info$db1 <- "resampled"
      db1$resampled$status1 <- db1$resampled$status2 <- db1$resampled$status3 <- rep(T, length(db1$resampled$x1))
    } else {
      info$db1 <- "original"
      updateTextInput(session, inputId = "step", value = "")
      info$step <- NULL
      info$stepUnit <- NULL
      showNotification(HTML("The resampling period is not valid.<br>Check input value."), action = NULL, duration = 10, closeButton = T, id = "bad_window", type = "error", session = getDefaultReactiveDomain())
    }
    if (input$tunits == 1) {
      info$samplingRaw[1] <- min(diff(db1[[info$db1]]$x1,1))
      info$samplingRaw[2] <- info$samplingRaw[1]/7
      info$samplingRaw[3] <- info$samplingRaw[1]/daysInYear
    } else if (input$tunits == 2) {
      info$samplingRaw[2] <- min(diff(db1[[info$db1]]$x2,1))
      info$samplingRaw[1] <- info$samplingRaw[2]*7
      info$samplingRaw[3] <- info$samplingRaw[1]/daysInYear
    } else if (input$tunits == 3) {
      info$samplingRaw[3] <- min(diff(db1[[info$db1]]$x3,1))
      info$samplingRaw[1] <- info$samplingRaw[3]*daysInYear
      info$samplingRaw[2] <- info$samplingRaw[1]/7
    }
  }, priority = 6)

  observeEvent(c(inputs$step2, info$redo_step2), {
    req(db2$original)
    removeNotification("bad_window")
    if (nchar(input$step2) > 0 && is.na(inputs$step2)) {
      info$step2 <- NULL
      showNotification(HTML("The resampling period of the secondary series is not numeric.<br>Check input value."), action = NULL, duration = 10, closeButton = T, id = "bad_window", type = "error", session = getDefaultReactiveDomain())
    } else if (isTruthy(inputs$step2)) {
      info$step2 <- inputs$step2
    } else {
      info$db2 <- "original"
      updateTextInput(session, inputId = "step2", value = "")
      info$step2 <- NULL
      if (input$optionSecondary > 1) {
        info$last_optionSecondary <- 1
        updateRadioButtons(session, inputId = "optionSecondary", label = NULL, selected = 1)
      }
      req(info$stop)
    }
    if (isTruthy(inputs$step2) && abs(inputs$step2 / min(diff(db2[[info$db2]][[paste0("x",input$tunits)]],1)) - 1) < 1/4) req(info$stop)
    if (messages > 0) cat(file = stderr(), mySession, "Averaging secondary series", "\n")
    if (input$optionSecondary > 1) {
      if (input$fitType == 2) {
        info$run <- NULL
        trans$res <- NULL
        trans$reserror <- NULL
        trans$results <- NULL
        trans$mod <- NULL
        trans$kalman <- NULL
        trans$equation <- NULL
        trans$ordinate <- NULL
        trans$filter <- NULL
        trans$filterRes <- NULL
      }
      trans$midas_vel <- NULL
      trans$midas_all <- NULL
      info$points <- NULL
      info$log <- NULL
      trans$mle <- F
      trans$verif <- NULL
      trans$pattern <- NULL
      if (isTruthy(input$correct_waveform)) {
        updateCheckboxInput(session, inputId = "correct_waveform", value = F)
      }
      updateTextInput(session, "short_period", value = "")
      updateTextInput(session, "ObsError", value = "")
    }
    if (input$tunits == 1) {
      x <- db2$original$x1
    } else if (input$tunits == 2) {
      x <- db2$original$x2
    } else if (input$tunits == 3) {
      x <- db2$original$x3
    }
    db2$resampled <- NULL
    if (inputs$step2 > min(diff(x,1)) && inputs$step2 <= (max(x) - min(x))/2) {
      tolerance <- min(diff(x,1))/3
      info$step2 <- inputs$step2
      withProgress(message = 'Averaging the secondary series.',
                   detail = 'This may take a while ...', value = 0, {
                     w <- as.integer((max(x) - min(x))/inputs$step2)
                     if (info$format == 4) {
                       if (input$sigmas) {
                         averaged <- sapply(1:w, function(p) average(p, x = x, y1 = db2$original$y1, y2 = NULL, y3 = NULL, sy1 = db2$original$sy1, sy2 = NULL, sy3 = NULL, tol = tolerance, w = w, s = inputs$step2, second = T, sigmas = T), simplify = T)
                         db2$resampled <- na.omit(data.frame(x1 = averaged[1,], y1 = averaged[2,], sy1 = averaged[3,]))
                         db2$resampled$x1 <- as.numeric(format(db2$resampled$x1, nsmall = info$decimalsx, trim = F, scientific = F, width = info$decimalsx))
                         # db2$resampled$y1 <- as.numeric(formatting(db2$resampled$y1,0))
                         # db2$resampled$sy1 <- as.numeric(formatting(db2$resampled$sy1,0))
                       } else {
                         averaged <- sapply(1:w, function(p) average(p, x = x, y1 = db2$original$y1, y2 = NULL, y3 = NULL, sy1 = NULL, sy2 = NULL, sy3 = NULL, tol = tolerance, w = w, s = inputs$step2, second = T, sigmas = F), simplify = T)
                         db2$resampled <- na.omit(data.frame(x1 = averaged[1,], y1 = averaged[2,], sy1 = rep(1, length(averaged[1,]))))
                         db2$resampled$x1 <- as.numeric(format(db2$resampled$x1, nsmall = info$decimalsx, trim = F, scientific = F, width = info$decimalsx))
                         # db2$resampled$y1 <- as.numeric(formatting(db2$resampled$y1,0))
                       }
                     } else {
                       if (input$sigmas) {
                         averaged <- sapply(1:w, function(p) average(p, x = x, y1 = db2$original$y1, y2 = db2$original$y2, y3 = db2$original$y3, sy1 = db2$original$sy1, sy2 = db2$original$sy2, sy3 = db2$original$sy3, tol = tolerance, w = w, s = inputs$step2, second = T, sigmas = T), simplify = T)
                         db2$resampled <- na.omit(data.frame(x1 = averaged[1,], y1 = averaged[2,], y2 = averaged[3,], y3 = averaged[4,], sy1 = averaged[5,], sy2 = averaged[6,], sy3 = averaged[7,]))
                         db2$resampled$x1 <- as.numeric(format(db2$resampled$x1, nsmall = info$decimalsx, trim = F, scientific = F, width = info$decimalsx))
                         # db2$resampled$y1 <- as.numeric(formatting(db2$resampled$y1,0))
                         # db2$resampled$y2 <- as.numeric(formatting(db2$resampled$y2,0))
                         # db2$resampled$y3 <- as.numeric(formatting(db2$resampled$y3,0))
                         # db2$resampled$sy1 <- as.numeric(formatting(db2$resampled$sy1,0))
                         # db2$resampled$sy2 <- as.numeric(formatting(db2$resampled$sy2,0))
                         # db2$resampled$sy3 <- as.numeric(formatting(db2$resampled$sy3,0))
                       } else {
                         averaged <- sapply(1:w, function(p) average(p, x = x, y1 = db2$original$y1, y2 = db2$original$y2, y3 = db2$original$y3, sy1 = NULL, sy2 = NULL, sy3 = NULL, tol = tolerance, w = w, s = inputs$step2, second = T, sigmas = F), simplify = T)
                         db2$resampled <- na.omit(data.frame(x1 = averaged[1,], y1 = averaged[2,], y2 = averaged[3,], y3 = averaged[4,], sy1 = rep(1, length(averaged[1,])), sy2 = rep(1, length(averaged[1,])), sy3 = rep(1, length(averaged[1,]))))
                         db2$resampled$x1 <- as.numeric(format(db2$resampled$x1, nsmall = info$decimalsx, trim = F, scientific = F, width = info$decimalsx))
                         # db2$resampled$y1 <- as.numeric(formatting(db2$resampled$y1,0))
                         # db2$resampled$y2 <- as.numeric(formatting(db2$resampled$y2,0))
                         # db2$resampled$y3 <- as.numeric(formatting(db2$resampled$y3,0))
                       }
                     }
                   })
      if (input$tunits == 1) {
        db2$resampled$x2 <- mjd2week(db2$resampled$x1)
        db2$resampled$x3 <- mjd2year(db2$resampled$x1)
        info$samplingRaw2[1] <- min(diff(db2$resampled$x1,1))
        info$samplingRaw2[2] <- info$samplingRaw2[1]/7
        info$samplingRaw2[3] <- info$samplingRaw2[1]/daysInYear
      } else if (input$tunits == 2) {
        db2$resampled$x2 <- db2$resampled$x1
        db2$resampled$x3 <- week2year(db2$resampled$x1)
        db2$resampled$x1 <- week2mjd(db2$resampled$x1)
        info$samplingRaw2[2] <- min(diff(db2$resampled$x2,1))
        info$samplingRaw2[1] <- info$samplingRaw2[2]*7
        info$samplingRaw2[3] <- info$samplingRaw2[1]/daysInYear
      } else if (input$tunits == 3) {
        db2$resampled$x3 <- db2$resampled$x1
        db2$resampled$x2 <- year2week(db2$resampled$x1)
        db2$resampled$x1 <- year2mjd(db2$resampled$x1)
        info$samplingRaw2[3] <- min(diff(db2$resampled$x3,1))
        info$samplingRaw2[1] <- info$samplingRaw2[3]*daysInYear
        info$samplingRaw2[2] <- info$samplingRaw2[1]/7
      }
      info$db2 <- "resampled"
    } else {
      info$db2 <- "original"
      info$step2 <- NULL
      if (inputs$step2 != min(diff(x,1))) {
        updateTextInput(session, inputId = "step2", value = "")
        showNotification(HTML("The XXX resampling period of the secondary series is not valid.<br>Check input value."), action = NULL, duration = 10, closeButton = T, id = "bad_window", type = "error", session = getDefaultReactiveDomain())
      }
    }
  }, priority = 6)

  # Observe secondary series ####
  observeEvent(input$series2, {
    req(db1$original)
    file$secondary <- isolate(input$series2)
    url$file2 <- url$station2 <- NULL
    url$server2 <- ""
    if (isTruthy(url$logfile2)) {
      url$logfile2 <- info$log <- NULL
      session$sendCustomMessage("log", "")
    }
    updateSelectInput(inputId = "server2", selected = "")
    updateSelectInput(inputId = "product2", selected = "")
    updateCheckboxInput(session, inputId = "fullSeries", value = F)
    updateCheckboxInput(session, inputId = "sameScale", value = F)
    updateCheckboxInput(session, inputId = "same_axis", value = F)
    updateCheckboxInput(session, inputId = "ne", value = F)
    if (length(input$series2$datapath) == 1) {
      header <- readLines(input$series2$datapath, n = 1)
      if (grepl(".tenv3$", file$secondary$name, perl = T) && grepl("site YYMMMDD ", header, fixed = T)) {
        updateRadioButtons(inputId = "format2", selected = 3)
        info$format2 <- 3
      } else if (grepl(".pos$", file$secondary$name, perl = T) && grepl("PBO Station Position Time Series", header, fixed = T)) {
        updateRadioButtons(inputId = "format2", selected = 2)
        info$format2 <- 2
      } else if (grepl(".pos$", file$secondary$name, perl = T) && grepl("GeoCSV", header, fixed = T)) {
        updateRadioButtons(inputId = "format2", selected = 1)
        info$format2 <- 1
        url$server2 <- "EARTHSCOPE"
        url$file2 <- file$secondary
      } else if (grepl(".enu$", file$secondary$name, perl = T) && grepl("SPOTGINS SOLUTION [POSITION]", header, fixed = T)) {
        updateRadioButtons(inputId = "format2", selected = 1)
        info$format2 <- 1
        info$product2 <- "SPOTGINS"
      } else if (grepl(".PLH$", file$secondary$name, perl = T) && grepl("^DGFI-TUM:", header, perl = T)) {
        updateRadioButtons(inputId = "format2", selected = 1)
        info$format2 <- 1
        url$server2 <- "SIRGAS"
        url$file2 <- file$secondary
      } else if (grepl(".series$", file$secondary$name, perl = T) && grepl(pattern = "\\.00\\s{2}\\d{4}\\s{1,2}\\d{1,2}\\s{1,2}\\d{1,2}\\s{1,2}\\d{1,2}\\s{1,2}\\d{1,2}\\s{1,2}\\d{1,2}$", header, perl = T)) {
        info$format2 <- 1
        url$server2 <- "JPL"
        url$file2 <- file$secondary
      } else if (grepl("_igs.plh$", file$secondary$name, perl = T)) {
        updateRadioButtons(inputId = "format2", selected = 1)
        url$server2 <- "IGS"
        url$file2 <- file$secondary
      } else if (grepl(".stcd.", file$secondary$name, perl = T)) {
        updateRadioButtons(inputId = "format2", selected = 1)
        url$server2 <- "DORIS"
        url$file2 <- file$secondary
      } else if (as.numeric(input$format) < 4) {
        updateRadioButtons(inputId = "format2", selected = 1)
        info$format2 <- 1
      } else {
        updateRadioButtons(inputId = "format2", selected = 4)
        info$format2 <- 4
        disable("format2")
      }
    } else {
      if (as.numeric(input$format) == 4) {
        updateRadioButtons(inputId = "format2", selected = 4)
        info$format2 <- 4
        disable("format2")
      }
    }
    if (input$optionSecondary > 0) {
      info$db1 <- "original"
      db2$original <- db2$resampled <- NULL
      info$last_optionSecondary <- 0
      updateRadioButtons(session, inputId = "optionSecondary", selected = 0)
      updateSelectInput(session, inputId = "separator2", selected = 1)
    }
  }, priority = 8)

  observeEvent(input$format2, {
    req(db1[[info$db1]])
    if (input$optionSecondary > 0) {
      if (messages > 4) cat(file = stderr(), mySession, "From: observe secondary format\n")
      db2$original <- db2$resampled <- NULL
      digest(2)
    }
  }, priority = 6)

  observeEvent(input$separator2, {
    req(db1[[info$db1]])
    if (input$optionSecondary > 0) {
      if (messages > 4) cat(file = stderr(), mySession, "From: observe secondary separator\n")
      db2$original <- db2$resampled <- NULL
      digest(2)
    }
  }, priority = 6)

  observeEvent(input$optionSecondary, {
    req(db1[[info$db1]])
    if (input$optionSecondary > 0 && !isTruthy(db2[[info$db2]])) {
      if (messages > 4) cat(file = stderr(), mySession, "From: observe secondary option\n")
      db2$original <- db2$resampled <- NULL
      digest(2)
    }
    req(db2[[info$db2]])
    if (messages > 0) {
      if (input$optionSecondary == 0) {
        cat(file = stderr(), mySession, "Hidding secondary series", "\n")
        ids_info <- file$id1
      } else if (input$optionSecondary == 1) {
        cat(file = stderr(), mySession, "Showing secondary series", "\n")
        ids_info <- paste(file$id1,file$id2, sep = " & ")
      } else if (input$optionSecondary == 2) {
        cat(file = stderr(), mySession, "Subtracting secondary series", "\n")
        ids_info <- paste(file$id1,file$id2, sep = " - ")
      } else if (input$optionSecondary == 3) {
        cat(file = stderr(), mySession, "Averaging with secondary series", "\n")
        ids_info <- paste(file$id1,file$id2, sep = " : ")
      } else if (input$optionSecondary == 4) {
        cat(file = stderr(), mySession, "Merging primary and secondary series", "\n")
        ids_info <- paste(file$id1,file$id2, sep = " + ")
      }
    }
    # merging primary and secondary series
    if (input$optionSecondary > 1) {
      if (info$db1 == "merged") {
        if (isTruthy(db1$resampled)) {
          type1 <- "resampled"
        } else {
          type1 <- "original"
        }
      } else {
        type1 <- info$db1
      }
      table1 <- db1[[type1]]
      table2 <- db2[[info$db2]]
      if (input$format < 4 && isTruthy(trans$plate) && input$eulerType == 2 && length(trans$plate) == 3 && all(is.numeric(trans$plate))) {
        table1$y1 <- table1$y1 - trans$plate[1]*(table1[[paste0("x",input$tunits)]] - median(table1[[paste0("x",input$tunits)]][table1$status1], na.rm = T)) - median(table1$y1, na.rm = T)
        table1$y2 <- table1$y2 - trans$plate[2]*(table1[[paste0("x",input$tunits)]] - median(table1[[paste0("x",input$tunits)]][table1$status2], na.rm = T)) - median(table1$y2, na.rm = T)
      }
      if (isTruthy(trans$gia) && input$giaType == 2 && all(is.numeric(trans$gia))) {
        if (input$format == 4) {
          table1$y1 <- table1$y1 - trans$gia[3]*(table1[[paste0("x",input$tunits)]] - median(table1[[paste0("x",input$tunits)]][table1$status1], na.rm = T)) - median(table1$y1, na.rm = T)
        } else {
          table1$y3 <- table1$y3 - trans$gia[3]*(table1[[paste0("x",input$tunits)]] - median(table1[[paste0("x",input$tunits)]][table1$status3], na.rm = T)) - median(table1$y3, na.rm = T)
        }
      }
      if (isTruthy(input$ne)) {
        table2y_tmp <- table2$y2
        table2sy_tmp <- table2$sy2
        table2$y2 <- table2$y1
        table2$sy2 <- table2$sy1
        table2$y1 <- table2y_tmp
        table2$sy1 <- table2sy_tmp
      }
      if (input$format2 < 4 && isTruthy(trans$plate2) && input$eulerType == 2 && length(trans$plate2) == 3 && all(is.numeric(trans$plate2))) {
        table2$y1 <- table2$y1 - trans$plate2[1]*(table2[[paste0("x",input$tunits)]] - median(table2[[paste0("x",input$tunits)]], na.rm = T)) - median(table2$y1, na.rm = T)
        table2$y2 <- table2$y2 - trans$plate2[2]*(table2[[paste0("x",input$tunits)]] - median(table2[[paste0("x",input$tunits)]], na.rm = T)) - median(table2$y2, na.rm = T)
      }
      if (isTruthy(trans$gia2) && input$giaType == 2 && all(is.numeric(trans$gia2))) {
        if (input$format == 4) {
          table2$y1 <- table2$y1 - trans$gia2[3]*(table2[[paste0("x",input$tunits)]] - median(table2[[paste0("x",input$tunits)]], na.rm = T)) - median(table2$y1, na.rm = T)
        } else {
          table2$y3 <- table2$y3 - trans$gia2[3]*(table2[[paste0("x",input$tunits)]] - median(table2[[paste0("x",input$tunits)]], na.rm = T)) - median(table2$y3, na.rm = T)
        }
      }
      # computing the shift period between the primary and secondary series
      delta <- computeTimeShift(table1$x1,table2$x1)
      if (isTruthy(delta) && is.numeric(delta) && delta <= info$samplingRaw[1] && abs(delta) > 0) {
        table2$x1 <- table2$x1 + delta
        showNotification(paste0("The time axis of the secondary series has been shifted by a constant ",delta," days"), action = NULL, duration = 10, closeButton = T, id = "time_shift", type = "warning", session = getDefaultReactiveDomain())
        if (abs(delta) == info$sampling/2) {
          showNotification("The time shift of the secondary series is equal to half the sampling of the primary series and the direction of the sifht is ambiguous.", action = NULL, duration = 15, closeButton = T, id = "ambiguous_shift", type = "error", session = getDefaultReactiveDomain())
        }
        if (input$optionSecondary == 4) {
          table2$x2 <- mjd2week(table2$x1)
          table2$x3 <- mjd2year(table2$x1)
        }
      }  
      # merging the primary and secondary series
      table2$status1 <- table2$status2 <- table2$status3 <- NULL
      if (input$optionSecondary == 2) {
        if (info$format == 4) {
          table_common <- data.frame(within(merge(table1,table2,by = "x1"), {
            x2 <- x2.x
            x3 <- x3.x
            y1 <- y1.x - y1.y * inputs$scaleFactor
            sy1 <- sqrt(sy1.x^2 + (sy1.y * inputs$scaleFactor)^2)
            status1 <- status1
          })[,c("x1","x2","x3","y1","sy1","status1")])
          # table_common$y1 <- as.numeric(formatting(table_common$y1,1))
          # table_common$sy1 <- as.numeric(formatting(table_common$sy1,1))
        } else {
          table_common <- data.frame(within(merge(table1,table2,by = "x1"), {
            if (info$format2 == 4) {
              x2 <- x2.x
              x3 <- x3.x
              y1 <- y1.x - y1.y * inputs$scaleFactor
              y2 <- y2 - y1.y * inputs$scaleFactor
              y3 <- y3 - y1.y * inputs$scaleFactor
              sy1 <- sqrt(sy1.x^2 + (sy1.y * inputs$scaleFactor)^2)
              sy2 <- sqrt(sy2^2 + (sy1.y * inputs$scaleFactor)^2)
              sy3 <- sqrt(sy3^2 + (sy1.y * inputs$scaleFactor)^2)
              status1 <- status1
              status2 <- status2
              status3 <- status3
            } else {
              x2 <- x2.x
              x3 <- x3.x
              y1 <- y1.x - y1.y * inputs$scaleFactor
              y2 <- y2.x - y2.y * inputs$scaleFactor
              y3 <- y3.x - y3.y * inputs$scaleFactor
              sy1 <- sqrt(sy1.x^2 + (sy1.y * inputs$scaleFactor)^2)
              sy2 <- sqrt(sy2.x^2 + (sy2.y * inputs$scaleFactor)^2)
              sy3 <- sqrt(sy3.x^2 + (sy3.y * inputs$scaleFactor)^2)
              status1 <- status1
              status2 <- status2
              status3 <- status3
            }
          })[,c("x1","x2","x3","y1","y2","y3","sy1","sy2","sy3","status1","status2","status3")])
        }
      } else if (input$optionSecondary == 3) {
        if (info$format == 4) {
          table_common <- data.frame(within(merge(table1,table2,by = "x1"), {
            x2 <- x2.x
            x3 <- x3.x
            y1 <- (y1.x + y1.y * inputs$scaleFactor) / 2
            sy1 <- sqrt(sy1.x^2 + (sy1.y * inputs$scaleFactor)^2)
            status1 <- status1
          })[,c("x1","x2","x3","y1","sy1","status1")])
        } else {
          table_common <- data.frame(within(merge(table1,table2,by = "x1"), {
            if (info$format2 == 4) {
              x2 <- x2.x
              x3 <- x3.x
              y1 <- (y1.x + y1.y * inputs$scaleFactor) / 2
              y2 <- (y2 + y1.y * inputs$scaleFactor) / 2
              y3 <- (y3 + y1.y * inputs$scaleFactor) / 2
              sy1 <- sqrt(sy1.x^2 + (sy1.y * inputs$scaleFactor)^2)
              sy2 <- sqrt(sy2^2 + (sy1.y * inputs$scaleFactor)^2)
              sy3 <- sqrt(sy3^2 + (sy1.y * inputs$scaleFactor)^2)
              status1 <- status1
              status2 <- status2
              status3 <- status3
            } else {
              x2 <- x2.x
              x3 <- x3.x
              y1 <- (y1.x + y1.y * inputs$scaleFactor) / 2
              y2 <- (y2.x + y2.y * inputs$scaleFactor) / 2
              y3 <- (y3.x + y3.y * inputs$scaleFactor) / 2
              sy1 <- sqrt(sy1.x^2 + (sy1.y * inputs$scaleFactor)^2)
              sy2 <- sqrt(sy2.x^2 + (sy2.y * inputs$scaleFactor)^2)
              sy3 <- sqrt(sy3.x^2 + (sy3.y * inputs$scaleFactor)^2)
              status1 <- status1
              status2 <- status2
              status3 <- status3
            }
          })[,c("x1","x2","x3","y1","y2","y3","sy1","sy2","sy3","status1","status2","status3")])
        }
      } else if (input$optionSecondary == 4) {
        table2$status1 <- T
        table1$y1 <- ifelse(table1$status1 == T, table1$y1, NA)
        table1$sy1 <- ifelse(table1$status1 == T, table1$sy1, NA)
        if (info$format == 4) {
          table_common <- data.frame(within(merge(table1, table2, by = "x1", all = T), {
            x2 <- ifelse(is.na(x2.x),x2.y,x2.x)
            x3 <- ifelse(is.na(x3.x),x3.y,x3.x)
            y1 <- ifelse(is.na(y1.x),y1.y * inputs$scaleFactor,y1.x)
            sy1 <- ifelse(is.na(sy1.x),sy1.y * inputs$scaleFactor,sy1.x)
            status1 <- ifelse(is.na(as.numeric(y1)),NA,T)
          })[,c("x1","x2","x3","y1","sy1","status1")])
        } else {
          table2$status2 <- table2$status3 <- T
          table1$y2 <- ifelse(table1$status1 == T, table1$y2, NA)
          table1$y3 <- ifelse(table1$status1 == T, table1$y3, NA)
          table1$sy2 <- ifelse(table1$status1 == T, table1$sy2, NA)
          table1$sy3 <- ifelse(table1$status1 == T, table1$sy3, NA)
          table_common <- data.frame(within(merge(table1, table2, by = "x1", all = T), {
            if (info$format2 == 4) {
              x2 <- ifelse(is.na(x2.x),x2.y,x2.x)
              x3 <- ifelse(is.na(x3.x),x3.y,x3.x)
              y1 <- ifelse(is.na(y1.x),y1.y * inputs$scaleFactor,y1.x)
              y2 <- ifelse(is.na(y2.x),y1.y * inputs$scaleFactor,y2.x)
              y3 <- ifelse(is.na(y3.x),y1.y * inputs$scaleFactor,y3.x)
              sy1 <- ifelse(is.na(sy1.x),sy1.y * inputs$scaleFactor,sy1.x)
              sy2 <- ifelse(is.na(sy2.x),sy1.y * inputs$scaleFactor,sy2.x)
              sy3 <- ifelse(is.na(sy3.x),sy1.y * inputs$scaleFactor,sy3.x)
              status1 <- ifelse(is.na(as.numeric(y1)),NA,T)
              status2 <- ifelse(is.na(as.numeric(y2)),NA,T)
              status3 <- ifelse(is.na(as.numeric(y3)),NA,T)
            } else {
              x2 <- ifelse(is.na(x2.x),x2.y,x2.x)
              x3 <- ifelse(is.na(x3.x),x3.y,x3.x)
              y1 <- ifelse(is.na(y1.x),y1.y * inputs$scaleFactor,y1.x)
              y2 <- ifelse(is.na(y2.x),y2.y * inputs$scaleFactor,y2.x)
              y3 <- ifelse(is.na(y3.x),y3.y * inputs$scaleFactor,y3.x)
              sy1 <- ifelse(is.na(sy1.x),sy1.y * inputs$scaleFactor,sy1.x)
              sy2 <- ifelse(is.na(sy2.x),sy2.y * inputs$scaleFactor,sy2.x)
              sy3 <- ifelse(is.na(sy3.x),sy3.y * inputs$scaleFactor,sy3.x)
              status1 <- ifelse(is.na(as.numeric(y1)),NA,T)
              status2 <- ifelse(is.na(as.numeric(y1)),NA,T)
              status3 <- ifelse(is.na(as.numeric(y1)),NA,T)
            }
          })[,c("x1","x2","x3","y1","y2","y3","sy1","sy2","sy3","status1","status2","status3")])
        }
      }
      numValid1 <- sum(table_common$status1, na.rm = T)
      if (input$format != 4 && input$format2 != 4) {
        numValid2 <- sum(table_common$status2, na.rm = T)
        numValid3 <- sum(table_common$status3, na.rm = T)
        if (numValid1 == numValid2 && numValid1 == numValid3) {
          atLeast <- " "
          numValid <- numValid1
        } else {
          atLeast <- " at least "
          numValid <- min(numValid1,numValid2,numValid3)
        }
      } else {
        atLeast <- " "
        numValid <- numValid1
      }
      if (input$optionSecondary == 4) {
        showNotification(paste0("There are",atLeast,numValid," epochs together between the primary and secondary series (after excluding removed points)"), action = NULL, duration = 10, closeButton = T, id = "in_common", type = "warning", session = getDefaultReactiveDomain())        
      } else {
        showNotification(paste0("There are",atLeast,numValid," epochs in common between the primary and secondary series (after excluding removed points)"), action = NULL, duration = 10, closeButton = T, id = "in_common", type = "warning", session = getDefaultReactiveDomain())
      }
      if (numValid > 0) {
        # recovering past merged values if possible
        if (input$optionSecondary > 1 && input$optionSecondary < 4 && info$last_optionSecondary < 2) {
          if (isTruthy(db1$merged$status1) && length(db1$merged$status1) == length(table_common$status1)) {
            table_common$status1 <- table_common$status1 + db1$merged$status1 > 1
          }
          if (isTruthy(db1$merged$status2) && length(db1$merged$status2) == length(table_common$status2)) {
            table_common$status2 <- table_common$status2 + db1$merged$status2 > 1
          }
          if (isTruthy(db1$merged$status3) && length(db1$merged$status3) == length(table_common$status3)) {
            table_common$status3 <- table_common$status3 + db1$merged$status3 > 1
          }
          if (isTruthy(db1$merged$status1) && length(db1$merged$mod1) == length(table_common$status1)) {
            table_common$mod1 <- db1$merged$mod1
            table_common$res1 <- db1$merged$res1
            table_common$reserror1 <- db1$merged$reserror1
          } else {
            trans$plotInfo1$merged <- NULL
          }
          if (isTruthy(db1$merged$status2) && length(db1$merged$mod2) == length(table_common$status2)) {
            table_common$mod2 <- db1$merged$mod2
            table_common$res2 <- db1$merged$res2
            table_common$reserror2 <- db1$merged$reserror2
          } else {
            trans$plotInfo2$merged <- NULL
          }
          if (isTruthy(db1$merged$status3) && length(db1$merged$mod3) == length(table_common$status3)) {
            table_common$mod3 <- db1$merged$mod3
            table_common$res3 <- db1$merged$res3
            table_common$reserror3 <- db1$merged$reserror3
          } else {
            trans$plotInfo2$merged <- NULL
          }
        }
        db1$merged <- table_common
        info$db1 <- "merged"
        rm(table_common,table1,table2)
        if (input$eulerType == 1) {
          updateRadioButtons(session, inputId = "eulerType", selected = 0)
        }
        if (input$giaType == 1) {
          updateRadioButtons(session, inputId = "giaType", selected = 0)
        }
      } else {
        info$last_optionSecondary <- 1
        updateRadioButtons(session, inputId = "optionSecondary", selected = 1)
      }
    } else if (info$last_optionSecondary > 1) {
      if (isTruthy(inputs$step) && isTruthy(db1$resampled$x1)) {
        info$db1 <- "resampled"
      } else {
        info$db1 <- "original"
      }
    }
    # Updating plot ranges
    if (input$optionSecondary > 1 || info$last_optionSecondary > 1) {
      # setting new axis limits
      if (input$tab == 4) {
        info$minx <- min(db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status1)],
                         db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status2)],
                         db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status3)])
        info$maxx <- max(db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status1)],
                         db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status2)],
                         db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status3)])
      } else {
        info$minx <- suppressWarnings(min(db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]][[paste0("status", input$tab)]])]))
        info$maxx <- suppressWarnings(max(db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]][[paste0("status", input$tab)]])]))
      }
      ranges$x1 <- c(info$minx, info$maxx)
    }
    # Updating station IDs
    updateTextInput(session, inputId = "ids", value = ids_info)
    if (input$fitType == 2 && length(trans$mod) > 0 && length(trans$res) > 0) {
      info$run <- F
      trans$mod <- trans$mod0 <- NULL
      trans$res <- trans$res0 <- NULL
      trans$kalman <- trans$kalman0 <- NULL
      trans$kalman_unc <- trans$kalman_unc0 <- NULL
    }
    updateTextInput(session, "ObsError", value = "")
    updateTextInput(session, "waveformPeriod", value = "")
    if (isTruthy(input$correct_waveform)) {
      updateCheckboxInput(session, inputId = "correct_waveform", value = F)
    }
    info$last_optionSecondary <- input$optionSecondary
    # providing remote secondary series
    output$fileSeries2 <- renderUI({
      if (input$optionSecondary > 0 && isTruthy(url$station2) && isTruthy(file$secondary$newname)) {
        tags$a(href = sub(pattern = "www/", replacement = "", x = file$secondary$newpath), "Show secondary series file", title = "Open the file of the secondary series in a new tab", target = "_blank", download = file$secondary$newname)
      } else {
        NULL
      }
    })
  }, priority = 6)
  observeEvent(c(input$series2, input$separator2, input$format2, input$optionSecondary), {
    req(db1[[info$db1]])
    if (input$optionSecondary > 0 && !isTruthy(db2[[info$db2]])) {
      info$last_optionSecondary <- 0
      updateRadioButtons(session, inputId = "optionSecondary", selected = 0)
    }
  }, priority = 0)

  # Observe swap ####
  swapClicks <- reactive(input$swap)
  throttledSwap <- throttle(swapClicks, 6000)
  observeEvent(throttledSwap(), {
    req(db1[[info$db1]], db2[[info$db2]])
    if (messages > 0) cat(file = stderr(), mySession, "Swapping primary and secondary series", "\n")
    # axis scale
    if (isTruthy(inputs$scaleFactor)) {
      updateTextInput(session, inputId = "scaleFactor", value = 1/inputs$scaleFactor)
      inputs$scaleFactor <- 1/inputs$scaleFactor
    }
    # plate model
    plate2 <- trans$plate2
    if (isTruthy(trans$plate)) {
      trans$plate2 <- trans$plate
    } else {
      trans$plate2 <- c(0,0,0)
    }
    if (isTruthy(plate2)) {
      trans$plate <- plate2
    } else {
      trans$plate <- c(0,0,0)
    }
    # GIA model
    gia2 <- trans$gia2
    if (isTruthy(trans$gia)) {
      trans$gia2 <- trans$gia
    } else {
      trans$gia2 <- c(0,0,0)
    }
    if (isTruthy(plate2)) {
      trans$gia <- gia2
    } else {
      trans$gia <- c(0,0,0)
    }
    # data base
    infodb1 <- info$db1
    info$db1 <- info$db2
    info$db2 <- infodb1
    db1_tmp <- isolate(list(original = db1$original, resampled = db1$resampled, merged = db1$merged))
    # keeping only if all components are valid
    for (type in names(db1_tmp)) {
      db1[[type]] <- db2[[type]]
      if (isTruthy(db1[[type]]) && !isTruthy(db1[[type]]$status1)) {
        db1[[type]]$status1 <- rep(T, length(db1[[type]]$x1))
        db1[[type]]$status2 <- rep(T, length(db1[[type]]$x2))
        db1[[type]]$status3 <- rep(T, length(db1[[type]]$x3))
      }
      if (input$format < 4) {
        db2[[type]] <- db1_tmp[[type]][db1_tmp[[type]]$status1 %in% T & db1_tmp[[type]]$status2 %in% T & db1_tmp[[type]]$status3 %in% T,]
      } else {
        db2[[type]] <- db1_tmp[[type]][db1_tmp[[type]]$status1 %in% T,]
      }
    }
    rm(db1_tmp)
    if (input$optionSecondary == 1 && isTruthy(input$fullSeries)) {
      ranges$x1 <- range(c(db1[[info$db1]][[paste0("x",input$tunits)]], db2[[info$db2]][[paste0("x",input$tunits)]]), na.rm = T)
    } else {
      ranges$x0 <- ranges$x1 <- range(db1[[info$db1]][[paste0("x",input$tunits)]], na.rm = T)
    }
    ranges$x2 <- NULL
    samplingRaw <- info$samplingRaw
    info$samplingRaw <- info$samplingRaw2
    info$samplingRaw2 <- samplingRaw
    # resampling periods
    step <- isolate(info$step)
    step2 <- isolate(info$step2)
    if (isTruthy(step)) {
      updateTextInput(session, inputId = "step2", value = sprintf("%.*f", info$decimalsx, step))
    } else {
      updateTextInput(session, inputId = "step2", value = "")
    }
    if (isTruthy(step2) && !input$average) {
      updateCheckboxInput(session, inputId = "average", value = T)
      if (isTruthy(step2)) {
        shinyjs::delay(100, updateTextInput(session, inputId = "step", value = sprintf("%.*f", info$decimalsx, step2)))
      } else {
        shinyjs::delay(100, updateTextInput(session, inputId = "step", value = ""))
      }
    } else {
      if (isTruthy(step2)) {
        updateTextInput(session, inputId = "step", value = sprintf("%.*f", info$decimalsx, step2))
      } else {
        updateTextInput(session, inputId = "step", value = "")
      }
    }
    # file names
    file1 <- file$primary
    file2 <- file$secondary
    file$primary <- file2
    file$secondary <- file1
    session$sendCustomMessage("filename", file$primary$name)
    session$sendCustomMessage("filename2", file$secondary$name)
    log1 <- url$logfile
    log2 <- url$logfile2
    url$logfile <- log2
    url$logfile2 <- log1
    # station coordinates
    if ((((isTruthy(inputs$station_x) && isTruthy(inputs$station_y) && isTruthy(inputs$station_z)) && (isTruthy(inputs$station_lat) && isTruthy(inputs$station_lon))) &&
         ((isTruthy(inputs$station_x2) && isTruthy(inputs$station_y2) && isTruthy(inputs$station_z2)) && (isTruthy(inputs$station_lat2) && isTruthy(inputs$station_lon2))))
    ) {
      x1 <- inputs$station_x
      y1 <- inputs$station_y
      z1 <- inputs$station_z
      lat1 <- inputs$station_lat
      lon1 <- inputs$station_lon
      x2 <- inputs$station_x2
      y2 <- inputs$station_y2
      z2 <- inputs$station_z2
      lat2 <- inputs$station_lat2
      lon2 <- inputs$station_lon2
      updateTextInput(session, inputId = "station_x", value = x2)
      updateTextInput(session, inputId = "station_y", value = y2)
      updateTextInput(session, inputId = "station_z", value = z2)
      updateTextInput(session, inputId = "station_lat", value = lat2)
      updateTextInput(session, inputId = "station_lon", value = lon2)
      updateTextInput(session, inputId = "station_x2", value = x1)
      updateTextInput(session, inputId = "station_y2", value = y1)
      updateTextInput(session, inputId = "station_z2", value = z1)
      updateTextInput(session, inputId = "station_lat2", value = lat1)
      updateTextInput(session, inputId = "station_lon2", value = lon1)
    }
    # station IDs
    if (isTruthy(file$id1) && isTruthy(file$id2)) {
      id1 <- file$id1
      id2 <- file$id2
      ids_info <- paste(id2, id1, sep = " & ")
      updateTextInput(session, inputId = "ids", value = ids_info)
    }
  }, priority = 200)

  # Observe ids ####
  observeEvent(c(inputs$ids, input$optionSecondary), {
    req(db1$original)
    update <- 0
    file$id1 <- toupper(trim(strsplit(as.character(inputs$ids), "-|\\&|\\+")[[1]][1]))
    if (!isTruthy(file$id1)) {
      if (isTruthy(url$station)) {
        if (url$server == "LOCAL") {
          file$id1 <- toupper(strsplit(as.character(url$station), "\\.|_|\\s|-|\\(")[[1]][1])
        } else {
          file$id1 <- toupper(url$station)
        }
      } else {
        file$id1 <- toupper(strsplit(as.character(input$series$name), "\\.|_|\\s|-|\\(")[[1]][1])
      }
      update <- 1
    }
    if (length(file$secondary) > 0) {
      file$id2 <- toupper(trim(strsplit(as.character(inputs$ids), "-|\\&|\\+")[[1]][2]))
      if (!isTruthy(file$id2)) {
        if (isTruthy(url$station2)) {
          if (url$server2 == "LOCAL") {
            file$id2 <- toupper(strsplit(as.character(url$station2), "\\.|_|\\s|-|\\(")[[1]][1])
          } else {
            file$id2 <- toupper(url$station2)
          }
        } else {
          if (isTruthy(input$series2$name)) {
            file$id2 <- toupper(strsplit(as.character(input$series2$name), "\\.|_|\\s|-|\\(")[[1]][1])
          }
        }
        update <- 1
      }
    }
    if (update > 0) {
      if (!is.null(file$id2)) {
        if (input$optionSecondary == 0) {
          ids_info <- file$id1
        } else if (input$optionSecondary == 1) {
          ids_info <- paste(file$id1,file$id2, sep = " & ")
        } else if (input$optionSecondary == 2) {
          ids_info <- paste(file$id1,file$id2, sep = " - ")
        } else if (input$optionSecondary == 3) {
          ids_info <- paste(file$id1,file$id2, sep = " : ")
        } else if (input$optionSecondary == 4) {
          ids_info <- paste(file$id1,file$id2, sep = " + ")
        }
      } else {
        ids_info <- file$id1
      }
      updateTextInput(session, inputId = "ids", value = ids_info)
    }
  }, priority = 5)

  # Observe remove fit ####
  # observeEvent(c(input$separator, input$format, inputs$epoch), {
  #   req(trans$res)
  #   if (messages > 0) cat(file = stderr(), mySession, "Deleting fit", "\n")
  #   trans$res <- NULL
  #   trans$reserror <- NULL
  #   trans$results <- NULL
  #   trans$mod <- NULL
  #   trans$kalman <- NULL
  #   trans$equation <- NULL
  #   trans$midas_vel <- NULL
  #   trans$midas_all <- NULL
  #   trans$filter <- NULL
  #   trans$filterRes <- NULL
  #   trans$mle <- F
  #   trans$verif <- NULL
  #   trans$pattern <- NULL
  #   trans$spectra <- NULL
  #   updateTextInput(session, "ObsError", value = "")
  #   updateTextInput(session, "waveformPeriod", value = "")
  #   if (isTruthy(input$correct_waveform)) {
  #     updateCheckboxInput(session, inputId = "correct_waveform", value = F)
  #   }
  #   if (isTruthy(input$model)) {
  #     updateCheckboxGroupInput(session, inputId = "model", label = "", choices = list("Linear","Polynomial","Sinusoidal","Offset","Exponential","Logarithmic"), selected = NULL, inline = T)
  #   }
  #   updateRadioButtons(session, inputId = "fitType", label = NULL, list("None" = 0, "LS" = 1, "KF" = 2), selected = 0, inline = T, choiceNames = NULL, choiceValues = NULL)
  #   updateTextInput(session, "E0", value = "")
  #   updateTextInput(session, "L0", value = "")
  #   if (isTruthy(input$white)) {
  #     updateCheckboxInput(session, inputId = "white", label = NULL, value = F)
  #   }
  #   if (isTruthy(input$flicker)) {
  #     updateCheckboxInput(session, inputId = "flicker", label = NULL, value = F)
  #   }
  #   if (isTruthy(input$randomw)) {
  #     updateCheckboxInput(session, inputId = "randomw", label = NULL, value = F)
  #   }
  #   if (isTruthy(input$powerl)) {
  #     updateCheckboxInput(session, inputId = "powerl", label = NULL, value = F)
  #   }
  # }, priority = 5)

  # Observe fit type ####
  observeEvent(input$fitType, {
    req(db1[[info$db1]])
    if (input$fitType > 0) {
      runjs("
        let element = document.getElementById('fitType');
        element.scrollIntoView({
          behavior: 'smooth'
        });
        ")
    }
    req(trans$res)
    if (messages > 0) cat(file = stderr(), mySession, "Deleting fit", "\n")
    trans$res <- NULL
    trans$reserror <- NULL
    trans$results <- NULL
    trans$mod <- NULL
    trans$kalman <- NULL
    trans$equation <- NULL
    trans$mle <- F
    trans$verif <- NULL
    trans$pattern <- NULL
    if (isTruthy(input$correct_waveform)) {
      updateCheckboxInput(session, inputId = "correct_waveform", value = F)
    }
    updateTextInput(session, "ObsError", value = "")
    if (isTruthy(input$white)) {
      updateCheckboxInput(session, inputId = "white", label = NULL, value = F)
    }
    if (isTruthy(input$flicker)) {
      updateCheckboxInput(session, inputId = "flicker", label = NULL, value = F)
    }
    if (isTruthy(input$randomw)) {
      updateCheckboxInput(session, inputId = "randomw", label = NULL, value = F)
    }
    if (isTruthy(input$powerl)) {
      updateCheckboxInput(session, inputId = "powerl", label = NULL, value = F)
    }
    updateTextInput(session, "E0", value = "")
    updateTextInput(session, "TE0", value = "")
    updateTextInput(session, "L0", value = "")
    updateTextInput(session, "TL0", value = "")
  }, priority = 5)

  # Observe delete model ####
  observeEvent(input$model, {
    req(trans$res)
    if (!isTruthy(input$model)) {
      if (messages > 0) cat(file = stderr(), mySession, "Deleting model", "\n")
      info$run <- F
      trans$res <- NULL
      trans$reserror <- NULL
      trans$results <- NULL
      trans$mod <- NULL
      trans$kalman <- NULL
      trans$equation <- NULL
      trans$midas_vel <- NULL
      trans$midas_all <- NULL
    } else if (input$fitType == 2 && length(trans$kalman) > 0)  {
      if (setequal(input$model,trans$model_old)) {
        updateButton(session, inputId = "runKF", label = " Run KF", icon = icon("filter", class = NULL, lib = "font-awesome"), style = "default")
      } else {
        updateButton(session, inputId = "runKF", label = " Run KF", icon = icon("filter", class = NULL, lib = "font-awesome"), style = "danger")
      }
    }
    trans$mle <- F
    trans$verif <- NULL
    if (isTruthy(input$white)) {
      updateCheckboxInput(session, inputId = "white", label = NULL, value = F)
    }
    if (isTruthy(input$flicker)) {
      updateCheckboxInput(session, inputId = "flicker", label = NULL, value = F)
    }
    if (isTruthy(input$randomw)) {
      updateCheckboxInput(session, inputId = "randomw", label = NULL, value = F)
    }
    if (isTruthy(input$powerl)) {
      updateCheckboxInput(session, inputId = "powerl", label = NULL, value = F)
    }
    output$est.white <- renderUI({ NULL })
    output$est.flicker <- renderUI({ NULL })
    output$est.randomw <- renderUI({ NULL })
    output$est.powerl <- renderUI({ NULL })
    output$est.index <- renderUI({ NULL })
    output$est.mle <- renderUI({ NULL })
    output$est.unc <- renderUI({ NULL })
    trans$noise <- NULL
    trans$mle <- F
  }, priority = 5)

  # Observe hide tabs ####
  observeEvent(input$format, {
    req(db1[[info$db1]])
    if (input$format == 4) { #1D
      updateTabsetPanel(session, inputId = "tab", selected = "1")
      output$tabName1 <- renderText({ "Series" })
      hideTab(inputId = "tab", target = "2", session = getDefaultReactiveDomain())
      hideTab(inputId = "tab", target = "3", session = getDefaultReactiveDomain())
      hideTab(inputId = "tab", target = "4", session = getDefaultReactiveDomain())
      hideTab(inputId = "tab", target = "5", session = getDefaultReactiveDomain())
    } else {
      showTab(inputId = "tab", target = "2", session = getDefaultReactiveDomain())
      showTab(inputId = "tab", target = "3", session = getDefaultReactiveDomain())
      showTab(inputId = "tab", target = "4", session = getDefaultReactiveDomain())
    }
  }, priority = 10)

  # Observe plotting ####
  observeEvent(input$plot, {
    req(file$primary)
    removeNotification("no_component")
    if (input$tab < 1) {
      if (messages > 0) cat(file = stderr(), mySession, "WARNING: tab number is", input$tab, "\n")
      showNotification("Please click on any component tab before plotting a coordiante series.", action = NULL, duration = 10, closeButton = T, id = "no_component", type = "error", session = getDefaultReactiveDomain())
      req(info$stop)
    }
    info$format <- input$format
    info$width <- isolate(session$clientData$output_plot1_width)
    if (messages > 4) cat(file = stderr(), mySession, "From: observe plotting\n")
    db1$original <- db1$resampled <- db1$merged <- NULL
    digest(1)
  }, priority = 4)

  # Observe overview ####
  observeEvent(input$plotAll, {
    req(db1[[info$db1]])
    if (input$format < 4) {
      if (messages > 0) cat(file = stderr(), mySession, "Overview plot", "\n")
      unit <- units <- ""
      if (input$sunits == 1) {
        unit <- "m"
      } else if (input$sunits == 2) {
        unit <- "mm"
      }
      if (input$sunits > 0) {
        if (input$tunits == 1) {
          units <- paste0(unit,"/day")
        } else if (input$tunits == 2) {
          units <- paste0(unit,"/week")
        } else if (input$tunits == 3) {
          units <- paste0(unit,"/year")
        }
      }
      if (input$symbol == 0) {
        symbol <- 'p'
      } else if (input$symbol == 1) {
        symbol <- 'l'
      } else if (input$symbol == 2) {
        symbol <- 'o'
      }
      if (input$tunits == 1) {
        x <- db1[[info$db1]]$x1
        x2 <- db2[[info$db2]]$x1
      } else if (input$tunits == 2) {
        x <- db1[[info$db1]]$x2
        x2 <- db2[[info$db2]]$x2
      } else if (input$tunits == 3) {
        x <- db1[[info$db1]]$x3
        x2 <- db2[[info$db2]]$x3
      }
      if (isTruthy(trans$plate) && input$eulerType == 2 && isTruthy(inputs$station_x) && isTruthy(inputs$station_y) && isTruthy(inputs$station_z) && info$db1 != "merged") {
        y1 <- db1[[info$db1]]$y1 - trans$plate[1]*(x - median(x, na.rm = T)) - median(db1[[info$db1]]$y1, na.rm = T)
        y2 <- db1[[info$db1]]$y2 - trans$plate[2]*(x - median(x, na.rm = T)) - median(db1[[info$db1]]$y2, na.rm = T)
        y3 <- db1[[info$db1]]$y3
      } else {
        y1 <- db1[[info$db1]]$y1
        y2 <- db1[[info$db1]]$y2
        y3 <- db1[[info$db1]]$y3
      }
      if (isTruthy(trans$gia) && input$giaType == 2 && info$db1 != "merged") {
        y3 <- y3 - trans$gia[3]*(x - median(x, na.rm = T)) - median(y3, na.rm = T)
      }
      if (isTruthy(trans$plate2) && input$eulerType == 2 && isTruthy(inputs$station_x2) && isTruthy(inputs$station_y2) && isTruthy(inputs$station_z2)) {
        y12 <- db2[[info$db2]]$y1 - trans$plate2[1]*(x2 - median(x, na.rm = T)) - median(db1[[info$db1]]$y1, na.rm = T)
        y22 <- db2[[info$db2]]$y2 - trans$plate2[2]*(x2 - median(x, na.rm = T)) - median(db1[[info$db1]]$y2, na.rm = T)
        y32 <- db2[[info$db2]]$y3
      } else {
        y12 <- db2[[info$db2]]$y1
        y22 <- db2[[info$db2]]$y2
        y32 <- db2[[info$db2]]$y3
      }
      if (isTruthy(trans$gia2) && input$giaType == 2) {
        y32 <- y32 - trans$gia2[3]*(x2 - median(x, na.rm = T)) - median(db1[[info$db1]]$y3, na.rm = T)
      }
      y12 <- y12 * inputs$scaleFactor
      y22 <- y22 * inputs$scaleFactor
      y32 <- y32 * inputs$scaleFactor
      if (all(db1[[info$db1]]$sy1 == 1)) {
        sy1 <- rep(0, length(db1[[info$db1]]$sy1))
        sy2 <- rep(0, length(db1[[info$db1]]$sy2))
        sy3 <- rep(0, length(db1[[info$db1]]$sy3))
      } else {
        sy1 <- db1[[info$db1]]$sy1
        sy2 <- db1[[info$db1]]$sy2
        sy3 <- db1[[info$db1]]$sy3
      }
      if (all(db2[[info$db2]]$sy1 == 1)) {
        sy12 <- rep(0, length(db2[[info$db2]]$sy1))
        sy22 <- rep(0, length(db2[[info$db2]]$sy2))
        sy32 <- rep(0, length(db2[[info$db2]]$sy3))
      } else {
        sy12 <- db2[[info$db2]]$sy1
        sy22 <- db2[[info$db2]]$sy2
        sy32 <- db2[[info$db2]]$sy3
      }
      valid1 <- db1[[info$db1]]$status1 & !is.na(db1[[info$db1]]$status1)
      valid2 <- db1[[info$db1]]$status2 & !is.na(db1[[info$db1]]$status2)
      valid3 <- db1[[info$db1]]$status3 & !is.na(db1[[info$db1]]$status3)
      fileout <- paste0("www/tempFiles/",file$primary$name,".png")
      if (ranges$x1[1] > info$minx || ranges$x1[2] < info$maxx) {
        x.range <- ranges$x1
      } else {
        if (isTruthy(input$fullSeries)) {
          x.range <- c(min(x[valid1], x[valid2], x[valid3], x2, na.rm = T), max(x[valid1], x[valid2], x[valid3], x2, na.rm = T))
        } else {
          x.range <- c(min(x[valid1], x[valid2], x[valid3], na.rm = T), max(x[valid1], x[valid2], x[valid3], na.rm = T))
        }
      }
      ragg::agg_png(filename = fileout, width = info$width, height = 800, pointsize = 25)
      par(mai = c(1, 2, 1, 2))
      layout(mat = matrix(data = c(1,2,3), nrow = 3, ncol = 1))
      ## East ####
      par(mai = c(0.3, 1.2, 0.7, 1.2))
      y.range <- range(y1[valid1][x[valid1] >= x.range[1] & x[valid1] <= x.range[2]], na.rm = T)
      if (input$optionSecondary == 1 && isTruthy(db2[[info$db2]])) {
        if (isTruthy(input$sameScale)) {
          x2.common <- x2[x2 > x.range[1] & x2 < x.range[2]]
          y2.common <- y12[x2 > x.range[1] & x2 < x.range[2]]
          y2.range <- range(y2.common)
          range1 <- diff(y.range)
          range2 <- diff(y2.range)
          if (input$fullSeries) {
            if (range1 >= range2) {
              y.range[1] <- y2.range[1] - (range1 - range2)/2
              y.range[2] <- y2.range[2] + (range1 - range2)/2
            } else {
              y.range[1] <- y.range[1] - (range2 - range1)/2
              y.range[2] <- y.range[2] + (range2 - range1)/2
            }
          } else {
            middle <- ifelse(isTruthy(y2.range), median(y2.range), 0)
            y2.range <- c(middle - range1/2, middle + range1/2)
          }
          if (length(x) == 0 || length(x2.common) == 0) {
            # NA
          } else if (x2.common[1] > x.range[2]) {
            # NA
          } else if (x.range[1] > x2.common[length(x2.common)]) {
            # NA
          } else {
            tie1 <- sort(sapply(x, function(i) min(abs(x2.common - i))), index.return = T)$ix
            tie2 <- sort(sapply(x2.common, function(i) min(abs(x - i))), index.return = T)$ix
            tie1 <- tie1[1:min(length(tie1),length(tie2))]
            tie2 <- tie2[1:min(length(tie1),length(tie2))]
            pointsBias <- median(y1[valid3][tie1] - y2.common[tie2])
            y2.range <- y2.range + (y.range[1] - y2.range[1]) - pointsBias
          }
        } else if (isTruthy(input$same_axis)) {
          if (input$fullSeries) {
            pointsY1 <- y1[valid1][x[valid1] >= x.range[1] & x[valid1] <= x.range[2]]
            pointsY2 <- y12[x2 > x.range[1] & x2 < x.range[2]]
            range <- range(c(pointsY1,pointsY2))
            y.range <- y2.range <- range
          } else {
            y2.range <- y.range
          }
        } else {
          y2.range <- suppressWarnings(range(y12[x2 >= x.range[1] & x2 <= x.range[2]]))
        }
        if (!isTruthy(y2.range) || !all(is.finite(y2.range))) {
          y2.range <- range(y12)
        }
        plot(x2, y12, type = symbol, lwd = 2, cex = 1.1, pch = 23, col = SARIcolors[3], xlab = NA, yaxt = "n", xaxt = "n", ylab = NA, xlim = x.range, ylim = y2.range)
        if (isTruthy(input$sigmas)) {
          color <- SARIcolors[3]
          alfa <- 0.5
          shade <- adjustcolor(color, alpha.f = alfa)
          ba <- y12 + sy12
          bb <- y12 - sy12
          polygon(c(x2, rev(x2)), c(ba, rev(bb)), col = shade, border = NA)
        }
        axis(side = 1, labels = F, tick = F)
        axis(side = 2, labels = F, tick = F)
        axis(side = 4, at = NULL, labels = T, tick = T, outer = F)
        par(new = T)
      }
      mini <- min(y1[valid1], na.rm = T)
      maxi <- max(y1[valid1], na.rm = T)
      if ((abs(mini) > 99 || abs(maxi) > 99) && abs(maxi - mini) < 99) {
        if (mini < 0) {
          const <- as.integer(round(maxi))
          ylab <- paste0(gsub("component","",info$components[1])," ",intToUtf8(8210)," ",abs(const)," (",unit,")")
        } else {
          const <- as.integer(round(mini))
          ylab <- paste0(gsub("component","",info$components[1])," + ",abs(const)," (",unit,")")
        }
      } else {
        const <- 0
        ylab <- gsub("component","",paste0(info$components[1], " (",unit,")"))
      }
      plot(x[valid1], y1[valid1], type = symbol, pch = 20, xlab = NA, xaxt = "n", yaxt = "n", ylab = ylab, xlim = x.range, ylim = y.range)
      p <- par("usr")[3:4]
      pout <- base::pretty(p - const)
      pin <- pout + const
      axis(2, at = pin, labels = pout)
      if (isTruthy(input$sigmas)) {
        color <- SARIcolors[1]
        alfa <- 0.2
        shade <- adjustcolor(color, alpha.f = alfa)
        ba <- y1 + sy1
        bb <- y1 - sy1
        polygon(c(x[valid1], rev(x[valid1])), c(ba[valid1], rev(bb[valid1])), col = shade, border = NA)
      }
      axis(side = 1, labels = F, tick = T)
      if (input$eulerType == 1 && length(trans$plate[!is.na(trans$plate)]) == 3) {
        xx <- median(x[valid1][x[valid1] > x.range[1] & x[valid1] < x.range[2]], na.rm = T)
        yy <- median(y1[valid1][x[valid1] > x.range[1] & x[valid1] < x.range[2]], na.rm = T)
        centerx <- which(abs(x[valid1] - xx) == min(abs(x[valid1] - xx)))[1]
        centery <- which(abs(y1[valid1] - yy) == min(abs(y1[valid1] - yy)))[1]
        lines(c(x[valid1][1],x[valid1][length(x[valid1])]),c(y1[valid1][centery] + trans$plate[1]*(x[valid1][1] - x[valid1][centerx]), y1[valid1][centery] + trans$plate[1]*(x[valid1][length(x[valid1])] - x[valid1][centerx])), col = SARIcolors[4], lwd = 3)
      }
      if (isTruthy(db1[[info$db1]]$mod1) > 0) {
        lines(db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]]$status1 %in% T],db1[[info$db1]]$mod1[db1[[info$db1]]$status1 %in% T], col = SARIcolors[2], lwd = 3)
        text <- paste("Rate", paste(format(c(trans$plotInfo1[[info$db1]][1], trans$plotInfo1[[info$db1]][2]), digits = 2, trim = T), collapse = " +/- "), units, "      Standard deviation", format(trans$plotInfo1[[info$db1]][3], digits = 2), unit)
        mtext(text, side = 3, line = 0, cex = 0.75)
        for (p in trans$offsetEpochs1) {
          abline(v = p, col = SARIcolors[2], lwd = 2)
        }
        if (input$breaking && isTruthy(trans$breakEpochs) && (input$trendType > 0 || input$sinusoidType > 0 || input$polyType > 0)) {
          for (p in trans$breakEpochs) {
            abline(v = p, col = SARIcolors[3], lwd = 2, lty = 3)
          }
        }
      }
      # North ####
      par(mai = c(0.3, 1.2, 0.5, 1.2))
      y.range <- range(y2[valid2][x[valid2] >= x.range[1] & x[valid2] <= x.range[2]], na.rm = T)
      if (input$optionSecondary == 1 && isTruthy(db2[[info$db2]])) {
        if (isTruthy(input$sameScale)) {
          x2.common <- x2[x2 > x.range[1] & x2 < x.range[2]]
          y2.common <- y22[x2 > x.range[1] & x2 < x.range[2]]
          y2.range <- range(y2.common)
          range1 <- diff(y.range)
          range2 <- diff(y2.range)
          if (input$fullSeries) {
            if (range1 >= range2) {
              y.range[1] <- y2.range[1] - (range1 - range2)/2
              y.range[2] <- y2.range[2] + (range1 - range2)/2
            } else {
              y.range[1] <- y.range[1] - (range2 - range1)/2
              y.range[2] <- y.range[2] + (range2 - range1)/2
            }
          } else {
            middle <- ifelse(isTruthy(y2.range), median(y2.range), 0)
            y2.range <- c(middle - range1/2, middle + range1/2)
          }
          if (length(x) == 0 || length(x2.common) == 0) {
            # NA
          } else if (x2.common[1] > x.range[2]) {
            # NA
          } else if (x.range[1] > x2.common[length(x2.common)]) {
            # NA
          } else {
            tie1 <- sort(sapply(x, function(i) min(abs(x2.common - i))), index.return = T)$ix
            tie2 <- sort(sapply(x2.common, function(i) min(abs(x - i))), index.return = T)$ix
            tie1 <- tie1[1:min(length(tie1),length(tie2))]
            tie2 <- tie2[1:min(length(tie1),length(tie2))]
            pointsBias <- median(y2[valid2][tie1] - y2.common[tie2])
            y2.range <- y2.range + (y.range[1] - y2.range[1]) - pointsBias
          }
        } else if (isTruthy(input$same_axis)) {
          if (input$fullSeries) {
            pointsY1 <- y2[valid2][x[valid2] >= x.range[1] & x[valid2] <= x.range[2]]
            pointsY2 <- y22[x2 > x.range[1] & x2 < x.range[2]]
            range <- range(c(pointsY1,pointsY2))
            y.range <- y2.range <- range
          } else {
            y2.range <- y.range 
          }
        } else {
          y2.range <- suppressWarnings(range(y22[x2 >= x.range[1] & x2 <= x.range[2]]))
        }
        if (!isTruthy(y2.range) || !all(is.finite(y2.range))) {
          y2.range <- range(y12)
        }
        plot(x2, y22, type = symbol, lwd = 2, cex = 1.1, pch = 23, col = SARIcolors[3], xlab = NA, yaxt = "n", xaxt = "n", ylab = NA, xlim = x.range, ylim = y2.range)
        if (isTruthy(input$sigmas)) {
          color <- SARIcolors[3]
          alfa <- 0.5
          shade <- adjustcolor(color, alpha.f = alfa)
          ba <- y22 + sy22
          bb <- y22 - sy22
          polygon(c(x2, rev(x2)), c(ba, rev(bb)), col = shade, border = NA)
        }
        axis(side = 1, labels = F, tick = F)
        axis(side = 2, labels = F, tick = F)
        axis(side = 4, at = NULL, labels = T, tick = T, outer = F)
        par(new = T)
      }
      mini <- min(y2[valid2], na.rm = T)
      maxi <- max(y2[valid2], na.rm = T)
      if ((abs(mini) > 99 || abs(maxi) > 99) && abs(maxi - mini) < 99) {
        if (mini < 0) {
          const <- as.integer(round(maxi))
          ylab <- paste0(gsub("component","",info$components[2])," ",intToUtf8(8210)," ",abs(const)," (",unit,")")
        } else {
          const <- as.integer(round(mini))
          ylab <- paste0(gsub("component","",info$components[2])," + ",abs(const)," (",unit,")")
        }
      } else {
        const <- 0
        ylab <- gsub("component","",paste0(info$components[2], " (",unit,")"))
      }
      plot(x[valid2], y2[valid2], type = symbol, pch = 20, xlab = "", xaxt = "n", yaxt = "n", ylab = ylab, xlim = x.range, ylim = y.range)
      p <- par("usr")[3:4]
      pout <- base::pretty(p - const)
      pin <- pout + const
      axis(2, at = pin, labels = pout)
      if (isTruthy(input$sigmas)) {
        color <- SARIcolors[1]
        alfa <- 0.2
        shade <- adjustcolor(color, alpha.f = alfa)
        ba <- y2 + sy2
        bb <- y2 - sy2
        polygon(c(x[valid1], rev(x[valid1])), c(ba[valid1], rev(bb[valid1])), col = shade, border = NA)
      }
      axis(side = 1, labels = F, tick = T)
      if (input$eulerType == 1 && length(trans$plate[!is.na(trans$plate)]) == 3) {
        xx <- median(x[valid2][x[valid2] > x.range[1] & x[valid2] < x.range[2]], na.rm = T)
        yy <- median(y2[valid2][x[valid2] > x.range[1] & x[valid2] < x.range[2]], na.rm = T)
        centerx <- which(abs(x[valid2] - xx) == min(abs(x[valid2] - xx)))[1]
        centery <- which(abs(y2[valid2] - yy) == min(abs(y2[valid2] - yy)))[1]
        lines(c(x[valid2][1],x[valid2][length(x[valid2])]),c(y2[valid2][centery] + trans$plate[2]*(x[valid2][1] - x[valid2][centerx]), y2[valid2][centery] + trans$plate[2]*(x[valid2][length(x[valid2])] - x[valid2][centerx])), col = SARIcolors[4], lwd = 3)
      }
      if (isTruthy(db1[[info$db1]]$mod2) > 0) {
        lines(db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]]$status2 %in% T],db1[[info$db1]]$mod2[db1[[info$db1]]$status2 %in% T], col = SARIcolors[2], lwd = 3)
        text <- paste("Rate", paste(format(c(trans$plotInfo2[[info$db1]][1], trans$plotInfo2[[info$db1]][2]), digits = 2, trim = T), collapse = " +/- "), units, "      Standard deviation", format(trans$plotInfo2[[info$db1]][3], digits = 2), unit)
        mtext(text, side = 3, line = 0, cex = 0.75)
        for (p in trans$offsetEpochs2) {
          abline(v = p, col = SARIcolors[2], lwd = 2)
        }
        if (input$breaking && isTruthy(trans$breakEpochs) && (input$trendType > 0 || input$sinusoidType > 0 || input$polyType > 0)) {
          for (p in trans$breakEpochs) {
            abline(v = p, col = SARIcolors[3], lwd = 2, lty = 3)
          }
        }
      }
      mtext(paste("Generated by", version, "on", format(Sys.time(), format = "%d %B %Y at %H:%M:%S", usetz = T)), side = 4, line = 3, cex = 0.5)
      # Up ####
      par(mai = c(1.2, 1.2, 0.5, 1.2))
      y.range <- range(y3[valid3][x[valid3] >= x.range[1] & x[valid3] <= x.range[2]], na.rm = T)
      if (input$optionSecondary == 1 && isTruthy(db2[[info$db2]])) {
        if (isTruthy(input$sameScale)) {
          x2.common <- x2[x2 > x.range[1] & x2 < x.range[2]]
          y2.common <- y32[x2 > x.range[1] & x2 < x.range[2]]
          y2.range <- range(y2.common)
          range1 <- diff(y.range)
          range2 <- diff(y2.range)
          if (input$fullSeries) {
            if (range1 >= range2) {
              y.range[1] <- y2.range[1] - (range1 - range2)/2
              y.range[2] <- y2.range[2] + (range1 - range2)/2
            } else {
              y.range[1] <- y.range[1] - (range2 - range1)/2
              y.range[2] <- y.range[2] + (range2 - range1)/2
            }
          } else {
            middle <- ifelse(isTruthy(y2.range), median(y2.range), 0)
            y2.range <- c(middle - range1/2, middle + range1/2)
          }
          if (length(x) == 0 || length(x2.common) == 0) {
            # NA
          } else if (x2.common[1] > x.range[2]) {
            # NA
          } else if (x.range[1] > x2.common[length(x2.common)]) {
            # NA
          } else {
            tie1 <- sort(sapply(x, function(i) min(abs(x2.common - i))), index.return = T)$ix
            tie2 <- sort(sapply(x2.common, function(i) min(abs(x - i))), index.return = T)$ix
            tie1 <- tie1[1:min(length(tie1),length(tie2))]
            tie2 <- tie2[1:min(length(tie1),length(tie2))]
            pointsBias <- median(y3[valid3][tie1] - y2.common[tie2])
            y2.range <- y2.range + (y.range[1] - y2.range[1]) - pointsBias
          }
        } else if (isTruthy(input$same_axis)) {
          if (input$fullSeries) {
            pointsY1 <- y3[valid3][x[valid3] >= x.range[1] & x[valid3] <= x.range[2]]
            pointsY2 <- y32[x2 > x.range[1] & x2 < x.range[2]]
            range <- range(c(pointsY1,pointsY2))
            y.range <- y2.range <- range
          } else {
            y2.range <- y.range 
          }
        } else {
          y2.range <- suppressWarnings(range(y32[x2 >= x.range[1] & x2 <= x.range[2]]))
        }
        if (!isTruthy(y2.range) || !all(is.finite(y2.range))) {
          y2.range <- range(y13)
        }
        plot(x2, y32, type = symbol, lwd = 2, cex = 1.1, pch = 23, col = SARIcolors[3], xlab = NA, yaxt = "n", xaxt = "n", ylab = NA, xlim = x.range, ylim = y2.range)
        if (isTruthy(input$sigmas)) {
          color <- SARIcolors[3]
          alfa <- 0.5
          shade <- adjustcolor(color, alpha.f = alfa)
          ba <- y32 + sy32
          bb <- y32 - sy32
          polygon(c(x2, rev(x2)), c(ba, rev(bb)), col = shade, border = NA)
        }
        axis(side = 1, labels = F, tick = F)
        axis(side = 2, labels = F, tick = F)
        axis(side = 4, at = NULL, labels = T, tick = T, outer = F)
        par(new = T)
      }
      mini <- min(y3[valid3], na.rm = T)
      maxi <- max(y3[valid3], na.rm = T)
      if ((abs(mini) > 99 || abs(maxi) > 99) && abs(maxi - mini) < 99) {
        if (mini < 0) {
          const <- as.integer(round(maxi))
          ylab <- paste0(gsub("component","",info$components[3])," ",intToUtf8(8210)," ",abs(const)," (",unit,")")
        } else {
          const <- as.integer(round(mini))
          ylab <- paste0(gsub("component","",info$components[3])," + ",abs(const)," (",unit,")")
        }
      } else {
        const <- 0
        ylab <- gsub("component","",paste0(info$components[3], " (",unit,")"))
      }
      plot(x[valid3], y3[valid3], type = symbol, pch = 20, yaxt = "n", xlab = info$tunits.label, ylab = ylab, xlim = x.range, ylim = y.range)
      p <- par("usr")[3:4]
      pout <- base::pretty(p - const)
      pin <- pout + const
      axis(2, at = pin, labels = pout)
      if (isTruthy(input$sigmas)) {
        color <- SARIcolors[1]
        alfa <- 0.2
        shade <- adjustcolor(color, alpha.f = alfa)
        ba <- y3 + sy3
        bb <- y3 - sy3
        polygon(c(x[valid1], rev(x[valid1])), c(ba[valid1], rev(bb[valid1])), col = shade, border = NA)
      }
      if (input$giaType == 1 && length(trans$gia[!is.na(trans$gia)]) == 3) {
        xx <- median(x[valid3][x[valid3] > x.range[1] & x[valid3] < x.range[2]], na.rm = T)
        yy <- median(y3[valid3][x[valid3] > x.range[1] & x[valid3] < x.range[2]], na.rm = T)
        centerx <- which(abs(x[valid3] - xx) == min(abs(x[valid3] - xx)))[1]
        centery <- which(abs(y3[valid3] - yy) == min(abs(y3[valid3] - yy)))[1]
        lines(c(x[valid3][1],x[valid3][length(x[valid3])]),c(y3[valid3][centery] + trans$gia[3]*(x[valid3][1] - x[valid3][centerx]), y3[valid3][centery] + trans$gia[3]*(x[valid3][length(x[valid3])] - x[valid3][centerx])), col = SARIcolors[4], lwd = 3)
      }
      if (isTruthy(db1[[info$db1]]$mod3) > 0) {
        lines(db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]]$status3 %in% T],db1[[info$db1]]$mod3[db1[[info$db1]]$status3 %in% T], col = SARIcolors[2], lwd = 3)
        text <- paste("Rate", paste(format(c(trans$plotInfo3[[info$db1]][1], trans$plotInfo3[[info$db1]][2]), digits = 2, trim = T), collapse = " +/- "), units, "      Standard deviation", format(trans$plotInfo3[[info$db1]][3], digits = 2), unit)
        mtext(text, side = 3, line = 0, cex = 0.75)
        for (p in trans$offsetEpochs3) {
          abline(v = p, col = SARIcolors[2], lwd = 2)
        }
        if (input$breaking && isTruthy(trans$breakEpochs) && (input$trendType > 0 || input$sinusoidType > 0 || input$polyType > 0)) {
          for (p in trans$breakEpochs) {
            abline(v = p, col = SARIcolors[3], lwd = 2, lty = 3)
          }
        }
      }
      dev.off()
      info$overview <- T
      js$showPopup(sub(pattern = "www/", replacement = "", x = fileout))
      js$checkPopup()
    }
  })

  # Observe removing points manual ####
  observeEvent(input$remove, {
    req(db1[[info$db1]])
    removeNotification("no_toggle")
    removeNotification("bad_toggle")
    removeNotification("no_point_manual")
    if (messages > 0) cat(file = stderr(), mySession, "Removing points, manually", "\n")
    excluding_plot <- excluding_plotres <- NULL
    brush1 <- input$plot_brush
    x <- trans$x0[!is.na(trans$y0)]
    y <- trans$y0[!is.na(trans$y0)]
    if (input$tab == 4) {
      if (isTruthy(input$plot41_brush)) {
        brush1 <- input$plot41_brush
        x <- db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$y1)]
        y <- db1[[info$db1]]$y1[!is.na(db1[[info$db1]]$y1)]
        if (isTruthy(trans$plate) && input$eulerType == 2 && isTruthy(inputs$station_x) && isTruthy(inputs$station_y) && isTruthy(inputs$station_z) && info$db1 != "merged") {
          y <- y - trans$plate[1]*(x - median(x, na.rm = T)) - median(y, na.rm = T)
        }
      } else if (isTruthy(input$plot42_brush)) {
        brush1 <- input$plot42_brush
        x <- db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$y2)]
        y <- db1[[info$db1]]$y2[!is.na(db1[[info$db1]]$y2)]
        if (isTruthy(trans$plate) && input$eulerType == 2 && isTruthy(inputs$station_x) && isTruthy(inputs$station_y) && isTruthy(inputs$station_z) && info$db1 != "merged") {
          y <- y - trans$plate[2]*(x - median(x, na.rm = T)) - median(y, na.rm = T)
        }
      } else if (isTruthy(input$plot43_brush)) {
        brush1 <- input$plot43_brush
        x <- db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$y3)]
        y <- db1[[info$db1]]$y3[!is.na(db1[[info$db1]]$y3)]
        if (isTruthy(trans$gia) && input$giaType == 2 && info$db1 != "merged") {
          y <- y - trans$gia[3]*(x - median(x, na.rm = T)) - median(y, na.rm = T)
        }
      }
    }
    series <- data.frame(x = x, y = y)
    brush2 <- NULL
    if (isTruthy(input$res_brush) && length(trans$res) > 0) {
      residuals <- data.frame(x = trans$x, y = trans$res)
      brush2 <- input$res_brush
    } else if (isTruthy(input$vondrak_brush) && length(trans$filterRes) > 0) {
      residuals <- data.frame(x = trans$x, y = trans$filterRes)
      brush2 <- input$vondrak_brush
    } else if (input$tab == 5) {
      if (isTruthy(input$plot51_brush)) {
        brush2 <- input$plot51_brush
        x <- db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]]$status1 %in% T]
        y <- db1[[info$db1]]$res1[db1[[info$db1]]$status1 %in% T]
      } else if (isTruthy(input$plot52_brush)) {
        brush2 <- input$plot52_brush
        x <- db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]]$status2 %in% T]
        y <- db1[[info$db1]]$res2[db1[[info$db1]]$status2 %in% T]
      } else if (isTruthy(input$plot53_brush)) {
        brush2 <- input$plot53_brush
        x <- db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]]$status3 %in% T]
        y <- db1[[info$db1]]$res3[db1[[info$db1]]$status3 %in% T]
      }
      residuals <- data.frame(x = x, y = y)
    }
    if (isTruthy(brush1) || isTruthy(brush2)) {
      if (length(brush1) > 0) {
        excluding_plot <- brushedPoints(series, brush1, xvar = "x", yvar = "y", allRows = T)
      }
      if (length(brush2) > 0) {
        excluding_res <- brushedPoints(residuals, brush2, xvar = "x", yvar = "y", allRows = T)
        if (input$fitType == 2 && length(trans$mod) > 0 && length(trans$res) > 0) {
          series_kf <- data.frame(x = trans$x0[db1[[info$db1]]$status.kf], y = trans$res[db1[[info$db1]]$status.kf])
          excluding_plotres_kf <- merge(series_kf, excluding_res, by = "x", all.x = T)
          excluding_plotres_kf$selected_ <- sapply(1:length(excluding_plotres_kf$x), function(x) if (isTRUE(excluding_plotres_kf$selected_[x])) T else F)
        }
        excluding_plotres <- merge(series, excluding_res, by = "x", all.x = T)
        excluding_plotres$selected_ <- sapply(1:length(excluding_plotres$x), function(x) if (isTRUE(excluding_plotres$selected_[x])) T else F)
      }
      if ((isTruthy(excluding_plot$selected_) && sum(excluding_plot$selected_) > 0) || (isTruthy(excluding_plotres$selected_) && sum(excluding_plotres$selected_) > 0)) {
        if ((sum(excluding_plot$selected_) == info$points) || (sum(excluding_plotres$selected_) == info$points)) {
          showNotification(HTML("All the points were selected to be removed from the series.<br>Check the selected area."), action = NULL, duration = 10, closeButton = T, id = "bad_toggle", type = "warning", session = getDefaultReactiveDomain())
        } else {
          if (isTruthy(input$remove3D)) {
            if (length(brush1) > 0) {
              if (isTruthy(input$permanent)) {
                db1[[info$db1]]$status1[excluding_plot$selected_] <- NA
                # setting new axis limits
                info$minx <- min(db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status1)])
                info$maxx <- max(db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status1)])
                ranges$x0 <- c(info$minx, info$maxx)
                if (isTruthy(input$fullSeries) && input$optionSecondary == 1) {
                  # show all points from primary & secondary series
                  info$minx <- min(db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status1)], db2[[info$db2]][[paste0("x",input$tunits)]])
                  info$maxx <- max(db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status1)], db2[[info$db2]][[paste0("x",input$tunits)]])
                }
                if (ranges$x1[1] < info$minx || ranges$x1[2] > info$maxx) {
                  ranges$x1 <- c(info$minx, info$maxx)
                  ranges$x2 <- NULL
                }
                updateCheckboxInput(session, inputId = "permanent", value = F)
              } else {
                db1[[info$db1]]$status1 <- xor(db1[[info$db1]]$status1, excluding_plot$selected_)
              }
            }
            if (length(brush2) > 0) {
              if (isTruthy(input$permanent)) {
                db1[[info$db1]]$status1[excluding_plotres$selected_] <- NA
                # setting new axis limits
                info$minx <- min(db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status1)])
                info$maxx <- max(db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status1)])
                ranges$x0 <- c(info$minx, info$maxx)
                if (isTruthy(input$fullSeries) && input$optionSecondary == 1) {
                  # show all points from primary & secondary series
                  info$minx <- min(db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status1)], db2[[info$db2]][[paste0("x",input$tunits)]])
                  info$maxx <- max(db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status1)], db2[[info$db2]][[paste0("x",input$tunits)]])
                }
                if (ranges$x1[1] < info$minx || ranges$x1[2] > info$maxx) {
                  ranges$x1 <- c(info$minx, info$maxx)
                  ranges$x2 <- NULL
                }
                updateCheckboxInput(session, inputId = "permanent", value = F)
              } else {
                db1[[info$db1]]$status1 <- xor(db1[[info$db1]]$status1, excluding_plotres$selected_)
              }
            }
            db1[[info$db1]]$status2 <- db1[[info$db1]]$status3 <- db1[[info$db1]]$status1
          } else {
            if (input$tab == 1 || isTruthy(input$plot41_brush) || is.null(input$tab)) {
              if (length(brush1) > 0) {
                if (isTruthy(input$permanent)) {
                  db1[[info$db1]]$status1[excluding_plot$selected_] <- NA
                  updateCheckboxInput(session, inputId = "permanent", value = F)
                } else {
                  db1[[info$db1]]$status1 <- xor(db1[[info$db1]]$status1, excluding_plot$selected_)
                }
              }
              if (length(brush2) > 0) {
                if (isTruthy(input$permanent)) {
                  db1[[info$db1]]$status1[excluding_plotres$selected_] <- NA
                  updateCheckboxInput(session, inputId = "permanent", value = F)
                } else {
                  db1[[info$db1]]$status1 <- xor(db1[[info$db1]]$status1, excluding_plotres$selected_)
                }
              }
            } else if (input$tab == 2 || isTruthy(input$plot42_brush)) {
              if (length(brush1) > 0) {
                if (isTruthy(input$permanent)) {
                  db1[[info$db1]]$status2[excluding_plot$selected_] <- NA
                  updateCheckboxInput(session, inputId = "permanent", value = F)
                } else {
                  db1[[info$db1]]$status2 <- xor(db1[[info$db1]]$status2, excluding_plot$selected_)
                }
              }
              if (length(brush2) > 0) {
                if (isTruthy(input$permanent)) {
                  db1[[info$db1]]$status2[excluding_plotres$selected_] <- NA
                  updateCheckboxInput(session, inputId = "permanent", value = F)
                } else {
                  db1[[info$db1]]$status2 <- xor(db1[[info$db1]]$status2, excluding_plotres$selected_)
                }
              }
            } else if (input$tab == 3 || isTruthy(input$plot43_brush)) {
              if (length(brush1) > 0) {
                if (isTruthy(input$permanent)) {
                  db1[[info$db1]]$status3[excluding_plot$selected_] <- NA
                  updateCheckboxInput(session, inputId = "permanent", value = F)
                } else {
                  db1[[info$db1]]$status3 <- xor(db1[[info$db1]]$status3, excluding_plot$selected_)
                }
              }
              if (length(brush2) > 0) {
                if (isTruthy(input$permanent)) {
                  db1[[info$db1]]$status3[excluding_plotres$selected_] <- NA
                  updateCheckboxInput(session, inputId = "permanent", value = F)
                } else {
                  db1[[info$db1]]$status3 <- xor(db1[[info$db1]]$status3, excluding_plotres$selected_)
                }
              }
            }
          }
        }
      } else {
        showNotification(HTML("No point was selected to be removed manually.<br>Check the selected area."), action = NULL, duration = 10, closeButton = T, id = "no_point_manual", type = "warning", session = getDefaultReactiveDomain())
      }
    }
  }, priority = 4)

  # Observe removing points auto ####
  observeEvent(input$removeAuto, {
    req(db1[[info$db1]])
    removeNotification("bad_normalised_threshold")
    removeNotification("bad_threshold")
    removeNotification("no_point_auto")
    if (messages > 0) cat(file = stderr(), mySession, "Removing points, automatically", "\n")
    if (input$fitType == 2 && length(trans$mod) > 0 && length(trans$res) > 0) {
      series_kf <- data.frame(x = trans$x0[db1[[info$db1]]$status.kf], y = trans$res[db1[[info$db1]]$status.kf])
    }
    series <- data.frame(x = trans$x0[!is.na(trans$y0)], y = trans$y0[!is.na(trans$y0)])
    if (length(trans$res) > 0) {
      if (isTruthy(input$sigmas)) {
        if (length(trans$reserror) > 0 && all(!is.na(trans$reserror))) {
          residuals <- data.frame(x = trans$x, res = trans$res, sy = trans$reserror)
        } else {
          residuals <- data.frame(x = trans$x, res = trans$res, sy = trans$sy)
        }
      } else {
        residuals <- data.frame(x = trans$x, res = trans$res)
      }
    } else if (length(trans$filterRes) > 0) {
      residuals <- data.frame(x = trans$x, res = trans$filterRes)
    } else {
      req(info$stop)
    }
    if (input$fitType == 2 && length(trans$mod) > 0 && length(trans$res) > 0) {
      excluding_kf <- rep(F,length(trans$res0))
      joint_kf <- merge(series_kf, residuals, by = "x", all.x = T)
      joint_kf$res <- sapply(1:length(joint_kf$x), function(x) if (is.na(joint_kf$res[x])) 0 else joint_kf$res[x])
      if (length(joint_kf$sy) > 0) {
        joint_kf$sy <- sapply(1:length(joint_kf$x), function(x) if (is.na(joint_kf$sy[x])) 1 else joint_kf$sy[x])
      }
    }
    excluding <- rep(F,length(series$x))
    joint <- merge(series, residuals, by = "x", all.x = T)
    joint$res <- sapply(1:length(joint$x), function(x) if (is.na(joint$res[x])) 0 else joint$res[x])
    if (length(joint$sy) > 0) {
      joint$sy <- sapply(1:length(series$x), function(x) if (is.na(joint$sy[x])) 1 else joint$sy[x])
    }
    if (nchar(input$thresholdResN) > 0 && length(joint$sy) > 0) {
      if (!is.na(inputs$thresholdResN)) {
        if (messages > 0) cat(file = stderr(), mySession, "Limit normalized residual", inputs$thresholdResN, "\n")
        if (input$fitType == 2 && length(trans$mod) > 0 && length(trans$res) > 0) {
          excluding_plot_kf <- abs(joint_kf$res/joint_kf$sy) > abs(inputs$thresholdResN)
          excluding_kf <- excluding_plot_kf
        }
        excluding_plot <- abs(joint$res/joint$sy) > abs(inputs$thresholdResN)
        excluding <- excluding_plot
      } else {
        showNotification(HTML("The normalised residual threshold is not numeric.<br>Check the input value."), action = NULL, duration = 10, closeButton = T, id = "bad_normalised_threshold", type = "warning", session = getDefaultReactiveDomain())
      }
    }
    if (nchar(input$thresholdRes) > 0) {
      if (!is.na(inputs$thresholdRes)) {
        if (abs(inputs$thresholdRes) < min(abs(residuals))) {
          showNotification(HTML("The residual threshold will remove all data from the residual series.<br>Check the input value."), action = NULL, duration = 10, closeButton = T, id = "bad_threshold", type = "error", session = getDefaultReactiveDomain())
        } else {
          if (messages > 0) cat(file = stderr(), mySession, "Limit absolute residual", inputs$thresholdRes, "\n")
          if (input$fitType == 2 && length(trans$mod) > 0 && length(trans$res) > 0) {
            excluding_res_kf <- abs(joint_kf$res) > abs(inputs$thresholdRes)
            excluding_kf <- excluding_kf + excluding_res_kf > 0
          }
          excluding_res <- abs(joint$res) > abs(inputs$thresholdRes)
          excluding <- excluding + excluding_res > 0
        }
      } else {
        showNotification(HTML("The residual threshold is not numeric.<br>Check the input value."), action = NULL, duration = 10, closeButton = T, id = "bad_threshold", type = "error", session = getDefaultReactiveDomain())
      }
    }
    if (isTruthy(excluding) && sum(excluding) > 0) {
      if (min(sum(db1[[info$db1]]$status1, na.rm = T), sum(db1[[info$db1]]$status2, na.rm = T), sum(db1[[info$db1]]$status3, na.rm = T), na.rm = T) - sum(excluding, na.rm = T) < 2) {
        showNotification(HTML("The residual threshold will remove all data from the residual series.<br>Check the input value."), action = NULL, duration = 10, closeButton = T, id = "bad_threshold", type = "error", session = getDefaultReactiveDomain())
      } else {
        if (isTruthy(input$remove3D)) {
          db1[[info$db1]]$status1 <- xor(db1[[info$db1]]$status1, excluding)
          if (isTruthy(input$permanent)) {
            db1[[info$db1]]$status1[excluding] <- NA
            # setting new axis limits
            info$minx <- min(db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status1)])
            info$maxx <- max(db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status1)])
            ranges$x0 <- c(info$minx, info$maxx)
            if (isTruthy(input$fullSeries) && input$optionSecondary < 2) {
              # show all points from primary & secondary series
              info$minx <- min(db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status1)], db2[[info$db2]][[paste0("x",input$tunits)]])
              info$maxx <- max(db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]]$status1)], db2[[info$db2]][[paste0("x",input$tunits)]])
            }
            if (ranges$x1[1] < info$minx || ranges$x1[2] > info$maxx) {
              ranges$x1 <- c(info$minx, info$maxx)
            }
            updateCheckboxInput(session, inputId = "permanent", value = F)
          }
          db1[[info$db1]]$status2 <- db1[[info$db1]]$status3 <- db1[[info$db1]]$status1
        } else {
          if (input$tab == 1 || is.null(input$tab)) {
            db1[[info$db1]]$status1 <- xor(db1[[info$db1]]$status1, excluding)
            if (isTruthy(input$permanent)) {
              db1[[info$db1]]$status1[excluding] <- NA
              updateCheckboxInput(session, inputId = "permanent", value = F)
            }
          } else if (input$tab == 2) {
            db1[[info$db1]]$status2 <- xor(db1[[info$db1]]$status2, excluding)
            if (isTruthy(input$permanent)) {
              db1[[info$db1]]$status2[excluding] <- NA
              updateCheckboxInput(session, inputId = "permanent", value = F)
            }
          } else if (input$tab == 3) {
            db1[[info$db1]]$status3 <- xor(db1[[info$db1]]$status3, excluding)
            if (isTruthy(input$permanent)) {
              db1[[info$db1]]$status3[excluding] <- NA
              updateCheckboxInput(session, inputId = "permanent", value = F)
            }
          }
        }
      }
    } else {
      showNotification(HTML("No point was selected to be removed automatically.<br>Check the input threshold."), action = NULL, duration = 10, closeButton = T, id = "no_point_auto", type = "warning", session = getDefaultReactiveDomain())
    }
  }, priority = 4)

  # Observe truncate ####
  observeEvent(c(inputs$cutStart, inputs$cutEnd), {
    req(db1[[info$db1]], input$cut)
    removeNotification("bad_cut")
    if (isTruthy(inputs$cutStart) || isTruthy(inputs$cutEnd)) {
      if (messages > 0) cat(file = stderr(), mySession, "Cutting series:", inputs$cutStart, "-", inputs$cutEnd, "\n")
      if (input$tab < 4) {
        x <- trans$x
        x0 <- trans$x0
      } else {
        statusAll <- colSums(t(cbind(db1[[info$db1]]$status1, db1[[info$db1]]$status2, db1[[info$db1]]$status3))) > 0
        x <- db1[[info$db1]][[paste0("x", input$tunits)]][!is.na(statusAll)]
        x0 <- db1[[info$db1]][[paste0("x", input$tunits)]][!is.na(db1[[info$db1]]$y1)]
      }
      start <- ifelse(isTruthy(inputs$cutStart), inputs$cutStart, x0[1])
      end <- ifelse(isTruthy(inputs$cutEnd), inputs$cutEnd, x0[length(x0)])
      start <- ifelse(start < x0[1], x0[1], start)
      end <- ifelse(end > x0[length(x0)], x0[length(x0)], end)
      if (end <= start) {
        shinyjs::delay(500, showNotification(HTML("The End epoch or the end of the series is equal or smaller than the Start epoch or the start of the series.<br>Check the truncation values."), action = NULL, duration = 10, closeButton = T, id = "bad_cut", type = "error", session = getDefaultReactiveDomain()))
        req(info$stop)
      }
      if (isTruthy(input$permanent)) {
        if (isTruthy(inputs$cutStart) && isTruthy(inputs$cutEnd)) {
          # NA
        } else if (isTruthy(inputs$cutStart)) {
          end <- x0[length(x0)]
        } else if (isTruthy(inputs$cutEnd)) {
          start <- x0[1]
        }
        if (isTruthy(input$remove3D)) {
          db1[[info$db1]]$status1[x0 < start | x0 > end] <- NA
          db1[[info$db1]]$status2[x0 < start | x0 > end] <- NA
          db1[[info$db1]]$status3[x0 < start | x0 > end] <- NA
        } else {
          if (input$tab == 1) {
            db1[[info$db1]]$status1[x0 < start | x0 > end] <- NA
          } else if (input$tab == 2) {
            db1[[info$db1]]$status2[x0 < start | x0 > end] <- NA
          } else if (input$tab == 3) {
            db1[[info$db1]]$status3[x0 < start | x0 > end] <- NA
          }
        }
        # setting new axis limits
        if (input$tab < 4) {
          valid <- !is.na(db1[[info$db1]][[paste0("status", input$tab)]])
        } else {
          valid <- !is.na(colSums(t(cbind(db1[[info$db1]]$status1, db1[[info$db1]]$status2, db1[[info$db1]]$status3))) > 0)
        }
        info$minx <- min(db1[[info$db1]][[paste0("x",input$tunits)]][valid])
        info$maxx <- max(db1[[info$db1]][[paste0("x",input$tunits)]][valid])
        ranges$x0 <- c(info$minx, info$maxx)
        if (isTruthy(input$fullSeries) && input$optionSecondary < 2) {
          # show all points from primary & secondary series
          info$minx <- min(db1[[info$db1]][[paste0("x",input$tunits)]][valid], db2[[info$db2]][[paste0("x",input$tunits)]])
          info$maxx <- max(db1[[info$db1]][[paste0("x",input$tunits)]][valid], db2[[info$db2]][[paste0("x",input$tunits)]])
        }
        if (ranges$x1[1] < info$minx || ranges$x1[2] > info$maxx) {
          ranges$x1 <- c(info$minx, info$maxx)
        }
        updateCheckboxInput(session, inputId = "permanent", value = F)
      } else {
        if (isTruthy(input$remove3D)) {
          db1[[info$db1]]$status1[(x0 < start | x0 > end) & !is.na(db1[[info$db1]]$status1)] <- F
          db1[[info$db1]]$status2[(x0 < start | x0 > end) & !is.na(db1[[info$db1]]$status2)] <- F
          db1[[info$db1]]$status3[(x0 < start | x0 > end) & !is.na(db1[[info$db1]]$status3)] <- F
        } else {
          if (input$tab == 1) {
            db1[[info$db1]]$status1[(x0 < start | x0 > end) & !is.na(db1[[info$db1]]$status1)] <- F
          } else if (input$tab == 2) {
            db1[[info$db1]]$status2[(x0 < start | x0 > end) & !is.na(db1[[info$db1]]$status2)] <- F
          } else if (input$tab == 3) {
            db1[[info$db1]]$status3[(x0 < start | x0 > end) & !is.na(db1[[info$db1]]$status3)] <- F
          }
        }
      }
      updateTextInput(session, inputId = "cutStart", value = "")
      updateTextInput(session, inputId = "cutEnd", value = "")
    }
  })
  observeEvent(c(inputs$cutAbove, inputs$cutBelow), {
    req(db1[[info$db1]], input$cut)
    removeNotification("bad_cut")
    removeNotification("bad_truncation")
    if (isTruthy(inputs$cutAbove) || isTruthy(inputs$cutBelow)) {
      if (messages > 0) cat(file = stderr(), mySession, "Cutting series: above", inputs$cutAbove, "& below", inputs$cutBelow, "\n")
      if (input$tab < 4) {
        y <- trans$y
        y0 <- trans$y0
        miny <- min(y, na.rm = T)
        maxy <- max(y, na.rm = T)
        above <- ifelse(isTruthy(inputs$cutAbove), inputs$cutAbove, maxy)
        below <- ifelse(isTruthy(inputs$cutBelow), inputs$cutBelow, miny)
        above <- ifelse(above > maxy, maxy, above)
        below <- ifelse(below < miny, miny, below)
      } else {
        above <- ifelse(isTruthy(inputs$cutAbove), inputs$cutAbove, Inf)
        below <- ifelse(isTruthy(inputs$cutBelow), inputs$cutBelow, -Inf)
      }
      if (above <= below) {
        shinyjs::delay(500, showNotification(HTML("The Above epoch or the top of the series is equal or smaller than the Below epoch or the bottom of the series.<br>Check the truncation values."), action = NULL, duration = 10, closeButton = T, id = "bad_cut", type = "error", session = getDefaultReactiveDomain()))
        req(info$stop)
      }
      all <- 0
      if (isTruthy(input$permanent)) {
        if (input$tab > 3) {
          for (comp in seq(3)) {
            index <- db1[[info$db1]][[paste0("y",comp)]] > above | db1[[info$db1]][[paste0("y",comp)]] < below
            all <- all + sum(index)
            if (!any((db1[[info$db1]][[paste0("status",comp)]] %in% T + !index) > 1) || all >= info$points) {
              showNotification(HTML("All the points were selected to be removed from the series.<br>Check the provided truncation limits"), action = NULL, duration = 10, closeButton = T, id = "bad_truncation", type = "warning", session = getDefaultReactiveDomain())
              req(info$stop)
            }
          }
          for (comp in seq(3)) {
            index <- db1[[info$db1]][[paste0("y",comp)]] > above | db1[[info$db1]][[paste0("y",comp)]] < below
            db1[[info$db1]]$status1[index] <- NA
            db1[[info$db1]]$status2[index] <- NA
            db1[[info$db1]]$status3[index] <- NA
          }
        } else {
          comp <- input$tab
          index <- db1[[info$db1]][[paste0("y",comp)]] > above | db1[[info$db1]][[paste0("y",comp)]] < below
          if (isTruthy(input$remove3D)) {
            for (comps in seq(3)) {
              if (!any((db1[[info$db1]][[paste0("status",comps)]] %in% T + !index) > 1)) {
                showNotification(HTML("All the points were selected to be removed from the series.<br>Check the provided truncation limits"), action = NULL, duration = 10, closeButton = T, id = "bad_truncation", type = "warning", session = getDefaultReactiveDomain())
                req(info$stop)
              }
            }
            db1[[info$db1]]$status1[index] <- NA
            db1[[info$db1]]$status2[index] <- NA
            db1[[info$db1]]$status3[index] <- NA
          } else {
            if (!any((db1[[info$db1]][[paste0("status",comp)]] %in% T + !index) > 1)) {
              showNotification(HTML("All the points were selected to be removed from the series.<br>Check the provided truncation limits"), action = NULL, duration = 10, closeButton = T, id = "bad_truncation", type = "warning", session = getDefaultReactiveDomain())
              req(info$stop)
            }
            db1[[info$db1]][[paste0("status",comp)]][index] <- NA
          }
        }
        # setting new axis limits
        if (isTruthy(input$remove3D) || input$format == 4) {
          if (input$tab < 4) {
            valid <- !is.na(db1[[info$db1]][[paste0("status", input$tab)]])
          } else {
            valid <- !is.na(colSums(t(cbind(db1[[info$db1]]$status1, db1[[info$db1]]$status2, db1[[info$db1]]$status3))) > 0)
          }
          info$minx <- min(db1[[info$db1]][[paste0("x",input$tunits)]][valid])
          info$maxx <- max(db1[[info$db1]][[paste0("x",input$tunits)]][valid])
          ranges$x0 <- c(info$minx, info$maxx)
          if (isTruthy(input$fullSeries) && input$optionSecondary < 2) {
            # show all points from primary & secondary series
            info$minx <- min(db1[[info$db1]][[paste0("x",input$tunits)]][valid], db2[[info$db2]][[paste0("x",input$tunits)]])
            info$maxx <- max(db1[[info$db1]][[paste0("x",input$tunits)]][valid], db2[[info$db2]][[paste0("x",input$tunits)]])
          }
          if (ranges$x1[1] < info$minx || ranges$x1[2] > info$maxx) {
            ranges$x1 <- c(info$minx, info$maxx)
          }
        }
        updateCheckboxInput(session, inputId = "permanent", value = F)
      } else {
        if (input$tab > 3) {
          all <- 0
          for (comp in seq(3)) {
            index <- (db1[[info$db1]][[paste0("y",comp)]] > above | db1[[info$db1]][[paste0("y",comp)]] < below) & !is.na(db1[[info$db1]][[paste0("status",comp)]])
            all <- all + sum(index)
            if (!any((db1[[info$db1]][[paste0("status",comp)]] %in% T + !index) > 1) || all >= info$points) {
              showNotification(HTML("All the points were selected to be removed from the series.<br>Check the provided truncation limits"), action = NULL, duration = 10, closeButton = T, id = "bad_truncation", type = "warning", session = getDefaultReactiveDomain())
              req(info$stop)
            }
          }
          for (comp in seq(3)) {
            index <- (db1[[info$db1]][[paste0("y",comp)]] > above | db1[[info$db1]][[paste0("y",comp)]] < below) & !is.na(db1[[info$db1]][[paste0("status",comp)]])
            db1[[info$db1]]$status1[index & !is.na(db1[[info$db1]]$status1)] <- F
            db1[[info$db1]]$status2[index & !is.na(db1[[info$db1]]$status2)] <- F
            db1[[info$db1]]$status3[index & !is.na(db1[[info$db1]]$status3)] <- F
          }
        } else {
          comp <- input$tab
          index <- (db1[[info$db1]][[paste0("y",comp)]] > above | db1[[info$db1]][[paste0("y",comp)]] < below) & !is.na(db1[[info$db1]][[paste0("status",comp)]])
          if (isTruthy(input$remove3D)) {
            for (comps in seq(3)) {
              if (!any((db1[[info$db1]][[paste0("status",comps)]] %in% T + !index) > 1)) {
                showNotification(HTML("All the points were selected to be removed from the series.<br>Check the provided truncation limits"), action = NULL, duration = 10, closeButton = T, id = "bad_truncation", type = "warning", session = getDefaultReactiveDomain())
                req(info$stop)
              }
            }
            db1[[info$db1]]$status1[index & !is.na(db1[[info$db1]]$status1)] <- F
            db1[[info$db1]]$status2[index & !is.na(db1[[info$db1]]$status2)] <- F
            db1[[info$db1]]$status3[index & !is.na(db1[[info$db1]]$status3)] <- F
          } else {
            if (!any((db1[[info$db1]][[paste0("status",comp)]] %in% T + !index) > 1)) {
              showNotification(HTML("All the points were selected to be removed from the series.<br>Check the provided truncation limits"), action = NULL, duration = 10, closeButton = T, id = "bad_truncation", type = "warning", session = getDefaultReactiveDomain())
              req(info$stop)
            }
            db1[[info$db1]][[paste0("status",comp)]][index] <- F
          }
        }
      }
      updateTextInput(session, inputId = "cutAbove", value = "")
      updateTextInput(session, inputId = "cutBelow", value = "")
    }
  })

  # Observe strip ####
  observeEvent(c(inputs$stripStart, inputs$stripEnd), {
    req(db1[[info$db1]], input$strip)
    removeNotification("bad_strip")
    if (isTruthy(inputs$stripStart) && isTruthy(inputs$stripEnd)) {
      if (messages > 0) cat(file = stderr(), mySession, "Stripping series:", inputs$stripStart, "-", inputs$stripEnd, "\n")
      if (input$tab < 4) {
        x <- trans$x
        x0 <- trans$x0
      } else {
        statusAll <- colSums(t(cbind(db1[[info$db1]]$status1, db1[[info$db1]]$status2, db1[[info$db1]]$status3))) > 0
        x <- db1[[info$db1]][[paste0("x", input$tunits)]][!is.na(statusAll)]
        x0 <- db1[[info$db1]][[paste0("x", input$tunits)]][!is.na(db1[[info$db1]]$y1)]
      }
      if (isTruthy(input$permanent)) {
        start <- ifelse(inputs$stripStart < x0[1], x0[1], inputs$stripStart)
        end <- ifelse(inputs$stripEnd > x0[length(x0)], x0[length(x0)], inputs$stripEnd)
      } else {
        start <- ifelse(inputs$stripStart < x[1], x[1], inputs$stripStart)
        end <- ifelse(inputs$stripEnd > x[length(x)], x[length(x)], inputs$stripEnd)
      }
      if (end <= start) {
        shinyjs::delay(500, showNotification(HTML("The 'To' epoch or the end of the series is equal or smaller than the 'From' epoch or the start of the series.<br>Check the provided epochs of the remove period option."), action = NULL, duration = 10, closeButton = T, id = "bad_strip", type = "error", session = getDefaultReactiveDomain()))
        req(info$stop)
      }
      if (isTruthy(input$permanent)) {
        if (isTruthy(input$remove3D)) {
          db1[[info$db1]]$status1[x0 >= start & x0 <= end] <- NA
          db1[[info$db1]]$status2[x0 >= start & x0 <= end] <- NA
          db1[[info$db1]]$status3[x0 >= start & x0 <= end] <- NA
        } else {
          if (input$tab == 1) {
            db1[[info$db1]]$status1[x0 >= start & x0 <= end] <- NA
          } else if (input$tab == 2) {
            db1[[info$db1]]$status2[x0 >= start & x0 <= end] <- NA
          } else if (input$tab == 3) {
            db1[[info$db1]]$status3[x0 >= start & x0 <= end] <- NA
          }
        }
        # setting new axis limits
        if (input$tab < 4) {
          valid <- !is.na(db1[[info$db1]][[paste0("status", input$tab)]])
        } else {
          valid <- !is.na(colSums(t(cbind(db1[[info$db1]]$status1, db1[[info$db1]]$status2, db1[[info$db1]]$status3))) > 0)
        }
        info$minx <- min(db1[[info$db1]][[paste0("x",input$tunits)]][valid])
        info$maxx <- max(db1[[info$db1]][[paste0("x",input$tunits)]][valid])
        ranges$x0 <- c(info$minx, info$maxx)
        if (isTruthy(input$fullSeries) && input$optionSecondary < 2) {
          # show all points from primary & secondary series
          info$minx <- min(db1[[info$db1]][[paste0("x",input$tunits)]][valid], db2[[info$db2]][[paste0("x",input$tunits)]])
          info$maxx <- max(db1[[info$db1]][[paste0("x",input$tunits)]][valid], db2[[info$db2]][[paste0("x",input$tunits)]])
        }
        ranges$x1 <- c(info$minx, info$maxx)
        updateCheckboxInput(session, inputId = "permanent", value = F)
      } else {
        if (isTruthy(input$remove3D)) {
          db1[[info$db1]]$status1[(x0 >= start & x0 <= end) & !is.na(db1[[info$db1]]$status1)] <- F
          db1[[info$db1]]$status2[(x0 >= start & x0 <= end) & !is.na(db1[[info$db1]]$status2)] <- F
          db1[[info$db1]]$status3[(x0 >= start & x0 <= end) & !is.na(db1[[info$db1]]$status3)] <- F
        } else {
          if (input$tab == 1) {
            db1[[info$db1]]$status1[(x0 >= start & x0 <= end) & !is.na(db1[[info$db1]]$status1)] <- F
          } else if (input$tab == 2) {
            db1[[info$db1]]$status2[(x0 >= start & x0 <= end) & !is.na(db1[[info$db1]]$status2)] <- F
          } else if (input$tab == 3) {
            db1[[info$db1]]$status3[(x0 >= start & x0 <= end) & !is.na(db1[[info$db1]]$status3)] <- F
          }
        }
      }
      updateTextInput(session, inputId = "stripStart", value = "")
      updateTextInput(session, inputId = "stripEnd", value = "")
    }
  })

  # Observe restore removed ####
  observeEvent(input$delete_excluded, {
    req(db1$original)
    if (messages > 0) cat(file = stderr(), mySession, "Restoring points", "\n")
    if (isTruthy(input$remove3D)) {
      db1[[info$db1]]$status1[!db1[[info$db1]]$status1 & !is.na(db1[[info$db1]]$status1)] <- T
      db1[[info$db1]]$status2 <- db1[[info$db1]]$status3 <- db1[[info$db1]]$status1
    } else {
      if (input$tab == 1 || is.null(input$tab)) {
        db1[[info$db1]]$status1[!db1[[info$db1]]$status1 & !is.na(db1[[info$db1]]$status1)] <- T
      } else if (input$tab == 2) {
        db1[[info$db1]]$status2[!db1[[info$db1]]$status2 & !is.na(db1[[info$db1]]$status2)] <- T
      } else if (input$tab == 3) {
        db1[[info$db1]]$status3[!db1[[info$db1]]$status3 & !is.na(db1[[info$db1]]$status3)] <- T
      }
    }
    updateTextInput(session, "thresholdRes", value = "")
    updateTextInput(session, "thresholdResN", value = "")
    updateTextInput(session, "cutStart", value = "")
    updateTextInput(session, "cutEnd", value = "")
    updateTextInput(session, "cutAbove", value = "")
    updateTextInput(session, "cutBelow", value = "")
    updateTextInput(session, "stripStart", value = "")
    updateTextInput(session, "stripEnd", value = "")
  }, priority = 4)

  # Observe station.info ####
  observeEvent(c(file$sinfo, input$series, input$series2, input$optionSecondary, file$id1, file$id2), {
    req(file$sinfo,file$id1)
    if (messages > 0) cat(file = stderr(), mySession, "Reading station.info", "\n")
    id1 <- file$id1
    if (length(file$secondary) > 0) {
      if (input$optionSecondary < 2) {
        id2 <- NULL
      } else {
        id2 <- file$id2
      }
    } else {
      id2 <- NULL
    }
    info$sinfo <- ReadInfo(id1,id2,file$sinfo)
    if (any(sapply(info$sinfo, isTruthy))) {
      tmp_log <- info$sinfo
      for (d in 1:length(info$sinfo)) {
        if (isTruthy(info$sinfo[[d]])) {
          if (input$tunits == 1) {
            tmp_log[[d]] <- mjd2year(info$sinfo[[d]])
          } else if (input$tunits == 2) {
            tmp_log[[d]] <- week2year(info$sinfo[[d]])
          } else if (input$tunits == 3) {
            tmp_log[[d]] <- info$sinfo[[d]]
          }
        }
      }
      info$sinfo_years <- tmp_log
    } else {
      info$sinfo <- NULL
    }
    output$station.info <- renderUI({
      tags$a(href = basename(file$sinfo$datapath), "Show station.info", title = "Open the station.info file in a new tab", target = "_blank")
    })
  }, priority = 4)
  observeEvent(c(input$printSinfo),{
    req(file$primary, input$sinfo)
    output$changes_ant1s <- output$changes_ant2s <- output$changes_ant3s <- renderText({
      if (length(info$sinfo[[1]]) > 0) {
        sprintf("Antenna changes from station.info at\n%s",paste(unlist(info$sinfo[[1]]), collapse = ", "))
      } else {
        NULL
      }
    })
    output$changes_rec1s <- output$changes_rec2s <- output$changes_rec3s <- renderText({
      if (length(info$sinfo[[2]]) > 0) {
        sprintf("Receiver and other changes from station.info at\n%s",paste(unlist(info$sinfo[[2]]), collapse = ", "))
      } else {
        NULL
      }
    })
  })

  # Observe soln.snx ####
  observeEvent(c(file$soln, input$series, input$series2, input$optionSecondary, file$id1, file$id2), {
    req(file$soln,file$id1)
    if (messages > 0) cat(file = stderr(), mySession, "Reading soln", "\n")
    id1 <- file$id1
    if (length(file$secondary) > 0) {
      if (input$optionSecondary < 2) {
        id2 <- NULL
      } else {
        id2 <- file$id2
      }
    } else {
      id2 <- NULL
    }
    info$soln <- ReadSoln(id1,id2,file$soln)
    if (any(sapply(info$soln, isTruthy))) {
      tmp_soln <- info$soln
      info$soln_years <- info$soln
      for (d in 1:length(info$soln_years)) {
        if (isTruthy(info$soln_years[[d]])) {
          if (!isTruthy(input$tunits) || input$tunits == 3) {
            tmp_soln[[d]] <- info$soln_years[[d]]
          } else if (input$tunits == 1) {
            tmp_soln[[d]] <- year2mjd(info$soln_years[[d]])
          } else if (input$tunits == 2) {
            tmp_soln[[d]] <- year2week(info$soln_years[[d]])
          }
        }
      }
      info$soln <- tmp_soln
    } else {
      info$soln <- NULL
    }
    output$solnFile <- renderUI({
      tags$a(href = basename(file$soln$datapath), "Show soln file", title = "Open the soln file in a new tab", target = "_blank")
    })
  }, priority = 4)
  observeEvent(c(input$printSoln),{
    req(file$primary, file$soln)
    output$changes_ant1so <- output$changes_ant2so <- output$changes_ant3so <- renderText({
      if (length(info$soln[[1]]) > 0) {
        sprintf("Antenna changes from soln file at\n%s",paste(unlist(info$soln[[1]]), collapse = ", "))
      } else {
        NULL
      }
    })
    output$changes_rec1so <- output$changes_rec2so <- output$changes_rec3so <- renderText({
      if (length(info$soln[[2]]) > 0) {
        sprintf("Receiver and other changes from soln file at\n%s",paste(unlist(info$soln[[2]]), collapse = ", "))
      } else {
        NULL
      }
    })
  })

  # Observe custom ####
  observeEvent(c(file$custom, input$series, input$series2, input$optionSecondary, file$id1, file$id2), {
    req(file$custom,file$id1)
    if (messages > 0) cat(file = stderr(), mySession, "Reading custom", "\n")
    id1 <- file$id1
    if (length(file$secondary) > 0) {
      if (input$optionSecondary < 2) {
        id2 <- NULL
      } else {
        id2 <- file$id2
      }
    } else {
      id2 <- NULL
    }
    info$custom <- ReadCustom(id1,id2,file$custom)
    if (any(sapply(info$custom, isTruthy))) {
      tmp_custom <- info$custom
      info$custom_years <- info$custom
      for (d in 1:length(info$custom_years)) {
        if (isTruthy(info$custom_years[[d]])) {
          if (!isTruthy(input$tunits) || input$tunits == 3) {
            tmp_custom[[d]] <- info$custom_years[[d]]
          } else if (input$tunits == 1) {
            tmp_custom[[d]] <- year2mjd(info$custom_years[[d]])
          } else if (input$tunits == 2) {
            tmp_custom[[d]] <- year2week(info$custom_years[[d]])
          }
        }
      }
      info$custom <- tmp_custom
    } else {
      info$custom <- NULL
    }
    output$customFile <- renderUI({
      tags$a(href = basename(file$custom$datapath), "Show custom file", title = "Open the custom file in a new tab", target = "_blank")
    })
  }, priority = 4)
  observeEvent(c(input$printCustom),{
    req(file$primary, file$custom)
    output$changes_ant1c <- output$changes_ant2c <- output$changes_ant3c <- renderText({
      if (length(info$custom[[1]]) > 0) {
        sprintf("Antenna changes from custom file at\n%s",paste(unlist(info$custom[[1]]), collapse = ", "))
      } else {
        NULL
      }
    })
    output$changes_rec1c <- output$changes_rec2c <- output$changes_rec3c <- renderText({
      if (length(info$custom[[2]]) > 0) {
        sprintf("Receiver and other changes from custom file at\n%s",paste(unlist(info$custom[[2]]), collapse = ", "))
      } else {
        NULL
      }
    })
  })

  # Observe sitelog ####
  observeEvent(c(file$sitelog, file$primary$logfile, file$secondary$logfile), {
    if (messages > 0) cat(file = stderr(), mySession, "Reading sitelog", "\n")
    if (isTruthy(file$sitelog)) {
      info$log <- ReadLog(file$sitelog$datapath)
      datapath <- file$sitelog$datapath
    } else if (isTruthy(file$primary$logfile)) {
      info$log <- ReadLog(file$primary$logfile)
      datapath <- file$primary$logfile
    } else if (isTruthy(file$secondary$logfile)) {
      info$log <- ReadLog(file$secondary$logfile)
      datapath <- file$secondary$logfile
    }
    if (isTruthy(datapath)) {
      output$sitelog <- renderUI({
        tags$a(href = sub(pattern = "www/", replacement = "", x = datapath), "Show log file", title = "Open the log file in a new tab", target = "_blank")
      })
    }
    if (any(!sapply(info$log, is.null))) {
      tmp_log <- info$log
      for (d in 1:length(info$log)) {
        if (isTruthy(info$log[[d]])) {
          if (!isTruthy(input$tunits) || input$tunits == 3) {
            tmp_log[[d]] <- info$log[[d]]
          } else if (input$tunits == 1) {
            tmp_log[[d]] <- mjd2year(info$log[[d]])
          } else if (input$tunits == 2) {
            tmp_log[[d]] <- week2year(info$log[[d]])
          }
        }
      }
      info$log_years <- tmp_log
    } else {
      info$log <- NULL
    }
  }, priority = 1)
  observeEvent(c(input$printLog),{
    req(db1$original)
    output$changes_ant1 <- output$changes_ant2 <- output$changes_ant3 <- renderText({
      if (length(info$log[[1]]) > 0) {
        sprintf("Antenna changes from log file at\n%s",paste(unlist(info$log[[1]]), collapse = ", "))
      } else {
        NULL
      }
    })
    output$changes_rec1 <- output$changes_rec2 <- output$changes_rec3 <- renderText({
      if (length(info$log[[2]]) > 0) {
        sprintf("Receiver and other changes from log file at\n%s",paste(unlist(info$log[[2]]), collapse = ", "))
      } else {
        NULL
      }
    })
  })

  # Observe reset ####
  observeEvent(input$reset, {
    req(file$primary)
    if (messages > 0) cat(file = stderr(), mySession, "Reset all", "\n")
    if (session$clientData$url_search != "") {
      if (session$clientData$url_pathname == "/") {
        path <- ""
      } else {
        path <- session$clientData$url_pathname
      }
      if (session$clientData$url_port == "") {
        port <- ""
      } else {
        port <- paste0(":",session$clientData$url_port)
      }
      jscode <- paste0("window.location.href = '",session$clientData$url_protocol,"//",session$clientData$url_hostname,path,port,"';")
      runjs(jscode)
      req(info$stop)
    }
    reset("side-panel")
    reset("main-panel")
    updateCollapse(session, id = "menu", open = 1, close = c(2,3,4,5,6))
    db1[[info$db1]] <- NULL
    db2[[info$db2]] <- NULL
    for (i in names(db1)) {
      db1[[i]] <- NULL
      db2[[i]] <- NULL
    }
    updateRadioButtons(session, inputId = "tunits", selected = character(0))
    ranges$x0 <- NULL
    ranges$x1 <- NULL
    ranges$y1 <- NULL
    ranges$y12 <- NULL
    ranges$x2 <- NULL
    ranges$y2 <- NULL
    ranges$x3 <- NULL
    ranges$y3 <- NULL
    file$primary <- NULL
    file$secondary <- NULL
    file$id1 <- NULL
    file$id2 <- NULL
    file$sitelog <- NULL
    file$soln <- NULL
    trans$x <- NULL
    trans$y <- NULL
    trans$sy <- NULL
    trans$xe <- NULL
    trans$ye <- NULL
    trans$sye <- NULL
    info$run <- NULL
    trans$res <- NULL
    trans$reserror <- NULL
    trans$results <- NULL
    trans$mod <- NULL
    trans$filter <- NULL
    trans$filterRes <- NULL
    trans$kalman <- NULL
    trans$equation <- NULL
    trans$ordinate <- NULL
    trans$offsetEpochs <- NULL
    trans$breakEpochs <- NULL
    trans$model_old <- NULL
    info$tol <- NULL
    trans$midas_vel <- NULL
    trans$midas_all <- NULL
    trans$mle <- F
    trans$verif <- NULL
    trans$pattern <- NULL
    trans$unc <- NULL
    trans$spectra_old <- NULL
    trans$plate <- NULL
    trans$gia <- NULL
    info$points <- NULL
    info$log <- NULL
    info$rangex <- NULL
    info$sampling <- NULL
    info$errorbars <- T
    info$last_optionSecondary <- 0
    info$trendRef <- NULL
    info$PolyRef <- NULL
    info$periodRef <- NULL
    info$tunits.known1 <- F
    info$tunits.known2 <- F
    info$product1 <- NULL
    info$step <- NULL
    info$step2 <- NULL
    info$stepUnit <- NULL
    url$file <- NULL
    url$file2 <- NULL
    url$logfile <- NULL
    url$logfile2 <- NULL
    url$server <- NULL
    url$server2 <- NULL
    url$station <- NULL
    url$station2 <- NULL
    updateTextInput(session, "waveformPeriod", value = "")
    updateCheckboxInput(session, inputId = "waveform", label = NULL, value = F)
    if (isTruthy(input$white)) {
      updateCheckboxInput(session, inputId = "white", label = NULL, value = F)
    }
    if (isTruthy(input$flicker)) {
      updateCheckboxInput(session, inputId = "flicker", label = NULL, value = F)
    }
    if (isTruthy(input$randomw)) {
      updateCheckboxInput(session, inputId = "randomw", label = NULL, value = F)
    }
    if (isTruthy(input$powerl)) {
      updateCheckboxInput(session, inputId = "powerl", label = NULL, value = F)
    }
    updateTextInput(session, "ObsError", value = "")
    updateTabsetPanel(session, inputId = "tab", selected = "1")
    updateSliderInput(session, inputId = "segmentLength", value = 10)
    output$offsetFound <- renderUI({
      NULL
    })
    enable("neuenu")
    enable("server1")
    info$components <- c("", "", "", "", "")
    output$tabName1 <<- renderText({ "Visualization panel" })
    output$tabName2 <<- renderText({ info$components[2] })
    output$tabName3 <<- renderText({ info$components[3] })
    output$tabName4 <<- renderText({ info$components[4] })
    output$tabName5 <<- renderText({ info$components[5] })
    output$fileSeries1 <- renderUI({
      tags$a(href = "SPOTGINS_CRAL00FRA.enu", "Show file example", targe = "_blank")
    })
    output$fileSeries2 <- renderUI({
      NULL
    })
    output$sitelog <- renderUI({
      tags$a(href = "cral00fra_20231110.log", "Show file example", target = "_blank")
    })
    output$station.info <- renderUI({
      tags$a(href = "station.info", "Show file example", target = "_blank")
    })
    output$customFile <- renderUI({
      tags$a(href = "steps.txt", "Show file example", target = "_blank")
    })
    output$solnFile <- renderUI({
      tags$a(href = "soln.snx", "Show file example", target = "_blank")
    })
    shinyjs::hide("zoomin1")
    shinyjs::hide("zoomin2")
    shinyjs::hide("zoomin3")
    updateButton(session, inputId = "runKF", label = " Run KF", icon = icon("filter", class = NULL, lib = "font-awesome"), style = "default")
    if (isTruthy(info$overview) && isTRUE(isolate(input$overview))) {
      runjs('overview.close();')
    }
  })

  # Observe hide buttons ####
  observeEvent(c(input$tab, trans$filter, trans$res, trans$y, inputs$step, input$optionSecondary, input$eulerType, input$giaType), {
    if (input$tab == 6) {
      showTab(inputId = "tab", target = "8", select = F, session = getDefaultReactiveDomain())
      hideTab(inputId = "tab", target = "7", session = getDefaultReactiveDomain())
    } else {
      hideTab(inputId = "tab", target = "8", session = getDefaultReactiveDomain())
      if (input$tab == 5 ||
          (input$tab < 4 && length(trans$y) > 0 &&
           (  length(trans$filter) > 0 ||
              length(trans$res) > 0 ||
              (nchar(inputs$step) > 0 && !is.na(inputs$step) && inputs$step > 0) ||
              input$optionSecondary > 1 ||
              (input$eulerType == 2 && length(trans$plate) > 0) ||
              (input$giaType == 2 && length(trans$gia) > 0 && (input$format == 4 || input$tab == 3)) )
          ) ||
          (input$tab == 4 &&
           (  (input$eulerType == 2 || input$giaType == 2) &&
              (isTruthy(trans$plate) || isTruthy(trans$gia))  )
          ) ||
          (input$tab == 4 && input$optionSecondary > 1)
      ) {
        showTab(inputId = "tab", target = "7", select = F, session = getDefaultReactiveDomain())
      } else {
        hideTab(inputId = "tab", target = "7", session = getDefaultReactiveDomain())
      }
    }
  }, priority = 0)

  # Observe directory ####
  observeEvent(input$directory, {
    if (isTruthy(input$directory)) {
      info$directory <- input$directory
    }
  })

  # Observe scrolling ####
  observeEvent(input$overflow, {
    if (isTruthy(input$overflow)) {
      runjs("document.getElementById('side-panel').style.overflowY='auto';")
      runjs("document.getElementById('side-panel').style.position='fixed';")
      runjs("document.getElementById('side-panel').style.width='inherit';")
      runjs("document.getElementById('side-panel').style.marginRight='0px';")
    } else {
      runjs("document.getElementById('side-panel').style.overflowY='visible';")
      runjs("document.getElementById('side-panel').style.position='static';")
      runjs("document.getElementById('side-panel').style.width='100%';")
      runjs("document.getElementById('side-panel').style.marginRight='0px';")
      runjs("window.scrollTo(0,0)")
    }
  })

  # Observe type of noise color ####
  observeEvent(input$typeColor, {
    if (input$typeColor == 1) {
      updateTextInput(session, inputId = "verif_pl", value = "")
      updateTextInput(session, inputId = "verif_k", value = "")
    } else if (input$typeColor == 2) {
      updateTextInput(session, inputId = "verif_fl", value = "")
      updateTextInput(session, inputId = "verif_rw", value = "")
    }
  })

  # Observe noise model ####
  observeEvent(c(input$white, input$flicker, input$randomw, input$powerl, input$noise_unc, info$points), {
    removeNotification("no_mle")
    removeNotification("too_long")
    removeNotification("warning_no_slope")
    trans$noise <- NULL
    trans$mle <- F
    output$est.white <- renderUI({ NULL })
    output$est.flicker <- renderUI({ NULL })
    output$est.randomw <- renderUI({ NULL })
    output$est.powerl <- renderUI({ NULL })
    output$est.index <- renderUI({ NULL })
    output$est.mle <- renderUI({ NULL })
    output$est.unc <- renderUI({ NULL })
    # updating LS trend error
    if (isTruthy(trans$unc)) {
      ids <- grepl("Rate",rownames(trans$LScoefs))
      if (isTruthy(trans$LScoefs[ids,2])) {
        trans$LScoefs[ids,2] <- trans$unc
      }
      if (isTruthy(trans$results$coefficients[ids,2])) {
        trans$results$coefficients[ids,2] <- trans$unc
        trans$results$coefficients[ids,3] <- abs(trans$results$coefficients[ids,1]) / trans$results$coefficients[ids,2]
        trans$results$coefficients[ids,4] <- 2 * pt(abs(trans$results$coefficients[ids,3]), trans$results$df , lower.tail = F)[2]
      }
    }
    # estimating MLE duration
    if (isTruthy(input$mle)) {
      info$timeMLE <- 0
      if (isTruthy(info$points) && info$points > 0) {
        if (input$white) {
          if (input$flicker) {
            if (input$randomw) { # WH + FN + RW
              if (isTruthy(input$noise_unc)) {
                info$timeMLE <- ceiling(0.0000000212*info$points^2.7310170576)
              } else {
                info$timeMLE <- ceiling(0.0000000163*info$points^2.6969406699)
              }
            } else {  # WH + FN
              if (isTruthy(input$noise_unc)) {
                info$timeMLE <- ceiling(0.0000000190*info$points^2.7218809680)
              } else {
                info$timeMLE <- ceiling(0.0000000194*info$points^2.6777146385)
              }
            }
          } else if (input$randomw) { # WH + RW
            if (isTruthy(input$noise_unc)) {
              info$timeMLE <- ceiling(0.0000000193*info$points^2.7102027977)
            } else {
              info$timeMLE <- ceiling(0.0000000153*info$points^2.6965310604)
            }
          } else if (input$powerl) { # WH + PL
            if (!isTruthy(trans$slope)) {
              showNotification("It is highly recommended to estimate the power spectrum of the residual series before fitting a PL noise model.", action = NULL, duration = 10, closeButton = T, id = "warning_no_slope", type = "warning", session = getDefaultReactiveDomain())
            }
            if (isTruthy(trans$slope) && trans$slope < 0 && trans$slope > -4) {
              if (isTruthy(input$noise_unc)) {
                info$timeMLE <- ceiling(0.0000000283*info$points^2.8574872668)
              } else {
                info$timeMLE <- ceiling(0.0000000182*info$points^2.8093811786)
              }
            } else {
              if (isTruthy(input$noise_unc)) {
                info$timeMLE <- ceiling(0.0000000029*info$points^3.1797797014)
              } else {
                info$timeMLE <- ceiling(0.0000000006*info$points^3.3238998899)
              }
            }
            # info$timeMLE <- info$timeMLE * 3 # if using the Nelder & Mead method
          } else { # WH
            info$timeMLE <- 2
          }
        } else if (input$flicker) {
          if (input$randomw) { # FN + RW
            if (isTruthy(input$noise_unc)) {
              info$timeMLE <- ceiling(0.0000000041*info$points^2.9122849861)
            } else {
              info$timeMLE <- ceiling(0.0000000022*info$points^2.9418404761)
            }
          } else { # FN
            info$timeMLE <- ceiling(0.0000000335*info$points^2.3767196923)
          }
        } else if (input$randomw) { # RW
          info$timeMLE <- ceiling(0.0000000502*info$points^2.3299799835)
        } else if (input$powerl) { # PL
          if (!isTruthy(trans$slope)) {
            showNotification("It is highly recommended to estimate the power spectrum of the residual series before fitting a PL noise model.", action = NULL, duration = 10, closeButton = T, id = "warning_no_slope", type = "warning", session = getDefaultReactiveDomain())
          }
          if (isTruthy(trans$slope) && trans$slope < 0 && trans$slope > -4) {
            if (isTruthy(input$noise_unc)) {
              info$timeMLE <- ceiling(0.0000000137*info$points^2.8892566790)
            } else {
              info$timeMLE <- ceiling(0.0000000084*info$points^2.8777970916)
            }
          } else {
            if (isTruthy(input$noise_unc)) {
              info$timeMLE <- ceiling(0.0000000209*info$points^2.8807048341)
            } else {
              info$timeMLE <- ceiling(0.0000000145*info$points^2.8835059302)
            }
            # info$timeMLE <- info$timeMLE * 3 # thanks to the Nelder & Mead method
          }
        }
        if (info$timeMLE < 0) {
          info$timeMLE <- 10
        }
      }
      if (info$timeMLE > 0) {
        if (info$timeMLE < 60) {
          showNotification(paste0("The noise model fit may take about ", ceiling(info$timeMLE), " sec"), action = NULL, duration = 10, closeButton = T, id = "timeWillTake", type = "warning", session = getDefaultReactiveDomain())
        } else {
          showNotification(paste0("The noise model fit may take about ", ceiling(info$timeMLE/60), " min"), action = NULL, duration = 10, closeButton = T, id = "timeWillTake", type = "warning", session = getDefaultReactiveDomain())
        }
        if (info$timeMLE > 14*60 && !isTruthy(info$local)) {
          showNotification(HTML("The noise model analysis will likely not finish before the server closes the session for lack of user activity.<br>Consider averaging the series for a faster analysis."), action = NULL, duration = 10, closeButton = T, id = "too_long", type = "error", session = getDefaultReactiveDomain())
        }
      }
    }
  })

  # Observe clicks on multiple plots ####
  observeEvent(input$plot41_1click, {
    inputs$plot4_1click$x <- input$plot41_1click$x
    inputs$plot4_1click$y <- input$plot41_1click$y
  })
  observeEvent(input$plot42_1click, {
    inputs$plot4_1click$x <- input$plot42_1click$x
    inputs$plot4_1click$y <- input$plot42_1click$y
  })
  observeEvent(input$plot43_1click, {
    inputs$plot4_1click$x <- input$plot43_1click$x
    inputs$plot4_1click$y <- input$plot43_1click$y
  })

  # Observe fullSeries ####
  observeEvent(input$fullSeries, {
    req(file$secondary)
    x2 <- db2[[info$db2]][[paste0("x",input$tunits)]]
    if (input$tab < 4) {
      x1 <- db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]][[paste0("status",input$tab)]] %in% T]
      xe <- db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]][[paste0("status",input$tab)]] %in% F]
    } else {
      x1 <- db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]]$status1 %in% T | db1[[info$db1]]$status2 %in% T | db1[[info$db1]]$status3 %in% T]
      xe <- db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]]$status1 %in% F | db1[[info$db1]]$status2 %in% F | db1[[info$db1]]$status3 %in% F]
    }
    if (input$optionSecondary == 1) {
      if (isTruthy(input$fullSeries)) {
        # show all points from primary & secondary series
        info$minx <- min(x1, xe, x2, na.rm = T)
        info$maxx <- max(x1, xe, x2, na.rm = T)
        ranges$x1 <- c(info$minx, info$maxx)
      } else {
        # show all points from primary series only
        info$minx <- min(x1, xe, na.rm = T)
        info$maxx <- max(x1, xe, na.rm = T)
        ranges$x1 <- c(info$minx, info$maxx)
      }
    }
  }, priority = 6)

  # Observe clicks on the periodogram ####
  observeEvent(input$lomb_1click, {
    if (length(input$lomb_1click$x) > 0 && !isTruthy(input$lomb_2click) && !isTruthy(input$lomb_brush)) {
      isolate({
        if (messages > 0) cat(file = stderr(), mySession, "Clicking periodogram", "\n")
        info$clickX <- input$lomb_1click$x
        info$clickY <- input$lomb_1click$y
        closestPoint <- which.min(abs(1/trans$fs - input$lomb_1click$x))
        info$closestX <- 1/trans$fs[closestPoint]
        c <- max(which(trans$spectra_old))
        if (input$spectrumType == 0) {
          info$closestY <- trans$amp[closestPoint,c]
        } else if (input$spectrumType == 1) {
          info$closestY <- trans$psd[closestPoint,c]
        }
      })
    }
  }, priority = 200)

  # Observe draconitics ####
  ## GPS ####
  observeEvent(input$GPSdrac, {
    req(db1[[info$db1]])
    draconiticPeriod <- 350.9
    text_in_default <- paste0(draconiticPeriod, "dx4")
    text_in_generic <- paste0(draconiticPeriod, "dx")
    text_out <- NULL
    if (grepl(text_in_generic, input$period, perl = F, fixed = T)) {
      if (input$GPSdrac) {
        # do nothing
      } else {
        # removing the string with the draconitic harmonics
        splitted <- strsplit(input$period, split = ",")[[1]]
        text_out <- sub(splitted[grepl(text_in_generic, strsplit(input$period, split = ",")[[1]], perl = F)], "", input$period, fixed = T)
        # removing the double commas if any
        text_out <- sub(", *,", ",", text_out, perl = T)
        # removing the last commas if any
        text_out <- sub(", *$", "", text_out, perl = T)
        # removing the first commas if any
        text_out <- sub("^ *, *", "", text_out, perl = T)
      }
    } else {
      if (input$GPSdrac) {
        # adding the string with the draconitic harmonics
        if (nchar(trimws(input$period)) > 0) {
          text_out <- paste(input$period, text_in_default, sep = ", ")
        } else {
          text_out <- text_in_default
        }
      } else {
        # do nothing
      }
    }
    if (!is.null(text_out)) {
      # updating the string on the UI
      updateTextInput(session, "period", value = text_out)
    }
  })
  ## Galileo ####
  observeEvent(input$GALdrac, {
    req(db1[[info$db1]])
    draconiticPeriod <- 355.7
    text_in_default <- paste0(draconiticPeriod, "dx4")
    text_in_generic <- paste0(draconiticPeriod, "dx")
    text_out <- NULL
    if (grepl(text_in_generic, input$period, perl = F, fixed = T)) {
      if (input$GALdrac) {
        # do nothing
      } else {
        # removing the string with the draconitic harmonics
        splitted <- strsplit(input$period, split = ",")[[1]]
        text_out <- sub(splitted[grepl(text_in_generic, strsplit(input$period, split = ",")[[1]], perl = F)], "", input$period, fixed = T)
        # removing the double commas if any
        text_out <- sub(", *,", ",", text_out, perl = T)
        # removing the last commas if any
        text_out <- sub(", *$", "", text_out, perl = T)
        # removing the first commas if any
        text_out <- sub("^ *, *", "", text_out, perl = T)
      }
    } else {
      if (input$GALdrac) {
        # adding the string with the draconitic harmonics
        if (nchar(trimws(input$period)) > 0) {
          text_out <- paste(input$period, text_in_default, sep = ", ")
        } else {
          text_out <- text_in_default
        }
      } else {
        # do nothing
      }
    }
    if (!is.null(text_out)) {
      # updating the string on the UI
      updateTextInput(session, "period", value = text_out)
    }
  })
  ## BeiDou ####
  observeEvent(input$BDSdrac, {
    req(db1[[info$db1]])
    draconiticPeriod <- 353.1
    text_in_default <- paste0(draconiticPeriod, "dx4")
    text_in_generic <- paste0(draconiticPeriod, "dx")
    text_out <- NULL
    if (grepl(text_in_generic, input$period, perl = F, fixed = T)) {
      if (input$BDSdrac) {
        # do nothing
      } else {
        # removing the string with the draconitic harmonics
        splitted <- strsplit(input$period, split = ",")[[1]]
        text_out <- sub(splitted[grepl(text_in_generic, strsplit(input$period, split = ",")[[1]], perl = F)], "", input$period, fixed = T)
        # removing the double commas if any
        text_out <- sub(", *,", ",", text_out, perl = T)
        # removing the last commas if any
        text_out <- sub(", *$", "", text_out, perl = T)
        # removing the first commas if any
        text_out <- sub("^ *, *", "", text_out, perl = T)
      }
    } else {
      if (input$BDSdrac) {
        # adding the string with the draconitic harmonics
        if (nchar(trimws(input$period)) > 0) {
          text_out <- paste(input$period, text_in_default, sep = ", ")
        } else {
          text_out <- text_in_default
        }
      } else {
        # do nothing
      }
    }
    if (!is.null(text_out)) {
      # updating the string on the UI
      updateTextInput(session, "period", value = text_out)
    }
  })
  ## GLONASS ####
  observeEvent(input$GLOdrac, {
    req(db1[[info$db1]])
    draconiticPeriod <- 353.0
    text_in_default <- paste0(draconiticPeriod, "dx4")
    text_in_generic <- paste0(draconiticPeriod, "dx")
    text_out <- NULL
    if (grepl(text_in_generic, input$period, perl = F, fixed = T)) {
      if (input$GLOdrac) {
        # do nothing
      } else {
        # removing the string with the draconitic harmonics
        splitted <- strsplit(input$period, split = ",")[[1]]
        text_out <- sub(splitted[grepl(text_in_generic, strsplit(input$period, split = ",")[[1]], perl = F)], "", input$period, fixed = T)
        # removing the double commas if any
        text_out <- sub(", *,", ",", text_out, perl = T)
        # removing the last commas if any
        text_out <- sub(", *$", "", text_out, perl = T)
        # removing the first commas if any
        text_out <- sub("^ *, *", "", text_out, perl = T)
      }
    } else {
      if (input$GLOdrac) {
        # adding the string with the draconitic harmonics
        if (nchar(trimws(input$period)) > 0) {
          text_out <- paste(input$period, text_in_default, sep = ", ")
        } else {
          text_out <- text_in_default
        }
      } else {
        # do nothing
      }
    }
    if (!is.null(text_out)) {
      # updating the string on the UI
      updateTextInput(session, "period", value = text_out)
    }
  })

  # Observe click&collect ####
  observeEvent(c(input$plot_1click), {
    req(db1[[info$db1]], input$click2collect)
    shinyjs::delay(300, {
      if (!isTruthy(input$plot_brush) && !isTruthy(input$res_brush)) {
        # adding click point to list of offsets
        allOffsets <- paste(input$offsetEpoch, input$plot_1click$x, sep = ", ")
        # removing the first commas if any
        allOffsets <- sub("^ *, *", "", allOffsets, perl = T)
        updateTextInput(session, inputId = "offsetEpoch", value = allOffsets)
        showNotification(HTML(paste("Offset added at:<br>", format(input$plot_1click$x, nsmall = 1, digits = 1))), action = NULL, duration = 5, closeButton = T, id = NULL, type = "error", session = getDefaultReactiveDomain())
      }
    })
  })

  # Observe offset epochs ####
  observeEvent(c(inputs$offsetEpoch, input$model, trans$x), {
    req(db1[[info$db1]])
    trans$offsetEpochs <- NULL
    if ("Offset" %in% input$model) {
      offsetEpochs <- trimws(unlist(strsplit(inputs$offsetEpoch, split = ",")))
      offsetEpochs <- extractEpochList(trans$x, offsetEpochs, "offset")
      if (length(offsetEpochs) > 0) {
        if (input$breaking && length(trans$breakEpochs) > 0 && sum(as.numeric(input$trendType,input$sinusoidType,input$polyType)) > 0) {
          trans$offsetEpochs <- extractEpochList(trans$x, offsetEpochs, "offset", trans$breakEpochs, "break")
        } else {
          trans$offsetEpochs <- offsetEpochs
        }
      }
    }
  }, priority = 3)

  # Observe breakpoint epochs ####
  observeEvent(c(input$breaking, inputs$breakEpoch, input$trendType, trans$x), {
    req(db1[[info$db1]])
    if (input$breaking) {
      breakEpochs <- trimws(unlist(strsplit(inputs$breakEpoch, split = ",")))
      trans$breakEpochs <- sort(extractEpochList(trans$x, breakEpochs, "break"))
    } else {
      trans$breakEpochs <- NULL
    }
    if ("Offset" %in% input$model && length(inputs$offsetEpoch) > 0) {
      offsetEpochs <- trimws(unlist(strsplit(inputs$offsetEpoch, split = ",")))
      offsetEpochs <- extractEpochList(trans$x, offsetEpochs, "offset")
      if (length(inputs$breakEpoch) > 0 && sum(as.numeric(input$trendType,input$sinusoidType,input$polyType)) > 0) {
        trans$offsetEpochs <- extractEpochList(trans$x, offsetEpochs, "offset", trans$breakEpochs, "break")
      } else {
        trans$offsetEpochs <- offsetEpochs
      }
    }
  }, priority = 3)

  # Functions ####
  digest <- function(series) {
    removeNotification("bad_series")
    removeNotification("removing_NA")
    removeNotification("bad_x")
    removeNotification("bad_window")
    removeNotification("unknown_components")
    removeNotification("time_shift")
    removeNotification("ambiguous_shift")
    removeNotification("parsing_url1")
    lat <- lon <- lat2 <- lon2 <- NULL
    removes <- "^SPOTGINS_|^UGA_|^IGS_|^ENS_"
    ## primary series ####
    if (series == 1) {
      if (messages > 0) cat(file = stderr(), mySession, "Reading primary series file", "\n")
      if (isTruthy(url$file) && isTruthy(url$station)) {
        fileName <- file$primary$name
        output$fileSeries1 <- renderUI({
          tags$a(href = sub(pattern = "www/", replacement = "", x = file$primary$datapath), "Show series file", title = "Open the file of the primary series in a new tab", target = "_blank", download = fileName)
        })
      } else {
        fileName <- input$series$name
        output$fileSeries1 <- renderUI({
          NULL
        })
      }
      printInfo("PLOT  ")
      # Setting column separation
      if (input$separator == "1") {
        sep <- ""
      } else if (input$separator == "2") {
        sep <- ","
      } else if (input$separator == "3") {
        sep <- ";"
      }
      # Getting primary series
      table <- NULL
      if (isTruthy(url$file)) {
        filein <- file$primary$datapath
        # checking downloaded file
        if (isTruthy(filein) && file.exists(filein)) {
          table <- extract_table(filein,sep,info$format,as.numeric(inputs$epoch),as.numeric(inputs$variable),as.numeric(inputs$errorBar),F,url$server,1)
        } else {
          showNotification(paste("Problem downloading the", file$primary$name, "series from the remote server."), action = NULL, duration = 10, closeButton = T, id = "bad_remote", type = "error", session = getDefaultReactiveDomain())
          req(info$stop)
        }
      } else {
        filein <- input$series$datapath
        table <- extract_table(filein,sep,info$format,as.numeric(inputs$epoch),as.numeric(inputs$variable),as.numeric(inputs$errorBar),F,"",1)
      }
      # Checking series values and time order
      if (!is.null(table)) {
        if (isTruthy(info$format)) {
          if (info$format == 4) {
            updateTabsetPanel(session, inputId = "tab", selected = "1")
            info$tab <- 1
          } else {
            updateTabsetPanel(session, inputId = "tab", selected = "4")
            info$tab <- 4
          }
        }
        table <- table[order(table$x1),]
        if (any(diff(table$x1) <= 0)) {
          bad_x <- which(diff(table$x1) <= 0)
          if (length(bad_x) > 10) {
            showNotification(HTML(paste("Negative or null increment in abscissa (probably 2 or more points at the same day epoch).<br>Check point", bad_x[1], "and many more ...")), action = NULL, duration = 10, closeButton = T, id = "bad_x", type = "error", session = getDefaultReactiveDomain())
          } else {
            showNotification(HTML(paste("Negative or null increment in abscissa (probably 2 or more points at the same day epoch).<br>Check points", paste(bad_x, collapse = " "))), action = NULL, duration = 10, closeButton = T, id = "bad_x", type = "error", session = getDefaultReactiveDomain())
          }
          req(info$stop)
        }
        table <- table[order(table$x2),]
        if (any(diff(table$x2) <= 0)) {
          bad_x <- which(diff(table$x2) <= 0)
          if (length(bad_x) > 10) {
            showNotification(HTML(paste("Negative or null increment in abscissa (probably 2 or more points at the same week epoch).<br>Check point", bad_x[1], "and many more ...")), action = NULL, duration = 10, closeButton = T, id = "bad_x", type = "error", session = getDefaultReactiveDomain())
          } else {
            showNotification(HTML(paste("Negative or null increment in abscissa (probably 2 or more points at the same week epoch).<br>Check points", paste(bad_x, collapse = " "))), action = NULL, duration = 10, closeButton = T, id = "bad_x", type = "error", session = getDefaultReactiveDomain())
          }
          req(info$stop)
        }
        table <- table[order(table$x3),]
        if (any(diff(table$x3) <= 0)) {
          bad_x <- which(diff(table$x3) <= 0)
          if (length(bad_x) > 10) {
            showNotification(HTML(paste("Negative or null increment in abscissa (probably 2 or more points at the same year epoch).<br>Check point", bad_x[1], "and many more ...")), action = NULL, duration = 10, closeButton = T, id = "bad_x", type = "error", session = getDefaultReactiveDomain())
          } else {
            showNotification(HTML(paste("Negative or null increment in abscissa (probably 2 or more points at the same year epoch).<br>Check points", paste(bad_x, collapse = " "))), action = NULL, duration = 10, closeButton = T, id = "bad_x", type = "error", session = getDefaultReactiveDomain())
          }
          req(info$stop)
        }
        table <- table[!is.infinite(rowSums(table)),]
        if (anyNA(table)) {
          table <- na.omit(table)
          showNotification(HTML("The primary series contains records with NA/NaN values.<br>These records were removed"), action = NULL, duration = 10, closeButton = T, id = "removing_NA", type = "warning", session = getDefaultReactiveDomain())
        }
      } else {
        shinyjs::delay(500, {
          showNotification("The input series is empty or has wrong format.", action = NULL, duration = 10, closeButton = T, id = "bad_series", type = "error", session = getDefaultReactiveDomain())
        })
        req(info$stop)
      }
      if (is.null(table)) {
        showNotification(HTML("All records in the series were removed.<br> Check the series format."), action = NULL, duration = 10, closeButton = T, id = "bad_series", type = "error", session = getDefaultReactiveDomain())
        req(info$stop)
      }
      # Extracting station coordinates
      coordinates <- as.numeric(extract_coordinates(filein,info$format,url$server,info$product1,url$station,sep))
      if (isTruthy(coordinates)) {
        lat <- coordinates[4]
        lon <- coordinates[5]
        shinyjs::delay(100, updateTextInput(session, inputId = "station_x", value = coordinates[1]))
        shinyjs::delay(100, updateTextInput(session, inputId = "station_y", value = coordinates[2]))
        shinyjs::delay(100, updateTextInput(session, inputId = "station_z", value = coordinates[3]))
        shinyjs::delay(100, updateTextInput(session, inputId = "station_lat", value = coordinates[4]))
        shinyjs::delay(100, updateTextInput(session, inputId = "station_lon", value = coordinates[5]))
      }
      # Fixing NEU/ENU if known
      if (isTruthy(url$server)) {
        disable("neuenu")
      }
      # Setting series units if known
      if (isTruthy(url$server)) {
        if (url$server == "EOSTLS" || url$server == "PSMSL") {
          updateRadioButtons(session, inputId = "sunits", selected = 2)
        } else {
          updateRadioButtons(session, inputId = "sunits", selected = 1)
        }
      } else if (info$format == 2 || info$format == 3) {
        updateRadioButtons(session, inputId = "sunits", selected = 1)
      } else {
        if (input$sunits == 0) {
          showNotification(HTML("Unknown units of the series.<br>If necessary, the series units can be set on the left panel."), action = NULL, duration = 10, closeButton = T, id = NULL, type = "warning", session = getDefaultReactiveDomain())
        }
      }
      # Setting plot limits
      if (!isTruthy(input$tunits) && isTruthy(info$tunits.known1)) {
        x <- table$x3
        info$tunits.last <- 3
      } else {
        if (input$tunits == 1) {
          x <- table$x1
        } else if (input$tunits == 2) {
          x <- table$x2
        } else if (input$tunits == 3) {
          x <- table$x3
        }
        info$tunits.last <- input$tunits
      }
      info$minx <- min(x, na.rm = T)
      info$maxx <- max(x, na.rm = T)
      ranges$x0 <- ranges$x1 <- c(info$minx, info$maxx)
      # Setting new tab names if necessary
      if (info$format == 1) { #NEU/ENU
        if (isTruthy(url$server) && url$server != "LOCAL") {
          info$components <- c("East component", "North component", "Up component", "3D", "Residuals")
          output$tabName1 <<- renderText({ info$components[1] })
          output$tabName2 <<- renderText({ info$components[2] })
          output$tabName3 <<- renderText({ info$components[3] })
          output$tabName4 <<- renderText({ info$components[4] })
          output$tabName5 <<- renderText({ info$components[5] })
        } else {
          extension <- tolower(rev(strsplit(as.character(file$primary$name), ".", fixed = T)[[1]])[1])
          if (isTruthy(extension) && (extension == "neu" || extension == "enu")) {
            info$components <- c("East component", "North component", "Up component", "3D", "Residuals")
            output$tabName1 <<- renderText({ info$components[1] })
            output$tabName2 <<- renderText({ info$components[2] })
            output$tabName3 <<- renderText({ info$components[3] })
            output$tabName4 <<- renderText({ info$components[4] })
            output$tabName5 <<- renderText({ info$components[5] })
          }
        }
      } else if (info$format == 4) { #1D
        output$tabName1 <- renderText({ "Series" })
      } else { #PBO & NGL
        info$components <- c("East component", "North component", "Up component", "3D", "Residuals")
        output$tabName1 <<- renderText({ info$components[1] })
        output$tabName2 <<- renderText({ info$components[2] })
        output$tabName3 <<- renderText({ info$components[3] })
        output$tabName4 <<- renderText({ info$components[4] })
        output$tabName5 <<- renderText({ info$components[5] })
      }
      if (info$components[1] != "East component" && info$format != 4) {
        info$components <- c("1st component", "2nd component", "3rd component", "3D", "Residuals")
        output$tabName1 <- renderText({ info$components[1] })
        output$tabName2 <- renderText({ info$components[2] })
        output$tabName3 <- renderText({ info$components[3] })
        output$tabName4 <- renderText({ info$components[4] })
        output$tabName5 <- renderText({ info$components[5] })
        showNotification(HTML("Unknown coordinate components in the primary series.<br>Assuming a ENU column format."), action = NULL, duration = 10, closeButton = T, id = "unknown_components", type = "warning", session = getDefaultReactiveDomain())
      }
      # Getting significant decimals from the primary series
      if (info$format == 4) {
        info$decimalsyList[1] <- decimalplaces(table$y,0)
        info$scientificList[1] <- info$scientific
        if (!isTruthy(info$decimalsyList[1])) {
          info$decimalsyList[1] <- 4
          showNotification(HTML("It was not possible to extract the number of decimal places from the series.<br>Using 4 decimal places by default."), action = NULL, duration = 10, closeButton = T, id = "no_decimals", type = "warning", session = getDefaultReactiveDomain())
        }
      } else {
        for (comp in seq(3)) {
          info$decimalsyList[comp] <- decimalplaces(table[[paste0("y",comp)]],0)
          info$scientificList[comp] <- info$scientific
          if (!isTruthy(info$decimalsyList[comp])) {
            info$decimalsyList[comp] <- 4
            showNotification(HTML(paste0("It was not possible to extract the number of decimal places from the series component ",comp,".<br>Using 4 decimal places by default.")), action = NULL, duration = 10, closeButton = T, id = "no_decimals", type = "warning", session = getDefaultReactiveDomain())
          }
        }
        info$decimalsyList[4] <- decimalplaces(c(table$y1,table$y2,table$y3),0)
        info$scientificList[4] <- info$scientific
      }
      # all good
      info$db1 <- "original"
      db1$original <- as.data.frame(table)
      db1$original$status1 <- db1$original$status2 <- db1$original$status3 <- rep(T, length(table$x1))
      # Setting primary station ID
      if (isTruthy(url$station)) {
        file$id1 <- toupper(url$station)
      } else {
        file$id1 <- toupper(strsplit(gsub(pattern = removes, replacement = "", x = input$series$name, ignore.case = T, perl = T, fixed = F), "\\.|_|\\s|-|\\(")[[1]][1])
      }
    ## secondary series ####
    } else if (series == 2) {
      # Setting column separation
      if (input$separator2 == "1") {
        sep2 <- ""
      } else if (input$separator2 == "2") {
        sep2 <- ","
      } else if (input$separator2 == "3") {
        sep2 <- ";"
      }
      # Getting secondary series
      table2 <- NULL
      if (isTruthy(url$file2) && isTruthy(url$station2)) {
        files <- file$secondary
      } else {
        if (input$optionSecondary < 1) {
          req(info$stop)
        }
        files <- input$series2
      }
      if (messages > 0) cat(file = stderr(), mySession, "Reading secondary series file", "\n")
      db2$original <- db2$resampled <- NULL
      table_stack <- NULL
      num <- length(files$datapath)
      if (url$server2 == "EOSTLS" && num > 1) {
        showNotification(HTML("Stacking the secondary series into one series."), action = NULL, duration = NULL, closeButton = T, id = "stacking", type = "warning", session = getDefaultReactiveDomain())
        if (any(grepl("ECCO", input$product2)) && any(grepl("TUGO", input$product2))) {
          showNotification(HTML("WARNING: the TUGO and ECCO models have similar forcing, which will be considered twice in the secondary series."), action = NULL, duration = 15, closeButton = T, id = NULL, type = "warning", session = getDefaultReactiveDomain())
        }
      }
      maxRows <- 1e0
      minRows <- 1e10
      for (i in seq_len(num)) {
        removeNotification(paste0("parsing_url2_",i))
        removeNotification("parsing_url2")
        # checking downloaded file
        if (!isTruthy(file.exists(files$datapath[i]))) {
          showNotification(paste("Problem downloading the", files$name[i], "series from the remote server."), action = NULL, duration = 10, closeButton = T, id = "bad_remote", type = "error", session = getDefaultReactiveDomain())
        } else {
          if (!isTruthy(info$format2)) {
            info$format2 <- input$format2
          }
          if (isTruthy(url$server2)) {
            server2 <- url$server2
          } else {
            server2 <- ""
          }
          table2 <- extract_table(files$datapath[i],sep2,info$format2,as.numeric(inputs$epoch2),as.numeric(inputs$variable2),as.numeric(inputs$errorBar2),input$ne,server2,2)
          # starting EOSTLS series at epoch .0, except for daily series
          if (url$server2 == "EOSTLS" && num > 1 && any(unique(table2$x1 %% 1) == 0)) {
            while (table2$x1[1] %% 1 > 0) {
              table2 <- table2[-1,]
            }
          }
          # Resampling the secondary series
          if (nchar(input$step2) > 0 && is.na(inputs$step2)) {
            if (is.na(as.numeric(input$step2))) {
              info$step2 <- NULL
              showNotification(HTML("The resampling period of the secondary series is not numeric.<br>Check input value."), action = NULL, duration = 10, closeButton = T, id = "bad_window", type = "error", session = getDefaultReactiveDomain())
            }
          } else if (isTruthy(inputs$step2)) {
            if (num > 1) {
              if (input$tunits == 1) {
                x <- table2$x1
              } else if (input$tunits == 2) {
                x <- table2$x2
              } else if (input$tunits == 3) {
                x <- table2$x3
              }
              if (inputs$step2 >= 2*min(diff(x,1)) && inputs$step2 <= (max(x) - min(x))/2) {
                tolerance <- min(diff(x,1))/3
                info$step2 <- inputs$step2
                withProgress(message = paste('Averaging the', files$name[i], 'series.'),
                             detail = 'This may take a while ...', value = 0, {
                               w <- as.integer((max(x) - min(x))/inputs$step2)
                               if (info$format2 == 4) {
                                 averaged <- sapply(1:w, function(p) average(p, x = x, y1 = table2$y1, y2 = NULL, y3 = NULL, sy1 = table2$sy1, sy2 = NULL, sy3 = NULL, tol = tolerance, w = w, s = inputs$step2, second = T, sigmas = F), simplify = T)
                                 table2 <- data.frame(x1 = averaged[1,], y1 = averaged[2,], sy1 = rep(1, length(table2$x)))
                               } else {
                                 if (url$server2 == "EOSTLS") {
                                   averaged <- sapply(1:w, function(p) average(p, x = x, y1 = table2$y1, y2 = table2$y2, y3 = table2$y3, sy1 = table2$sy1, sy2 = table2$sy2, sy3 = table2$sy3, tol = tolerance, w = w, s = inputs$step2, second = T, sigmas = F), simplify = T)
                                   table2 <- data.frame(x1 = averaged[1,], y1 = averaged[2,], y2 = averaged[3,], y3 = averaged[4,], sy1 = rep(1, length(averaged[1,])), sy2 = rep(1, length(averaged[1,])), sy3 = rep(1, length(averaged[1,])))
                                 } else {
                                   averaged <- sapply(1:w, function(p) average(p, x = x, y1 = table2$y1, y2 = table2$y2, y3 = table2$y3, sy1 = table2$sy1, sy2 = table2$sy2, sy3 = table2$sy3, tol = tolerance, w = w, s = inputs$step2, second = T, sigmas = T), simplify = T)
                                   table2 <- data.frame(x1 = averaged[1,], y1 = averaged[2,], y2 = averaged[3,], y3 = averaged[4,], sy1 = averaged[5,], sy2 = averaged[6,], sy3 = averaged[7,])
                                 }
                               }
                             })
                table2 <- na.omit(table2)
                if (input$tunits == 1) {
                  table2$x2 <- mjd2week(table2$x1)
                  table2$x3 <- mjd2year(table2$x1)
                } else if (input$tunits == 2) {
                  table2$x2 <- table2$x1
                  table2$x3 <- week2year(table2$x1)
                  table2$x1 <- week2mjd(table2$x1)
                } else if (input$tunits == 3) {
                  table2$x3 <- table2$x1
                  table2$x2 <- year2week(table2$x1)
                  table2$x1 <- year2mjd(table2$x1)
                }
              } else {
                info$step2 <- NULL
              }
            } else {
              info$redo_step2 <- info$redo_step2 + 1
            }
          } else {
            info$step2 <- NULL
          }
          # computing the sum of secondary series
          if (!is.null(table2)) {
            if (!is.null(table_stack)) {
              # shifting the next secondary series if necessary
              delta <- computeTimeShift(table_stack$x1,table2$x1)
              if (isTruthy(delta) && is.numeric(delta)) {
                if (abs(delta) > 0) {
                  table2$x1 <- table2$x1 + delta
                  table2$x2 <- mjd2week(table2$x1)
                  table2$x3 <- mjd2year(table2$x1)
                  showNotification(paste("The time axis of the", files$name[i], "series has been shifted by a constant",delta,info$tunits.label), action = NULL, duration = 10, closeButton = T, id = "time_shift", type = "warning", session = getDefaultReactiveDomain())
                }
              } else {
                if (info$sampling < info$sampling_regular) {
                  showNotification(paste("The sampling of the secondary series No.",i,"does not match the other secondary series."), action = NULL, duration = 10, closeButton = T, id = "bad_time_shift", type = "error", session = getDefaultReactiveDomain())
                } else {
                  showNotification(HTML(paste("The sampling of the", files$name[i], "series is not regular.<br>It is not possible to correct the secondary series.")), action = NULL, duration = 10, closeButton = T, id = "bad_time_shift", type = "error", session = getDefaultReactiveDomain())
                }
              }
              if (url$server2 == "EOSTLS") {
                table_stack_tmp <- data.frame(within(merge(table_stack,table2, by = "x1", all = T), {
                  x2 <- ifelse(is.na(x2.y),x2.x,x2.y)
                  x3 <- ifelse(is.na(x3.y),x3.x,x3.y)
                  y1 <- rowSums(cbind(y1.x, y1.y), na.rm = F)
                  y2 <- rowSums(cbind(y2.x, y2.y), na.rm = F)
                  y3 <- rowSums(cbind(y3.x, y3.y), na.rm = F)
                  sy1 <- sy2 <- sy3 <- 1e-9
                })[,c("x1","x2","x3","y1","y2","y3","sy1","sy2","sy3")])
              } else {
                table_stack_tmp <- data.frame(within(merge(table_stack,table2, by = "x1", all = T), {
                  x2 <- ifelse(is.na(x2.y),x2.x,x2.y)
                  x3 <- ifelse(is.na(x3.y),x3.x,x3.y)
                  y1 <- rowSums(cbind(y1.x, y1.y), na.rm = F)
                  y2 <- rowSums(cbind(y2.x, y2.y), na.rm = F)
                  y3 <- rowSums(cbind(y3.x, y3.y), na.rm = F)
                  sy1 <- sqrt(rowSums(cbind(sy1.x^2, sy1.y^2), na.rm = T))
                  sy2 <- sqrt(rowSums(cbind(sy2.x^2, sy2.y^2), na.rm = T))
                  sy3 <- sqrt(rowSums(cbind(sy3.x^2, sy3.y^2), na.rm = T))
                })[,c("x1","x2","x3","y1","y2","y3","sy1","sy2","sy3")])
              }
              nowRows <- nrow(table_stack_tmp)
              maxRows <- ifelse(maxRows > nowRows, maxRows, nowRows)
              table_stack <- na.omit(table_stack_tmp)
              nowRows <- nrow(table_stack)
              minRows <- ifelse(minRows < nowRows, minRows, nowRows)
              rm(table_stack_tmp)
            } else {
              table_stack <- table2
            }
          } else {
            showNotification(HTML(paste0("Wrong series format in ",files$name[i],".<br>Check the input file or the requested format.")), action = NULL, duration = 10, closeButton = T, id = NULL, type = "error", session = getDefaultReactiveDomain())
          }
        }
      }
      removeNotification("stacking")
      if (maxRows > minRows) {
        showNotification(paste("There are", minRows, "epochs in common between the secondary series out of", maxRows, "in total."), action = NULL, duration = 10, closeButton = T, id = NULL, type = "warning", session = getDefaultReactiveDomain())
      }
      # create secondary series merged file
      if (!is.null(table_stack)) {
        if (isTruthy(url$file2) && isTruthy(url$station2)) {
          info$last_optionSecondary <- 1
          updateRadioButtons(session, inputId = "optionSecondary", selected = 1)
        }
        if (anyNA(table_stack)) {
          table_stack <- na.omit(table_stack)
          showNotification(HTML("The secondary series contains records with NA/NaN values.<br>These records were removed"), action = NULL, duration = 10, closeButton = T, id = "removing_NA", type = "warning", session = getDefaultReactiveDomain())
        }
        table2 <- table_stack
        if (!is.null(table2)) {
          # writing the merged series into a file, unless the series were uploaded from local files
          if (isTruthy(url$station2) && dim(as.matrix(files$datapath))[1] > 1) {
            table_stack <- table_stack[,c("x1","y1","y2","y3")]
            names(table_stack) <- c("# MJD", "East", "North", "Up")
            suppressWarnings(write.table(x = format(table_stack, justify = "right", nsmall = 2, scientific = F), file = file$secondary$newpath, append = F, quote = F, sep = "\t", eol = "\n", na = "NA", dec = ".", row.names = F, col.names = T))
          } else {
            # Extracting station coordinates
            coordinates <- extract_coordinates(files$datapath[i],info$format2,url$server2,info$product2,url$station2,sep2)
            lat2 <- as.numeric(coordinates[4])
            lon2 <- as.numeric(coordinates[5])
            shinyjs::delay(100, updateTextInput(session, inputId = "station_x2", value = coordinates[1]))
            shinyjs::delay(100, updateTextInput(session, inputId = "station_y2", value = coordinates[2]))
            shinyjs::delay(100, updateTextInput(session, inputId = "station_z2", value = coordinates[3]))
            shinyjs::delay(100, updateTextInput(session, inputId = "station_lat2", value = coordinates[4]))
            shinyjs::delay(100, updateTextInput(session, inputId = "station_lon2", value = coordinates[5]))
          }
          rm(table_stack)
          info$db2 <- "original"
          db2$original <- as.data.frame(table2)
          output$fileSeries2 <- renderUI({
            if (input$optionSecondary == 1 && isTruthy(url$station2) && isTruthy(file$secondary$newpath)) {
              tags$a(href = sub(pattern = "www/", replacement = "", x = file$secondary$newpath), "Show secondary series file", title = "Open the file of the secondary series in a new tab", target = "_blank", download = file$secondary$newname)
            } else {
              NULL
            }
          })
          # Setting secondary station ID
          if (isTruthy(url$station2)) {
            file$id2 <- toupper(url$station2)
          } else {
            file$id2 <- try(toupper(strsplit(gsub(pattern = removes, replacement = "", x = input$series2$name, ignore.case = T, perl = T, fixed = F), "\\.|_|\\s|-|\\(")[[1]][1]), silent = T)
            if (inherits(file$id2,"try-error") || file$id2 == "") {
              file$id2 <- NULL
              showNotification(HTML("Problem extracting the series ID from the secondary file name.<br>No series ID will be used"), action = NULL, duration = 10, closeButton = T, id = "ids_info", type = "warning", session = getDefaultReactiveDomain())
            }
          }
        } else {
          showNotification("The secondary series is empty or it does not match the requested format.", action = NULL, duration = 10, closeButton = T, id = "bad_series", type = "error", session = getDefaultReactiveDomain())
        }
      } else {
        file$secondary <- NULL
        showNotification("The secondary series is empty or it does not match the requested format.", action = NULL, duration = 10, closeButton = T, id = "bad_series", type = "error", session = getDefaultReactiveDomain())
      }
    }
    # Updating station IDs
    if (isTruthy(file$id1) && isTruthy(file$id2)) {
      if (input$optionSecondary == 0) {
        ids_info <- file$id1
      } else if (input$optionSecondary == 1) {
        ids_info <- paste(file$id1,file$id2, sep = " & ")
      } else if (input$optionSecondary == 2) {
        ids_info <- paste(file$id1,file$id2, sep = " - ")
      } else if (input$optionSecondary == 3) {
        ids_info <- paste(file$id1,file$id2, sep = " : ")
      } else if (input$optionSecondary == 4) {
        ids_info <- paste(file$id1,file$id2, sep = " + ")
      }
    } else if (isTruthy(file$id1)) {
      ids_info <- file$id1
    } else {
      ids_info <- ""
      removeNotification(id = "ids_info", session = getDefaultReactiveDomain())
      showNotification(HTML("Problem extracting the series ID from the file name.<br>No series ID will be used"), action = NULL, duration = 10, closeButton = T, id = "ids_info", type = "warning", session = getDefaultReactiveDomain())
    }
    shinyjs::delay(100, updateTextInput(session, inputId = "ids", value = ids_info))
  }
  #
  extract_table <- function(file,sep,format,epoch,variable,errorBar,swap,server,series) {
    tableAll <- NULL
    extracted <- NULL
    if (series == 1) {
      seriesClass <- "primary"
    } else if (series == 2) {
      seriesClass <- "secondary"
    }
    if (input$optionSecondary > 1 && isTruthy(db1$merged)) {
      info$last_optionSecondary <- 1
      updateRadioButtons(session, inputId = "optionSecondary", selected = 1)
    }
    removeNotification("no_weeks")
    removeNotification("no_error_bars")
    removeNotification("bad_coordinates")
    removeNotification("bad_pole")
    removeNotification("no_rotation")
    removeNotification("no_values")
    removeNotification("no_epos")
    removeNotification("bad_sigmas")
    removeNotification("no_tunits")
    # NEU/ENU ####
    if (format == 1) { #NEU/ENU
      skip <- 0
      a <- 6378137
      b <- 6356752.314140347
      e2 <- (a^2 - b^2) / a^2
      tunitsKnown <- F
      spotgins2 <- try(grepl("^# SPOTGINS SOLUTION \\[POSITION\\]$|^# SPOTGINS SOLUTION \\[POSITION\\] v2$", readLines(file, n = 1, warn = F), perl = T), silent = T)
      spotgins3 <- try(grepl("# SPOTGINS SOLUTION [POSITION] v3", readLines(file, n = 1, warn = F), fixed = T), silent = T)
      # extracting series from SIRGAS format and transforming lat lon into ENU format
      if (server == "SIRGAS") {
        sirgas_new <- grep(" IGb14 ", readLines(file, warn = F), ignore.case = F, value = T, fixed = T)
        tableAll <- try(read.table(text = sirgas_new)[,c("V3", "V7", "V8", "V9", "V10", "V11", "V12")], silent = T)
        N <- a / sqrt( 1 - e2 * sin(tableAll[,2]*pi/180)^2) + tableAll[,3]
        dn <- N * (tableAll[,2] - tableAll[1,2]) * pi/180
        dn <- as.numeric(sprintf(fmt = "%.6f", dn))
        sdn <- N * tableAll[,5] * pi/180
        sdn <- as.numeric(sprintf(fmt = "%.6f", sdn))
        de <- N * (tableAll[,3] - tableAll[1,3]) * pi/180 * cos(tableAll[,2]*pi/180)
        de <- as.numeric(sprintf(fmt = "%.6f", de))
        sde <- N * tableAll[,6] * pi/180 * cos(tableAll[,2]*pi/180)
        sde <- as.numeric(sprintf(fmt = "%.6f", sde))
        tableAll <- cbind(de, dn, sde, sdn, tableAll)[,c(5,1,2,8,3,4,11)]
        tableAll[,4] <- as.numeric(sprintf(fmt = "%.6f", tableAll[,4]))
        tableAll[,7] <- as.numeric(sprintf(fmt = "%.6f", tableAll[,7]))
      } else if (server == "EARTHSCOPE") { # extracting ENU format from UNAVCO series
        unavco_new <- grep("^Datetime,", grep("^#", readLines(file, warn = F), ignore.case = F, value = T, perl = T, invert = T), ignore.case = F, value = T, perl = T, invert = T)
        tableAll <- try(read.table(text = unavco_new, sep = ",")[,c("V1", "V15", "V14", "V16", "V17", "V18", "V19")], silent = T)
      } else if (server == "EPOS") { # extracting ENU format from EPOS JSON series
        tableAll <- try(fromJSON(txt = file), silent = T)
        if (isTruthy(tableAll) && !inherits(tableAll,"try-error")) {
          tableAll <- tableAll$results[, c("epoch", "de", "dn", "du", "se", "sn", "su")]
        } else {
          showNotification("No series was downloaded from the EPOS server.", action = NULL, duration = 10, closeButton = T, id = "no_epos", type = "error", session = getDefaultReactiveDomain())
          req(info$stop)
        }
      } else if (server == "DORIS") { # extracting ENU format from DORIS JSON series
        tableAll <- try(fromJSON(txt = file), silent = T)
        if (isTruthy(tableAll) && !inherits(tableAll, "try-error")) {
          tableAll <- tableAll[, c("date", "de", "dn", "du", "se", "sn", "su")]
          tableAll[,c("de", "dn", "du", "se", "sn", "su")] <- tableAll[,c("de", "dn", "du", "se", "sn", "su")]/1000
        } else {
          showNotification("No series was downloaded from the DORIS server.", action = NULL, duration = 10, closeButton = T, id = "no_epos", type = "error", session = getDefaultReactiveDomain())
          req(info$stop)
        }
      } else {
        tableAll <- try(read.table(text = trimws(readLines(file, warn = F)), comment.char = "#", sep = sep, skip = skip), silent = T)
      }
      # extracting series from SONEL format into ENU format
      if (server == "SONEL") {
        tableAll <- tableAll[, c("V1", "V3", "V2", "V4", "V6", "V5", "V7")]
      }
      # extracting series from EOSTLS format into ENU format
      if (server == "EOSTLS") {
        tableAll <- tableAll[, c("V1", "V3", "V2", "V4")]
      }
      # transforming series from IGS lat lon into ENU format
      if (server == "IGS") {
        N <- a / sqrt( 1 - e2 * sin(tableAll[,5]*pi/180)^2) + tableAll[,7]
        dn <- N * (tableAll[,5] - tableAll[1,5]) * pi/180
        dn <- as.numeric(sprintf(fmt = "%.6f", dn))
        sdn <- N * tableAll[,8] * pi/180
        sdn <- as.numeric(sprintf(fmt = "%.6f", sdn))
        de <- N * (tableAll[,6] - tableAll[1,6]) * pi/180 * cos(tableAll[,5]*pi/180)
        de <- as.numeric(sprintf(fmt = "%.6f", de))
        sde <- N * tableAll[,9] * pi/180 * cos(tableAll[,5]*pi/180)
        sde <- as.numeric(sprintf(fmt = "%.6f", sde))
        tableAll <- cbind(de, dn, sde, sdn, tableAll)[,c(7,1,2,11,3,4,14,5,6)]
        tableAll[,4] <- as.numeric(sprintf(fmt = "%.6f", tableAll[,4]))
        tableAll[,7] <- as.numeric(sprintf(fmt = "%.6f", tableAll[,7]))
      }
      # extracting data in columns
      if (isTruthy(tableAll)) {
        columns <- dim(tableAll)[2]
        if (columns > 3) {
          extension <- tolower(strsplit(basename(file), ".", fixed = T)[[1]][-1])
          if (server == "" && isTruthy(extension) && extension == "neu") {
            swap <- T
          }
          if (isTruthy(swap)) {
            extracted <- tableAll[,c(3,2,4)]
          } else {
            extracted <- tableAll[,c(2,3,4)]
          }
          names(extracted) <- c("y1","y2","y3")
          if (columns > 6) {
            if (isTruthy(swap)) {
              extracted$sy1 <- tableAll[,6]
              extracted$sy2 <- tableAll[,5]
              extracted$sy3 <- tableAll[,7]
            } else {
              extracted$sy1 <- tableAll[,5]
              extracted$sy2 <- tableAll[,6]
              extracted$sy3 <- tableAll[,7]
            }
          } else {
            extracted$sy1 <- extracted$sy2 <- extracted$sy3 <- rep(1e-9,length(extracted$y1))
            # if (server != "EOSTLS" || series != 2) {
            if (series != 2) {
              info$errorbars <- F
            }
          }
          # get different time units
          if (isTruthy(extracted) && all(sapply(extracted, is.numeric))) {
            if (server == "JPL") {
              if (series == 1) {
                info$tunits.known1 <- T
              } else if (series == 2) {
                info$tunits.known2 <- T
              }
              days <- difftime(strptime(paste(sprintf("%4d",tableAll[,12]),sprintf("%02d",tableAll[,13]),sprintf("%02d",tableAll[,14]),sprintf("%02d",tableAll[,15]),sprintf("%02d",tableAll[,16]),sprintf("%02d",tableAll[,17])), format = '%Y %m %d %H %M %S', tz = "GMT"), strptime(paste(sprintf("%08d",18581117),sprintf("%06d",000000)),format = '%Y%m%d %H%M%S', tz = "GMT"), units = "days")
              extracted$x1 <- as.numeric(sprintf("%.*f", 5, days))
              extracted$x2 <- mjd2week(extracted$x1)
              extracted$x3 <- mjd2year(extracted$x1)
              if (series == 1) {
                info$samplingRaw[1] <- min(diff(days,1))
                info$samplingRaw[2] <- info$samplingRaw[1]/7
                info$samplingRaw[3] <- info$samplingRaw[1]/daysInYear
              } else {
                info$samplingRaw2[1] <- min(diff(days,1))
                info$samplingRaw2[2] <- info$samplingRaw[1]/7
                info$samplingRaw2[3] <- info$samplingRaw[1]/daysInYear
              }
            } else if (server == "SONEL") {
              if (series == 1) {
                info$tunits.known1 <- T
              } else if (series == 2) {
                info$tunits.known2 <- T
              }
              extracted$x1 <- year2mjd(tableAll[,1])
              extracted$x2 <- year2week(tableAll[,1])
              extracted$x3 <- tableAll[,1]
              if (series == 1) {
                info$samplingRaw[3] <- min(diff(extracted$x3,1))
                info$samplingRaw[1] <- info$samplingRaw[3]*daysInYear
                info$samplingRaw[2] <- info$samplingRaw[1]/7
              } else {
                info$samplingRaw2[3] <- min(diff(extracted$x3,1))
                info$samplingRaw2[1] <- info$samplingRaw[3]*daysInYear
                info$samplingRaw2[2] <- info$samplingRaw[1]/7
              }
            } else if (server == "SIRGAS") {
              if (series == 1) {
                info$tunits.known1 <- T
              } else if (series == 2) {
                info$tunits.known2 <- T
              }
              days <- difftime(as.Date("1980-01-06") + tableAll[,1] * 7 + 3, strptime(paste(sprintf("%08d",18581117),sprintf("%06d",000000)), format = '%Y%m%d %H%M%S', tz = "GMT"), units = "days")
              extracted$x1 <- as.numeric(sprintf("%.*f", 0, days))
              extracted$x2 <- mjd2week(extracted$x1)
              extracted$x3 <- mjd2year(extracted$x1)
              if (series == 1) {
                info$samplingRaw[1] <- min(diff(days,1))
                info$samplingRaw[2] <- info$samplingRaw[1]/7
                info$samplingRaw[3] <- info$samplingRaw[1]/daysInYear
              } else {
                info$samplingRaw2[1] <- min(diff(days,1))
                info$samplingRaw2[2] <- info$samplingRaw[1]/7
                info$samplingRaw2[3] <- info$samplingRaw[1]/daysInYear
              }
            } else if (server == "IGS") {
              if (series == 1) {
                info$tunits.known1 <- T
              } else if (series == 2) {
                info$tunits.known2 <- T
              }
              extracted$x1 <- as.numeric(sprintf("%.*f", 1, tableAll[,1]))
              extracted$x2 <- as.numeric(sprintf("%.*f", 2, tableAll[,8] + tableAll[,9]/7))
              extracted$x3 <- mjd2year(extracted$x1)
              if (series == 1) {
                info$samplingRaw[1] <- min(diff(tableAll[,1],1))
                info$samplingRaw[2] <- info$samplingRaw[1]/7
                info$samplingRaw[3] <- info$samplingRaw[1]/daysInYear
              } else {
                info$samplingRaw2[1] <- min(diff(tableAll[,1],1))
                info$samplingRaw2[2] <- info$samplingRaw[1]/7
                info$samplingRaw2[3] <- info$samplingRaw[1]/daysInYear
              }
            } else if (isTruthy(spotgins2) || isTruthy(spotgins3)) { # SPOTGINS series
              if (series == 1) {
                info$tunits.known1 <- T
              } else if (series == 2) {
                info$tunits.known2 <- T
              }
              extracted$x1 <- as.numeric(sprintf("%.*f", 1, tableAll[,1]))
              if (isTruthy(spotgins2)) {
                extracted$x2 <- as.numeric(sprintf("%.*f", 2, difftime(strptime(tableAll[,8], format = '%Y%m%d', tz = "GMT"), strptime(paste(sprintf("%08d",19800106),sprintf("%06d",000000)),format = '%Y%m%d %H%M%S', tz = "GMT"), units = "weeks")))
                extracted$x3 <- as.numeric(sprintf("%.*f", 4, tableAll[,9]))
              } else if (isTruthy(spotgins3)) {
                extracted$x2 <- as.numeric(sprintf("%.*f", 2, difftime(strptime(tableAll[,11], format = '%Y-%m-%d', tz = "GMT"), strptime(paste(sprintf("%08d",19800106),sprintf("%06d",000000)),format = '%Y%m%d %H%M%S', tz = "GMT"), units = "weeks")))
                extracted$x3 <- as.numeric(sprintf("%.*f", 4, tableAll[,12]))
              }
              if (series == 1) {
                info$samplingRaw[1] <- min(diff(tableAll[,1],1))
                info$samplingRaw[2] <- info$samplingRaw[1]/7
                info$samplingRaw[3] <- info$samplingRaw[1]/daysInYear
              } else {
                info$samplingRaw2[1] <- min(diff(tableAll[,1],1))
                info$samplingRaw2[2] <- info$samplingRaw[1]/7
                info$samplingRaw2[3] <- info$samplingRaw[1]/daysInYear
              }
            } else if (server == "EARTHSCOPE") {
              if (series == 1) {
                info$tunits.known1 <- T
              } else if (series == 2) {
                info$tunits.known2 <- T
              }
              extracted$x1 <- as.numeric(difftime(as.Date(tableAll[,1]), strptime(paste(sprintf("%08d",18581117),sprintf("%06d",000000)),format = '%Y%m%d %H%M%S', tz = "GMT"), units = "days"))
              extracted$x2 <- mjd2week(extracted$x1)
              extracted$x3 <- mjd2year(extracted$x1)
              if (series == 1) {
                info$samplingRaw[1] <- min(diff(extracted$x1,1))
                info$samplingRaw[2] <- info$samplingRaw[1]/7
                info$samplingRaw[3] <- info$samplingRaw[1]/daysInYear
              } else {
                info$samplingRaw2[1] <- min(diff(extracted$x1,1))
                info$samplingRaw2[2] <- info$samplingRaw[1]/7
                info$samplingRaw2[3] <- info$samplingRaw[1]/daysInYear
              }
            } else if (server == "EOSTLS") {
              if (series == 1) {
                info$tunits.known1 <- T
              } else if (series == 2) {
                info$tunits.known2 <- T
              }
              extracted$x1 <- tableAll[,1]
              extracted$x2 <- mjd2week(extracted$x1)
              extracted$x3 <- mjd2year(extracted$x1)
              if (series == 1) {
                info$samplingRaw[1] <- min(diff(tableAll[,1],1))
                info$samplingRaw[2] <- info$samplingRaw[1]/7
                info$samplingRaw[3] <- info$samplingRaw[1]/daysInYear
              } else {
                info$samplingRaw2[1] <- min(diff(tableAll[,1],1))
                info$samplingRaw2[2] <- info$samplingRaw[1]/7
                info$samplingRaw2[3] <- info$samplingRaw[1]/daysInYear
              }
            } else { #plain ENU series
              # ISO 8601 dates
              if (all(isTruthy(suppressWarnings(parse_date_time(tableAll[,1], c("%Y-%m-%dT%H:%M:%S%z", "%Y-%m-%dT%H:%M:%S", "%Y-%m-%d %H:%M:%S"), exact = T))))) {
                if (series == 1) {
                  info$tunits.known1 <- T
                } else if (series == 2) {
                  info$tunits.known2 <- T
                }
                updateRadioButtons(session, inputId = "tunits", selected = 1)
                extracted$x1 <- as.numeric(difftime(ymd_hms(tableAll[,1]), strptime(paste(sprintf("%08d",18581117),sprintf("%06d",000000)),format = '%Y%m%d %H%M%S', tz = "GMT"), units = "days"))
                extracted$x1 <- as.numeric(formatting(extracted$x1,1))
                extracted$x2 <- mjd2week(extracted$x1)
                extracted$x3 <- mjd2year(extracted$x1)
                if (series == 1) {
                  info$samplingRaw[1] <- min(diff(extracted$x1,1))
                  info$samplingRaw[2] <- info$samplingRaw[1]/7
                  info$samplingRaw[3] <- info$samplingRaw[1]/daysInYear
                } else {
                  info$samplingRaw2[1] <- min(diff(extracted$x1,1))
                  info$samplingRaw2[2] <- info$samplingRaw[1]/7
                  info$samplingRaw2[3] <- info$samplingRaw[1]/daysInYea
                }
              } else {
                if (!isTruthy(input$tunits)) {
                  showNotification("The time units of the series must be set before plotting.", action = NULL, duration = 10, closeButton = T, id = "no_tunits", type = "error", session = getDefaultReactiveDomain())
                  req(info$stop)
                }
                # assuming the time units set by the user are good
                if (input$tunits == 1) {
                  extracted$x1 <- tableAll[,1]
                  extracted <- suppressWarnings(extracted[apply(extracted, 1, function(r) !any(is.na(as.numeric(r)))) ,])
                  if (nrow(extracted) == 0) {
                    return(NULL)
                  }
                  extracted$x2 <- mjd2week(extracted$x1)
                  extracted$x3 <- mjd2year(extracted$x1)
                  if (series == 1) {
                    info$samplingRaw[1] <- min(diff(extracted$x1,1))
                    info$samplingRaw[2] <- info$samplingRaw[1]/7
                    info$samplingRaw[3] <- info$samplingRaw[1]/daysInYear
                  } else {
                    info$samplingRaw2[1] <- min(diff(extracted$x1,1))
                    info$samplingRaw2[2] <- info$samplingRaw[1]/7
                    info$samplingRaw2[3] <- info$samplingRaw[1]/daysInYear
                  }
                } else if (input$tunits == 2) {
                  extracted$x2 <- tableAll[,1]
                  extracted <- suppressWarnings(extracted[apply(extracted, 1, function(r) !any(is.na(as.numeric(r)))) ,])
                  if (nrow(extracted) == 0) {
                    return(NULL)
                  }
                  extracted$x1 <- week2mjd(extracted$x2)
                  extracted$x3 <- week2year(extracted$x2)
                  if (series == 1) {
                    info$samplingRaw[2] <- min(diff(extracted$x2,1))
                    info$samplingRaw[1] <- info$samplingRaw[2]*7
                    info$samplingRaw[3] <- info$samplingRaw[1]/daysInYear
                  } else {
                    info$samplingRaw2[2] <- min(diff(extracted$x2,1))
                    info$samplingRaw2[1] <- info$samplingRaw[2]*7
                    info$samplingRaw2[3] <- info$samplingRaw[1]/daysInYear
                  }
                } else if (input$tunits == 3) {
                  extracted$x3 <- tableAll[,1]
                  extracted <- suppressWarnings(extracted[apply(extracted, 1, function(r) !any(is.na(as.numeric(r)))) ,])
                  if (nrow(extracted) == 0) {
                    return(NULL)
                  }
                  extracted$x1 <- year2mjd(extracted$x3)
                  extracted$x2 <- year2week(extracted$x3)
                  if (series == 1) {
                    info$samplingRaw[3] <- min(diff(extracted$x3,1))
                    info$samplingRaw[1] <- info$samplingRaw[3]*daysInYear
                    info$samplingRaw[2] <- info$samplingRaw[1]/7
                  } else {
                    info$samplingRaw2[3] <- min(diff(extracted$x3,1))
                    info$samplingRaw2[1] <- info$samplingRaw[3]*daysInYear
                    info$samplingRaw2[2] <- info$samplingRaw[1]/7
                  }
                }
              }
            }
            extracted <- suppressWarnings(extracted[apply(extracted, 1, function(r) !any(is.na(as.numeric(r)))) ,])
            extracted <- extracted[!duplicated(extracted),]
          }
        }
      } else {
        errorInfo <- gsub("\n", "", gsub("(.|\\\\s)*?  ", "", tableAll[1]))
        if (isTruthy(errorInfo)) {
          errorInfo <- paste(errorInfo, "(skipping comment lines)")
        }
        showNotification(HTML(paste("Format error when reading the input NEU/ENU file.<br>", errorInfo)), action = NULL, duration = 10, closeButton = T, id = "no_values", type = "error", session = getDefaultReactiveDomain())
        req(info$stop)
      }
    # PBO ####
    } else if (format == 2) { #PBO
      skip <- which(grepl("YYYYMMDD HHMMSS JJJJJ.JJJJ", readLines(file, warn = F)))
      tableAll <- try(read.table(file, comment.char = "#", sep = sep, skip = skip), silent = T)
      if (isTruthy(tableAll) && !inherits(tableAll,"try-error")) {
        if (series == 1) {
          info$tunits.known1 <- T
        } else if (series == 2) {
          info$tunits.known2 <- T
        }
        if (isTruthy(swap)) {
          extracted <- tableAll[,c(16,17,18,19,20,21)]
        } else {
          extracted <- tableAll[,c(17,16,18,20,19,21)]
        }
        names(extracted) <- c("y1","y2","y3","sy1","sy2","sy3")
        extracted$x1 <- tableAll[,3]
        extracted$x2 <- mjd2week(extracted$x1)
        extracted$x3 <- mjd2year(extracted$x1)
        if (series == 1) {
          info$samplingRaw[1] <- min(diff(tableAll[,3],1))
          info$samplingRaw[2] <- info$samplingRaw[1]/7
          info$samplingRaw[3] <- info$samplingRaw[1]/daysInYear
        } else {
          info$samplingRaw2[1] <- min(diff(tableAll[,3],1))
          info$samplingRaw2[2] <- info$samplingRaw[1]/7
          info$samplingRaw2[3] <- info$samplingRaw[1]/daysInYear
        }
      }
    ## NGL ####
    } else if (format == 3) { #NGL
      skip <- which(grepl("site YYMMMDD", readLines(file, warn = F)))
      tableAll <- try(read.table(file, comment.char = "#", sep = sep, skip = skip), silent = T)
      if (isTruthy(tableAll) && !inherits(tableAll,"try-error")) {
        if (series == 1) {
          info$tunits.known1 <- T
        } else if (series == 2) {
          info$tunits.known2 <- T
        }
        extracted <- data.frame(x1 = tableAll[,4])
        extracted$x2 <- as.numeric(sprintf("%.*f", 2, tableAll[,5] + tableAll[,6]/7))
        extracted$x3 <- mjd2year(extracted$x1)
        if (series == 1) {
          info$samplingRaw[1] <- min(diff(extracted$x1,1))
          info$samplingRaw[2] <- info$samplingRaw[1]/7
          info$samplingRaw[3] <- info$samplingRaw[1]/daysInYear
        } else {
          info$samplingRaw2[1] <- min(diff(extracted$x1,1))
          info$samplingRaw2[2] <- info$samplingRaw[1]/7
          info$samplingRaw2[3] <- info$samplingRaw[1]/daysInYear
        }
        if (isTruthy(swap)) {
          extracted$y2 <- tableAll[,8] - tableAll[1,8] + tableAll[,9] #East
          extracted$y1 <- tableAll[,10] - tableAll[1,10] + tableAll[,11] #North
          extracted$sy2 <- tableAll[,15]
          extracted$sy1 <- tableAll[,16]
        } else {
          extracted$y1 <- tableAll[,8] - tableAll[1,8] + tableAll[,9] #East (the coordinate integer portion seems to be constant, but just in case)
          extracted$y2 <- tableAll[,10] - tableAll[1,10] + tableAll[,11] #North
          extracted$sy1 <- tableAll[,15]
          extracted$sy2 <- tableAll[,16]
        }
        extracted$y3 <- tableAll[,12] - tableAll[1,12] + tableAll[,13] #Up
        extracted$sy3 <- tableAll[,17]
      }
      ## 1D ####
    } else if (format == 4) { #1D
      if (!is.na(epoch) && is.numeric(epoch) && epoch > 0 && !is.na(variable) && is.numeric(variable) && variable > 0 && epoch != variable) {
        if (server == "PSMSL") {
          tableAll <- try(read.table(file, sep = ";"), silent = T)
          tableAll <- tableAll[tableAll$V2 != -99999,]
          columns <- 2
        } else {
          skip <- 0
          tableAll <- try(read.table(text = trimws(readLines(file, warn = F)), comment.char = "#", sep = sep, skip = skip), silent = T)
          columns <- dim(tableAll)[2]
        }
        if (isTruthy(tableAll) && !inherits(tableAll,"try-error")) {
          if (epoch <= columns && variable <= columns) {
            if (all(sapply(tableAll[[variable]], is.numeric))) {
              extracted <- data.frame(y1 = tableAll[[variable]])
              # ISO 8601 dates
              if (all(isTruthy(suppressWarnings(parse_date_time(tableAll[[epoch]], c("%Y-%m-%dT%H:%M:%S%z", "%Y-%m-%dT%H:%M:%S"), exact = T))))) {
                if (series == 1) {
                  info$tunits.known1 <- T
                } else if (series == 2) {
                  info$tunits.known2 <- T
                }
                updateRadioButtons(session, inputId = "tunits", selected = 1)
                extracted$x1 <- as.numeric(difftime(ymd_hms(tableAll[[epoch]]), strptime(paste(sprintf("%08d",18581117),sprintf("%06d",000000)),format = '%Y%m%d %H%M%S', tz = "GMT"), units = "days"))
                extracted$x2 <- mjd2week(extracted$x1)
                extracted$x3 <- mjd2year(extracted$x1)
                if (series == 1) {
                  info$samplingRaw[1] <- min(diff(extracted$x1,1))
                  info$samplingRaw[2] <- info$samplingRaw[1]/7
                  info$samplingRaw[3] <- info$samplingRaw[1]/daysInYear
                } else {
                  info$samplingRaw2[1] <- min(diff(extracted$x1,1))
                  info$samplingRaw2[2] <- info$samplingRaw[1]/7
                  info$samplingRaw2[3] <- info$samplingRaw[1]/daysInYear
                }
              } else if (server == "PSMSL") {
                if (series == 1) {
                  info$tunits.known1 <- T
                } else if (series == 2) {
                  info$tunits.known2 <- T
                }
                extracted$x1 <- year2mjd(tableAll[,1])
                extracted$x2 <- year2week(tableAll[,1])
                extracted$x3 <- tableAll[,1]
                if (series == 1) {
                  info$samplingRaw[3] <- min(diff(extracted$x3,1))
                  info$samplingRaw[1] <- info$samplingRaw[3]*daysInYear
                  info$samplingRaw[2] <- info$samplingRaw[1]/7
                } else {
                  info$samplingRaw2[3] <- min(diff(extracted$x3,1))
                  info$samplingRaw2[1] <- info$samplingRaw[3]*daysInYear
                  info$samplingRaw2[2] <- info$samplingRaw[1]/7
                }
              } else {
                if (!isTruthy(input$tunits)) {
                  showNotification("The time units of the series must be set before plotting.", action = NULL, duration = 10, closeButton = T, id = "no_tunits", type = "error", session = getDefaultReactiveDomain())
                  req(info$stop)
                }
                # assuming the time units set by the user are good
                if (all(sapply(tableAll[[epoch]], is.numeric))) {
                  extracted$x1 <- tableAll[[epoch]]
                  if (input$tunits == 1) {
                    extracted$x2 <- mjd2week(extracted$x1)
                    extracted$x3 <- mjd2year(extracted$x1)
                    if (series == 1) {
                      info$samplingRaw[1] <- min(diff(extracted$x1,1))
                      info$samplingRaw[2] <- info$samplingRaw[1]/7
                      info$samplingRaw[3] <- info$samplingRaw[1]/daysInYear
                    } else {
                      info$samplingRaw2[1] <- min(diff(extracted$x1,1))
                      info$samplingRaw2[2] <- info$samplingRaw[1]/7
                      info$samplingRaw2[3] <- info$samplingRaw[1]/daysInYear
                    }
                  } else if (input$tunits == 2) {
                    extracted$x2 <- extracted$x1
                    extracted$x1 <- week2mjd(extracted$x2)
                    extracted$x3 <- week2year(extracted$x2)
                    if (series == 1) {
                      info$samplingRaw[2] <- min(diff(extracted$x2,1))
                      info$samplingRaw[1] <- info$samplingRaw[2]*7
                      info$samplingRaw[3] <- info$samplingRaw[1]/daysInYear
                    } else {
                      info$samplingRaw2[2] <- min(diff(extracted$x2,1))
                      info$samplingRaw2[1] <- info$samplingRaw[2]*7
                      info$samplingRaw2[3] <- info$samplingRaw[1]/daysInYear
                    }
                  } else if (input$tunits == 3) {
                    extracted$x3 <- extracted$x1
                    extracted$x1 <- year2mjd(extracted$x3)
                    extracted$x2 <- year2week(extracted$x3)
                    if (series == 1) {
                      info$samplingRaw[3] <- min(diff(extracted$x3,1))
                      info$samplingRaw[1] <- info$samplingRaw[3]*daysInYear
                      info$samplingRaw[2] <- info$samplingRaw[1]/7
                    } else {
                      info$samplingRaw2[3] <- min(diff(extracted$x3,1))
                      info$samplingRaw2[1] <- info$samplingRaw[3]*daysInYear
                      info$samplingRaw2[2] <- info$samplingRaw[1]/7
                    }
                  }
                } else {
                  showNotification(HTML(paste("Non numeric values extracted from the input", seriesClass, "series.<br>Check the input file or the requested format.")), action = NULL, duration = 10, closeButton = T, id = "no_values", type = "error", session = getDefaultReactiveDomain())
                  req(info$stop)
                }
              }
              if (columns > 2) {
                if (input$sigmas == T) {
                  if (!is.na(errorBar) && is.numeric(errorBar) && errorBar > 0 && errorBar <= columns && errorBar != epoch && errorBar != variable) {
                    extracted$sy1 <- tableAll[[errorBar]]
                  } else {
                    showNotification(HTML("Invalid column number for the series error bars.<br>Provide a valid column number or uncheck the error bars option."), action = NULL, duration = 10, closeButton = T, id = "no_error_bars", type = "error", session = getDefaultReactiveDomain())
                    req(info$stop)
                  }
                } else {
                  extracted$sy1 <- rep(1e-9,length(extracted$y1))
                  if (series != 2) {
                    info$errorbars <- F
                    disable("sigmas")
                  }
                }
              } else {
                if (input$sigmas == T) {
                  showNotification(HTML("Invalid column number for the series error bars.<br>Provide a valid column number or uncheck the error bars option."), action = NULL, duration = 10, closeButton = T, id = "no_error_bars", type = "error", session = getDefaultReactiveDomain())
                  req(info$stop)
                }
                extracted$sy1 <- rep(1e-9,length(extracted$y1))
                if (series != 2) {
                  info$errorbars <- F
                  disable("sigmas")
                }
              }
              if (isTruthy(extracted)) {
                extracted <- suppressWarnings(extracted[apply(extracted, 1, function(r) !any(is.na(as.numeric(r)))) ,])
              }
            } else {
              extracted <- NULL
            }
          }
        }
      }
    }
    if (!isTruthy(input$tunits)) {
      if (isTruthy(info$tunits.known1)) {
        updateRadioButtons(session, inputId = "tunits", selected = 3)
      } else {
        showNotification("The time units of the series must be set before plotting.", action = NULL, duration = 10, closeButton = T, id = "no_tunits", type = "error", session = getDefaultReactiveDomain())
        req(info$stop)
      }
    }
    if (!is.null(extracted) && all(sapply(extracted, is.numeric))) {
      # checking the error bars
      if (any(extracted[,grepl("sy", names(extracted))] <= 0)) {
        extracted[,grepl("sy", names(extracted))] <- rep(1, length(extracted$y1))
        info$errorbars <- F
        showNotification(HTML("Negative or null error bars extracted from the input series.<br>The use of the error bars has been deactivated."), action = NULL, duration = 10, closeButton = T, id = "bad_sigmas", type = "error", session = getDefaultReactiveDomain())
      }
      extracted
    } else {
      showNotification(HTML(paste("Non numeric values extracted from the input", seriesClass, "series.<br>Check the input file or the requested format.")), action = NULL, duration = 10, closeButton = T, id = "no_values", type = "error", session = getDefaultReactiveDomain())
      req(info$stop)
    }
  }
  #
  extract_coordinates <- function(filein,format,server,product,station,sep) {
    coordinates <- NULL
    if (format == 1) {
      if (isTruthy(server) && server != "LOCAL") {
        if (server == "FORMATERRE") {
          coordinates <- unlist(strsplit(grep("_pos ", readLines(filein, warn = F), ignore.case = F, value = T, perl = T), "\\s+", fixed = F, perl = T, useBytes = F))[c(4,8,12)]
          if (length(coordinates) == 3) {
            shinyjs::delay(100, updateRadioButtons(session, inputId = "station_coordinates", selected = 1))
            stationGeo <- do.call(xyz2llh,as.list(as.numeric(c(coordinates[1],coordinates[2],coordinates[3]))))
            lat <- sprintf("%.6f", stationGeo[1] * 180/pi)
            lon <- sprintf("%.6f", stationGeo[2] * 180/pi)
            coordinates <- c(coordinates,lat,lon)
          } else {
            coordinates <- NULL
          }
        } else if (server == "SONEL") {
          coordinates <- unlist(strsplit(grep("^# X : |^# Y : |^# Z : ", readLines(filein, warn = F), ignore.case = F, value = T, perl = T), "\\s+", fixed = F, perl = T, useBytes = F))[c(4,17,30)]
          if (length(coordinates) == 3) {
            shinyjs::delay(100, updateRadioButtons(session, inputId = "station_coordinates", selected = 1))
            stationGeo <- do.call(xyz2llh,as.list(as.numeric(c(coordinates[1],coordinates[2],coordinates[3]))))
            lat <- sprintf("%.6f", stationGeo[1] * 180/pi)
            lon <- sprintf("%.6f", stationGeo[2] * 180/pi)
            coordinates <- c(coordinates,lat,lon)
          } else {
            coordinates <- NULL
          }
        } else if (server == "IGS") {
          tableAll <- try(read.table(text = trimws(readLines(filein, warn = F)[1]), comment.char = "#"), silent = T)
          shinyjs::delay(100, updateRadioButtons(inputId = "station_coordinates", selected = 2))
          lat <- tableAll[1,5]
          lon <- tableAll[1,6]
          coordinates <- latlon2xyz(lat*pi/180,lon*pi/180,1)
          coordinates <- c(coordinates,lat,lon)
        } else if (server == "JPL") {
          if (isTruthy(station)) {
            tableAll <- read.table("www/JPL_database.txt")
            coordinates <- tableAll[tableAll$V1 == station, c(2,3,4)]
            if (length(coordinates) == 3) {
              shinyjs::delay(100, updateRadioButtons(session, inputId = "station_coordinates", selected = 1))
              stationGeo <- do.call(xyz2llh,as.list(as.numeric(c(coordinates[1],coordinates[2],coordinates[3]))))
              lat <- sprintf("%.6f", stationGeo[1] * 180/pi)
              lon <- sprintf("%.6f", stationGeo[2] * 180/pi)
              coordinates <- c(coordinates,lat,lon)
            } else {
              coordinates <- NULL
            }
          }
        } else if (server == "SIRGAS") {
          tableAll <- try(read.table(text = grep(" IGb14 ", readLines(filein, warn = F), value = T, fixed = T)[1], comment.char = "#"), silent = T)
          shinyjs::delay(100, updateRadioButtons(inputId = "station_coordinates", selected = 2))
          lat <- tableAll[1,7]
          lon <- tableAll[1,8]
          coordinates <- latlon2xyz(lat*pi/180,lon*pi/180,1)
          coordinates <- c(coordinates,lat,lon)
        } else if (server == "EPOS") {
          stationsFromEPOS <- try(read.table(file = "www/EPOS_database.txt", header = T), silent = T)
          tableAll <- stationsFromEPOS[grepl(station, stationsFromEPOS$id), c(2,3)]
          shinyjs::delay(100, updateRadioButtons(inputId = "station_coordinates", selected = 2))
          lat <- tableAll[1,1]
          lon <- tableAll[1,2]
          coordinates <- latlon2xyz(lat*pi/180,lon*pi/180,1)
          coordinates <- c(coordinates,lat,lon)
        } else if (server == "EARTHSCOPE") {
          tableAll <- try(read.table(text = grep("# XYZ Reference Coordinate", readLines(filein, warn = F, n = 10), ignore.case = F, value = T, fixed = T), comment.char = ""), silent = T)
          if (length(tableAll) > 9) {
            shinyjs::delay(100, updateRadioButtons(session, inputId = "station_coordinates", selected = 1))
            stationGeo <- do.call(xyz2llh,as.list(as.numeric(c(tableAll[6],tableAll[8],tableAll[10]))))
            lat <- sprintf("%.6f", stationGeo[1] * 180/pi)
            lon <- sprintf("%.6f", stationGeo[2] * 180/pi)
            coordinates <- c(as.numeric(tableAll[6]),as.numeric(tableAll[8]),as.numeric(tableAll[10]),lat,lon)
          } else {
            coordinates <- NULL
          }
        } else if (server == "DORIS") {
          if (isTruthy(station)) {
            tableAll <- read.table("www/DORIS_database.txt", sep = ";")
            coordinates <- tableAll[grepl(station, tableAll$V6, ignore.case = T), c(2,3,4)]
            if (length(coordinates) == 3) {
              shinyjs::delay(100, updateRadioButtons(session, inputId = "station_coordinates", selected = 2))
              lat <- coordinates[1,1]
              lon <- coordinates[1,2]
              coordinates <- latlon2xyz(lat*pi/180,lon*pi/180,1)
              coordinates <- c(coordinates,lat,lon)
            } else {
              coordinates <- NULL
            }
          }
        }
      } else if (isTruthy(product) && (product == "SPOTGINS" || product == "SPOTGINS_POS")) {
        coordinates <- unlist(strsplit(trim(grep("_pos ", readLines(filein, warn = F), ignore.case = F, value = T, perl = T)), "\\s+", fixed = F, perl = T, useBytes = F))[c(4,8,12)]
        if (!any(is.na(suppressWarnings(as.numeric(coordinates)))) && length(coordinates) == 3) {
          shinyjs::delay(100, updateRadioButtons(session, inputId = "station_coordinates", selected = 1))
          stationGeo <- do.call(xyz2llh,as.list(as.numeric(c(coordinates[1],coordinates[2],coordinates[3]))))
          lat <- sprintf("%.6f", stationGeo[1] * 180/pi)
          lon <- sprintf("%.6f", stationGeo[2] * 180/pi)
          coordinates <- c(coordinates,lat,lon)
        } else {
          coordinates <- NULL
        }
      }
    } else if (format == 2) {
      ref_pos <- grep("^XYZ Reference position",readLines(filein, n = 20, ok = T, warn = F, skipNul = T), ignore.case = F, perl = T, value = T)
      if (length(ref_pos) > 0) {
        shinyjs::delay(100, updateRadioButtons(session, inputId = "station_coordinates", choices = list("Cartesian" = 1, "Geographic" = 2), selected = 1, inline = T))
        x <- unlist(strsplit(ref_pos, split = " +"))[5]
        y <- unlist(strsplit(ref_pos, split = " +"))[6]
        z <- unlist(strsplit(ref_pos, split = " +"))[7]
        stationGeo <- do.call(xyz2llh,as.list(as.numeric(c(x,y,z))))
        lat <- sprintf("%.6f", stationGeo[1] * 180/pi)
        lon <- sprintf("%.6f", stationGeo[2] * 180/pi)
        coordinates <- c(x,y,z,lat,lon)
      }
    } else if (format == 3) {
      skip <- which(grepl("site YYMMMDD", readLines(filein, warn = F)))
      tableAll <- try(read.table(filein, comment.char = "#", sep = sep, skip = skip)[1,], silent = T)
      shinyjs::delay(100, updateRadioButtons(session, inputId = "station_coordinates", choices = list("Cartesian" = 1, "Geographic" = 2), selected = 2, inline = T))
      lat <- tableAll[1,21]
      lon <- ifelse(tableAll[1,22] < -180, yes = tableAll[1,22] + 360, no = tableAll[1,22])
      coordinates <- latlon2xyz(lat*pi/180,lon*pi/180,1)
      coordinates <- c(coordinates,lat,lon)
    } else if (format == 4) {
      if (isTruthy(server)) {
        if (server == "PSMSL") {
          stationsFromPSMSL <- try(read.table(file = "www/PSMSL_database.txt", sep = ";"), silent = T)
          if (isTruthy(station)) {
            tableAll <- stationsFromPSMSL[grepl(station, stationsFromPSMSL$V2), c(3,4)]
          } else {
            tableAll <- stationsFromPSMSL[stationsFromPSMSL$V1 == strsplit(file$primary$name, ".rlrdata", fixed = T)[[1]][1],c(3,4)]
          }
          if (isTruthy(tableAll)) {
            shinyjs::delay(100, updateRadioButtons(inputId = "station_coordinates", selected = 2))
            lat <- as.numeric(tableAll[1,1])
            lon <- as.numeric(tableAll[1,2])
            coordinates <- latlon2xyz(lat*pi/180,lon*pi/180,1)
            coordinates <- c(coordinates,lat,lon)
          }
        }
      }
    }
    if (isTruthy(coordinates)) {
      return(c(as.numeric(sprintf("%.1f", as.numeric(coordinates[1]))), as.numeric(sprintf("%.1f", as.numeric(coordinates[2]))), as.numeric(sprintf("%.1f", as.numeric(coordinates[3]))), as.numeric(sprintf("%.6f", as.numeric(coordinates[4]))), as.numeric(sprintf("%.6f", as.numeric(coordinates[5])))))
    }
  }
  #
  latlon2xyz <- function(lat,lon,scaling) {
    a <- 6378137
    b <- 6356752.314140347
    e2 <- (a^2 - b^2) / a^2
    N <- a / sqrt( 1 - e2 * sin(lat)^2)
    x <- as.numeric(sprintf("%.1f", N * cos(lat) * cos(lon)))
    y <- as.numeric(sprintf("%.1f", N * cos(lat) * sin(lon)))
    z <- as.numeric(sprintf("%.1f", N * (1 - e2) * sin(lat)))
    c(x,y,z) * scaling
  }
  #
  xyz2llh <- function(x,y,z) {
    a <- 6378137
    b <- 6356752.314140347
    e2 <- (a^2 - b^2) / a^2
    lon <- atan2(y,x)
    lat <- atan2(z*cos(lon),x*(1 - e2))
    if (lat > pi/2) {
      lat <- lat - pi
    } else if (lat < -1*pi/2) {
      lat <- lat + pi
    }
    c(lat,lon)
  }
  #
  model <- function(x,y) {
    removeNotification("bad_rate_noise")
    removeNotification("missing_rate_noise")
    removeNotification("no_trend_error")
    removeNotification("no_intercept_error")
    removeNotification("bad_sinusoidal_period")
    removeNotification("bad_amplitude_error")
    removeNotification("bad_sinusoidal_noise")
    removeNotification("missing_sinusoidal_noise")
    removeNotification("bad_offset_epoch")
    removeNotification("no_exponential")
    removeNotification("no_logarithmic")
    removeNotification("bad_degree")
    isolate({
      model_nls <- model_lm <- model_kf <- "y ~"
      model_kf_inst <- model_kf_mean <- ""
      j <- 1
      apriori <- list()
      error <- list()
      nouns <- list()
      processNoise <- 0
      info$run <- F
      y_detrend <- NULL
      lm <- ifelse(input$fitType == 1 && !"Logarithmic" %in% input$model && !"Exponential" %in% input$model,T,F)
      # * Linear model ####
      if ("Linear" %in% input$model) {
        if (isTruthy(info$trendRef) && isTruthy(inputs$trendRef)) {
          reft <- inputs$trendRef
        } else {
          if (input$fitType == 1) {
            reft <- sprintf("%.*f", info$decimalsx, mean(x, na.rm = T))
            reft <- as.numeric(reft)
          } else if (input$fitType == 2) {
            reft <- x[1]
          }
          inputs$trendRef <- reft
          updateTextInput(session, "trendRef", value = sprintf("%.*f", info$decimalsx, reft))
          info$trendRef <- T
          if (input$fitType == 1) {
            req(info$stop)
          }
        }
        text_rate <- reft
        if (input$fitType == 1) {
          if (input$breaking && length(trans$breakEpochs) > 0 && input$trendType > 0) {
            for (breaks in seq_len(length(trans$breakEpochs) + 1)) {
              if (breaks == 1) {
                model_lm <- paste0(model_lm, " R(-Inf,",trans$breakEpochs[breaks],")")
                model_nls <- paste0(model_nls, " (Intercept",breaks," + Rate",breaks,"*(x-",text_rate,"))*I(x<=",trans$breakEpochs[breaks],")")
                nouns <- c(nouns, paste0("Intercept",breaks), paste0("Rate",breaks))
              } else if (breaks == length(trans$breakEpochs) + 1) {
                model_lm <- paste0(model_lm, " + I(",trans$breakEpochs[breaks - 1],",Inf) + R(",trans$breakEpochs[breaks - 1],",Inf)")
                model_nls <- paste0(model_nls, " + (Intercept",breaks," + Rate",breaks,"*(x-",text_rate,"))*I(x>",trans$breakEpochs[breaks - 1],")")
                nouns <- c(nouns, paste0("Intercept",breaks), paste0("Rate",breaks))
              } else {
                model_lm <- paste0(model_lm, " + I(",trans$breakEpochs[breaks - 1],",",trans$breakEpochs[breaks],") + R(",trans$breakEpochs[breaks - 1],",",trans$breakEpochs[breaks],")")
                model_nls <- paste0(model_nls, " + (Intercept",breaks," + Rate",breaks,"*(x-",text_rate,"))*I(x>",trans$breakEpochs[breaks - 1]," & x<=",trans$breakEpochs[breaks],")")
                nouns <- c(nouns, paste0("Intercept",breaks), paste0("Rate",breaks))
              }
            }
          } else {
            model_lm <- paste0(model_lm, " R(",x[1],",Inf)")
            model_nls <- paste0(model_nls, " Intercept + Rate*(x-",text_rate,")")
            nouns <- c("Intercept", "Rate")
          }
        } else if (input$fitType == 2) {
          if (nchar(input$TrendDev) > 0) {
            if (!is.na(suppressWarnings(as.numeric(input$TrendDev)))) {
              if (suppressWarnings(as.numeric(input$TrendDev)) > 0) {
                model_kf <- paste(model_kf, paste0("Intercept + Rate*dx"), sep = " ")
                noise <- as.numeric(input$TrendDev)
              } else if (suppressWarnings(as.numeric(input$TrendDev)) == 0) {
                noise <- 0
                model_kf <- paste(model_kf, paste0("Intercept + Rate*(x-",text_rate,")"), sep = " ")
              } else {
                showNotification(HTML("The process noise for the trend is not valid.<br>Check the input value."), action = NULL, duration = 15, closeButton = T, id = "bad_rate_noise", type = "error", session = getDefaultReactiveDomain())
                return(NULL)
              }
            } else {
              showNotification(HTML("The process noise for the trend is not valid.<br>Check the input value."), action = NULL, duration = 15, closeButton = T, id = "bad_rate_noise", type = "error", session = getDefaultReactiveDomain())
              return(NULL)
            }
          } else {
            updateTextInput(session, "TrendDev", value = "0.0")
            noise <- 0
            model_kf <- paste(model_kf, paste0("Intercept + Rate*(x-",text_rate,")"), sep = " ")
            showNotification(HTML("The process noise value for the trend is missing.<br>Using a value of zero."), action = NULL, duration = 10, closeButton = T, id = "missing_rate_noise", type = "warning", session = getDefaultReactiveDomain())
          }
          nouns <- c("Intercept", "Rate")
          model_kf_inst <- paste(model_kf_inst, paste0("e[k,",j,"] + e[k,",j + 1,"]*(x[k] - x[k-1])"), sep = " ")
          model_kf_mean <- paste(model_kf_mean, paste0("e[k,",j,"] + e[k,",j + 1,"]*(x[k]-",text_rate,")"), sep = " ")
          j <- j + 2
        }
        if (!lm) {
          if (length(y) > 30) {
            tenth <- ceiling(length(y)/10)
          } else {
            tenth <- ceiling(length(y)/2)
          }
          # a priori trend
          if (identical(input$Trend0,character(0)) || is.na(input$Trend0) || input$Trend0 == "" || input$Trend0 == " ") {
            if (isTruthy(match("Rate", trans$names))) {
                ap_rate <- trans$LScoefs[match("Rate", trans$names),1]
                sigma_rate <- trans$LScoefs[match("Rate", trans$names),2]
            } else {
              fastFit <- try(lm(y[1:tenth]~x[1:tenth]), silent = F)
              if (isTruthy(fastFit)) {
                ap_rate <- summary(fastFit)$coefficients[2,1]
                sigma_rate <- summary(fastFit)$coefficients[2,2] * 3
              } else {
                ap_rate <- (mean(tail(y, n = tenth), na.rm = T) - mean(y[1:tenth], na.rm = T))/(mean(tail(x, n = tenth), na.rm = T) - mean(x[1:tenth], na.rm = T))
                sigma_rate <- ap_rate * 5
              }
            }
            if (input$fitType == 2) {
              max_decimals <- signifdecimal(ap_rate, F) + 2
              updateTextInput(session, "Trend0", value = sprintf("%.*f", max_decimals, ap_rate))
              max_decimals <- signifdecimal(sigma_rate, F) + 2
              updateTextInput(session, "eTrend0", value = sprintf("%.*f", max_decimals, sigma_rate))
            }
          } else {
            ap_rate <- as.numeric(input$Trend0)
            if (input$eTrend0 == 0) {
              showNotification(HTML("The initial trend error is zero.<br>Check the input value."), action = NULL, duration = 15, closeButton = T, id = "no_trend_error", type = "error", session = getDefaultReactiveDomain())
              req(info$stop)
            } else {
              sigma_rate <- as.numeric(input$eTrend0)
            }
          }
          # a priori intercept
          if (input$fitType == 1) {
            y_detrend <- y - (x - reft) * ap_rate
            xreft <- which.min(abs(x - reft))
            xfrom <- ifelse(xreft > tenth, xreft - tenth, xreft)
            xto <- ifelse(xreft + tenth < length(x), xreft + tenth, length(x))
            ap_intercept <- mean(y_detrend[seq(xfrom,xto)], na.rm = T)
            sigma_intercept <- sd(y_detrend[seq(xfrom,xto)], na.rm = T)/sqrt(tenth*2)
            if (!isTruthy(sigma_intercept) || sigma_intercept <= 0) {
              sigma_intercept <- 1
            }
          } else if (input$fitType == 2) {
            if (identical(input$Intercept0,character(0)) || is.na(input$Intercept0) || input$Intercept0 == "" || input$Intercept0 == " ") {
              if (isTruthy(match("Intercept", trans$names))) {
                if (isTruthy(match("Rate", trans$names))) {
                  ap_intercept <- trans$LScoefs[match("Intercept", trans$names),1] + (trans$x[1] - reft) * trans$LScoefs[match("Rate", trans$names),1]
                } else {
                  ap_intercept <- trans$LScoefs[match("Intercept", trans$names),1] + (trans$x[1] - reft) * ap_rate
                }
                sigma_intercept <- abs(as.numeric(trans$LScoefs[match("Intercept", trans$names),2] * sqrt(length(trans$x))))
              } else {
                ap_intercept <- y[1]
                sigma_intercept <- info$noise
              }
              max_decimals <- signifdecimal(ap_intercept, F) + 2
              updateTextInput(session, "Intercept0", value = sprintf("%.*f", max_decimals, ap_intercept))
              max_decimals <- signifdecimal(sigma_intercept, F) + 2
              updateTextInput(session, "eIntercept0", value = sprintf("%.*f", max_decimals, sigma_intercept))
            } else {
              ap_intercept <- as.numeric(input$Intercept0)
              if (input$eIntercept0 == 0) {
                showNotification(HTML("The initial intercept error is zero.<br>Check the input value."), action = NULL, duration = 15, closeButton = T, id = "no_intercept_error", type = "error", session = getDefaultReactiveDomain())
                req(info$stop)
              } else {
                sigma_intercept <- as.numeric(input$eIntercept0)
              }
            }
            processNoise <- c(processNoise, as.numeric(noise)^2)
            error <- c(error, Intercept = as.numeric(sigma_intercept), Rate = as.numeric(sigma_rate))
          }
          if (input$fitType == 1 && input$breaking && length(trans$breakEpochs) > 0 && input$trendType > 0) {
            for (breaks in seq_len(length(trans$breakEpochs) + 1)) {
              apriori[[paste0("Intercept",breaks)]] <- ap_intercept
              apriori[[paste0("Rate",breaks)]] <- ap_rate
            }
          } else {
            apriori <- c(Intercept = as.numeric(ap_intercept), Rate = as.numeric(ap_rate))
          }
        }
        info$run <- T
      } else { # only Intercept
        if (input$fitType == 1) {
          if (input$breaking && length(trans$breakEpochs) > 0 && (input$sinusoidType > 0 || input$polyType > 0)) {
            for (breaks in seq_len(length(trans$breakEpochs) + 1)) {
              if (breaks == 1) {
                model_nls <- paste0(model_nls, " Intercept",breaks,"*I(x<=",trans$breakEpochs[breaks],")")
              } else if (breaks == length(trans$breakEpochs) + 1) {
                model_nls <- paste0(model_nls, " + Intercept",breaks,"*I(x>",trans$breakEpochs[breaks - 1],")")
              } else {
                model_nls <- paste0(model_nls, " + Intercept",breaks,"*I(x>",trans$breakEpochs[breaks - 1]," & x<=",trans$breakEpochs[breaks],")")
              }
              nouns <- c(nouns, paste0("Intercept",breaks))
            }
          } else {
            model_nls <- paste0(model_nls, " Intercept")
            nouns <- c("Intercept")
          }
        } else if (input$fitType == 2) {
          nouns <- c("Intercept")
          model_kf <- paste0(model_kf, " Intercept")
          model_kf_inst <- model_kf_mean <- paste(model_kf_inst, "e[k,",j,"]", sep = " ")
          j <- j + 1
        }
        if (!lm) {
          if (isTruthy(match("Intercept", trans$names))) {
            if (input$fitType == 1) {
              ap_intercept <- trans$LScoefs[match("Intercept", trans$names),1] - trans$ordinate
            } else if (input$fitType == 2) {
              ap_intercept <- trans$LScoefs[match("Intercept", trans$names),1]
            }
            sigma_intercept <- abs(as.numeric(trans$LScoefs[match("Intercept", trans$names),2] * sqrt(length(trans$x))))
          } else {
            ap_intercept <- mean(y, na.rm = T)
            sigma_intercept <- sd(y, na.rm = T)
          }
          if (input$fitType == 1 && input$breaking && length(trans$breakEpochs) > 0 && input$trendType > 0) {
            for (breaks in seq_len(length(trans$breakEpochs) + 1)) {
              apriori[[paste0("Intercept",breaks)]] <- ap_intercept
            }
          } else {
            apriori <- c(apriori, Intercept = as.numeric(ap_intercept))
            error <- c(error, Intercept = as.numeric(sigma_intercept))
          }
        }
      }
      # * Sinusoidal model ####
      if ("Sinusoidal" %in% input$model) {
        periodsIn <- unlist(strsplit(inputs$period, split = ","))
        periodsOut <- NULL
        trans$periods <- NULL
        S0 <- C0 <- unlist(strsplit(input$S0, split = ","))
        eS0 <- eC0 <- unlist(strsplit(input$eS0, split = ","))
        # S0 <- C0 <- eS0 <- eC0 <- ""
        sigamp <- unlist(strsplit(input$SinusoidalDev, split = ","))
        if (isTruthy(info$periodRef)) {
          refs <- inputs$periodRef
        } else {
          if (input$fitType == 1) {
            refs <- sprintf("%.*f", info$decimalsx, mean(x, na.rm = T))
            refs <- as.numeric(refs)
          } else if (input$fitType == 2) {
            refs <- x[1]
          }
          inputs$periodRef <- refs
          updateTextInput(session, "periodRef", value = refs)
          info$periodRef <- T
          if (input$fitType == 1) {
            req(info$stop)
          }
        }
        # getting all frequencies and their harmonics
        if (length(periodsIn) > 0) {
          for (p in periodsIn) {
            if (grepl("x",p)) {
              part <- unlist(strsplit(sub("x","",p), "(?<=[0-9])(?=[a-zA-Z])|(?<=[a-zA-Z])(?=[0-9])", perl = T))
              if (length(part) == 3 && isTruthy(as.numeric(part[1])) && is.character(part[2]) && (part[2] %in% c("d","w","y")) && isTruthy(as.numeric(part[3]))) {
                periodsOut <- c(periodsOut, paste0(part[1],part[2]))
                periodsOut <- c(periodsOut, paste(as.numeric(part[1])/seq(as.numeric(part[3]))[-1],part[2],sep = ""))
              }
            } else {
              part <- unlist(strsplit(p, "(?<=[0-9])(?=[a-zA-Z])|(?<=[a-zA-Z])(?=[0-9])", perl = T))
              if (length(part) == 2 && isTruthy(as.numeric(part[1])) && is.character(part[2]) && (part[2] %in% c("d","w","y"))) {
                periodsOut <- c(periodsOut, paste0(part[1],part[2]))
              }
            }
          }
        }
        # loop for each frequency
        if (length(periodsOut) > 0) {
          periodsOut <- unique(periodsOut)
          i <- 0
          for (p in periodsOut) {
            f <- NULL
            i <- i + 1
            if (grepl("d",p)) {
              f <- gsub("d", "", p)
              if (nchar(f) > 0 && !is.na(as.numeric(f))) {
                if (input$breaking && length(trans$breakEpochs) > 0 && input$sinusoidType > 0) {
                  for (breaks in seq_len(length(trans$breakEpochs) + 1)) {
                    trans$periods <- c(trans$periods, trim(paste0(f,"d")))
                  }
                } else {
                  trans$periods <- c(trans$periods, trim(paste0(f,"d")))
                }
                if (input$tunits == 1) {
                  f <- 1/as.numeric(f)
                } else if (input$tunits == 2) {
                  f <- 7/as.numeric(f)
                } else if (input$tunits == 3) {
                  f <- daysInYear/as.numeric(f)
                }
              } else {
                f <- NULL
              }
            } else if (grepl("w",p)) {
              f <- gsub("w", "", p)
              if (nchar(f) > 0 && !is.na(as.numeric(f))) {
                if (input$breaking && length(trans$breakEpochs) > 0 && input$sinusoidType > 0) {
                  for (breaks in seq_len(length(trans$breakEpochs) + 1)) {
                    trans$periods <- c(trans$periods, trim(paste0(f,"w")))
                  }
                } else {
                  trans$periods <- c(trans$periods, trim(paste0(f,"w")))
                }
                if (input$tunits == 1) {
                  f <- (1/as.numeric(f))*7
                } else if (input$tunits == 2) {
                  f <- (1/as.numeric(f))*1
                } else if (input$tunits == 3) {
                  f <- 1/as.numeric(f)*7/daysInYear
                }
              } else {
                f <- NULL
              }
            } else if (grepl("y",p)) {
              f <- gsub("y", "", p)
              if (nchar(f) > 0  && !is.na(as.numeric(f))) {
                if (input$breaking && length(trans$breakEpochs) > 0 && input$sinusoidType > 0) {
                  for (breaks in seq_len(length(trans$breakEpochs) + 1)) {
                    trans$periods <- c(trans$periods, trim(paste0(f,"y")))
                  }
                } else {
                  trans$periods <- c(trans$periods, trim(paste0(f,"y")))
                }
                if (input$tunits == 1) {
                  f <- (1/as.numeric(f))*1/daysInYear
                } else if (input$tunits == 2) {
                  f <- (1/as.numeric(f))*7/daysInYear
                } else if (input$tunits == 3) {
                  f <- 1/as.numeric(f)
                }
              } else {
                f <- NULL
              }
            }
            if (length(f) > 0 && f < 1/(2*info$sampling) && f > 1/(10*abs(info$rangex))) {
              if (f < 1/abs(info$rangex)) {
                showNotification(HTML(paste0("At least one of the input sinusoidal periods is larger than the series length (",format(info$rangex, nsmall = info$decimalsx, scientific = F, trim = F)," ",info$tunits.label,").<br>The fitting results may be unreliable.")), action = NULL, duration = 10, closeButton = T, id = "bad_sinusoidal_period", type = "warning", session = getDefaultReactiveDomain())
              }
              info$run <- T
              label_sin <- paste0("S",i)
              label_cos <- paste0("C",i)
              text_sin <- paste0("I(sin(2*pi*(x-", refs, ")*", f, "))")
              text_cos <- paste0("I(cos(2*pi*(x-", refs, ")*", f, "))")
              text_sin_kf <- paste0("sin(2*pi*(x[k]-", refs, ")*", f, ")")
              text_cos_kf <- paste0("cos(2*pi*(x[k]-", refs, ")*", f, ")")
              text_sin_lm <- paste0("sin(2*pi*x*", f, ")")
              text_cos_lm <- paste0("cos(2*pi*x*", f, ")")
              if (input$fitType == 1) {
                if (input$breaking && length(trans$breakEpochs) > 0 && input$sinusoidType > 0) {
                  for (breaks in seq_len(length(trans$breakEpochs) + 1)) {
                    label_sin <- paste0("S",i,breaks)
                    label_cos <- paste0("C",i,breaks)
                    if (breaks == 1) {
                      model_lm <- ifelse(nchar(model_lm) > 3, paste(model_lm,"+"), model_lm)
                      model_lm <- paste0(model_lm, " S(-Inf,",trans$breakEpochs[breaks],",",f,")")
                      model_lm <- paste0(model_lm, " + C(-Inf,",trans$breakEpochs[breaks],",",f,")")
                      model_nls <- paste(model_nls, paste(label_sin,text_sin,paste0("I(x<=",trans$breakEpochs[breaks],")"),sep = "*"), sep = " + ")
                      model_nls <- paste(model_nls, paste(label_cos,text_cos,paste0("I(x<=",trans$breakEpochs[breaks],")"),sep = "*"), sep = " + ")
                    } else if (breaks == length(trans$breakEpochs) + 1) {
                      if (i == 1 && !any(grepl(paste0("Intercept",breaks),nouns))) {
                        nouns <- c(nouns, paste0("Intercept",breaks))
                      }
                      model_lm <- paste0(model_lm, " + I(",trans$breakEpochs[breaks - 1],",Inf) + S(",trans$breakEpochs[breaks - 1],",Inf,",f,")")
                      model_lm <- paste0(model_lm, " + C(",trans$breakEpochs[breaks - 1],",Inf,",f,")")
                      model_nls <- paste(model_nls, paste(label_sin,text_sin,paste0("I(x>",trans$breakEpochs[breaks - 1],")"),sep = "*"), sep = " + ")
                      model_nls <- paste(model_nls, paste(label_cos,text_cos,paste0("I(x>",trans$breakEpochs[breaks - 1],")"),sep = "*"), sep = " + ")
                    } else {
                      if (i == 1 && !any(grepl(paste0("Intercept",breaks),nouns))) {
                        nouns <- c(nouns, paste0("Intercept",breaks))
                      }
                      model_lm <- paste0(model_lm, " + I(",trans$breakEpochs[breaks - 1],",",trans$breakEpochs[breaks],") + S(",trans$breakEpochs[breaks - 1],",",trans$breakEpochs[breaks],",",f,")")
                      model_lm <- paste0(model_lm, " + C(",trans$breakEpochs[breaks - 1],",",trans$breakEpochs[breaks],",",f,")")
                      model_nls <- paste(model_nls, paste(label_sin,text_sin,paste0("I(x>",trans$breakEpochs[breaks - 1]," & x<=",trans$breakEpochs[breaks],")"),sep = "*"), sep = " + ")
                      model_nls <- paste(model_nls, paste(label_cos,text_cos,paste0("I(x>",trans$breakEpochs[breaks - 1]," & x<=",trans$breakEpochs[breaks],")"),sep = "*"), sep = " + ")
                    }
                    nouns <- c(nouns, label_sin)
                    nouns <- c(nouns, label_cos)
                  }
                } else {
                  model_lm <- ifelse(nchar(model_lm) > 3, paste(model_lm,"+"), model_lm)
                  model_lm <- paste0(model_lm, " S(-Inf,Inf,",f,")")
                  model_lm <- paste0(model_lm, " + C(-Inf,Inf,",f,")")
                  model_nls <- paste(model_nls, paste(label_sin,text_sin,sep = "*"), sep = " + ")
                  model_nls <- paste(model_nls, paste(label_cos,text_cos,sep = "*"), sep = " + ")
                  nouns <- c(nouns, label_sin)
                  nouns <- c(nouns, label_cos)
                }
              } else if (input$fitType == 2) {
                model_kf <- paste(model_kf, paste(label_sin,text_sin,sep = "*"), sep = " + ")
                model_kf <- paste(model_kf, paste(label_cos,text_cos,sep = "*"), sep = " + ")
                model_kf_inst <- paste(model_kf_inst, paste(paste0("e[k,",j,"]"),text_sin_kf,sep = "*"), sep = " + ")
                model_kf_mean <- paste(model_kf_mean, paste(paste0("e[k,",j,"]"),text_sin_kf,sep = "*"), sep = " + ")
                j <- j + 1
                model_kf_inst <- paste(model_kf_inst, paste(paste0("e[k,",j,"]"),text_cos_kf,sep = "*"), sep = " + ")
                model_kf_mean <- paste(model_kf_mean, paste(paste0("e[k,",j,"]"),text_cos_kf,sep = "*"), sep = " + ")
                j <- j + 1
                nouns <- c(nouns, label_sin)
                nouns <- c(nouns, label_cos)
              }
              if (!lm) {
                if (length(y_detrend) > 0) {
                  y_now <- y_detrend
                } else {
                  y_now <- y - median(y)
                }
                if (identical(S0,character(0)) || is.na(S0[i]) || S0[i] == "" || S0[i] == " ") {
                  if (isTruthy(match(paste0("S",i), trans$names)) && sum(grepl(pattern = "^S", trans$names, ignore.case = F, perl = T)) == length(periodsOut)) {
                    S0[i] <- trans$LScoefs[match(paste0("S",i), trans$names),1]
                    C0[i] <- trans$LScoefs[match(paste0("C",i), trans$names),1]
                    max_decimals <- signifdecimal(as.numeric(S0[i]), F) + 2
                    S0[i] <- sprintf("%.*f", max_decimals, as.numeric(S0[i]))
                    max_decimals <- signifdecimal(as.numeric(C0[i]), F) + 2
                    C0[i] <- sprintf("%.*f", max_decimals, as.numeric(C0[i]))
                    eS0[i] <- abs(as.numeric(S0[i]))
                    eC0[i] <- abs(as.numeric(C0[i]))
                  } else {
                    S0[i] <- quantile(y_now, probs = 0.95)/(4*sqrt(2))
                    max_decimals <- signifdecimal(as.numeric(S0[i]), F) + 2
                    S0[i] <- C0[i] <- sprintf("%.*f", max_decimals, as.numeric(S0[i]))
                    eS0[i] <- as.numeric(S0[i])/2
                    max_decimals <- signifdecimal(as.numeric(eS0[i]), F) + 2
                    eS0[i] <- eC0[i] <- sprintf("%.*f", max_decimals, as.numeric(eS0[i]))
                    # fixed to zero for the first run because of the new draconitic option; need to find something better
                    S0[i] <- C0[i] <- 0
                  }
                  if (input$fitType == 2) {
                    line_S0 <- paste(S0, collapse = ", ")
                    line_eS0 <- paste(eS0, collapse = ", ")
                    updateTextInput(session, "S0", value = line_S0)
                    updateTextInput(session, "eS0", value = line_eS0)
                  }
                }
                if (eS0[i] == 0) {
                  info$run <- F
                  showNotification(HTML("At least one of the initial sinusoidal amplitude errors is zero.<br>Check the input value."), action = NULL, duration = 15, closeButton = T, id = "bad_amplitude_error", type = "error", session = getDefaultReactiveDomain())
                  req(info$stop)
                } else {
                  if (input$fitType == 1 && input$breaking && length(trans$breakEpochs) > 0 && input$sinusoidType > 0) {
                    for (breaks in seq_len(length(trans$breakEpochs) + 1)) {
                      apriori[[paste0("S",i,breaks)]] <- as.numeric(S0[i])
                      apriori[[paste0("C",i,breaks)]] <- as.numeric(C0[i])
                    }
                  } else {
                    apriori[[label_sin]] <- as.numeric(S0[i])
                    error[[label_sin]] <- as.numeric(eS0[i])
                    apriori[[label_cos]] <- as.numeric(C0[i])
                    error[[label_cos]] <- as.numeric(eC0[i])
                  }
                }
              }
              if (input$fitType == 2) {
                if (isTruthy(sigamp[i])) {
                  if (!is.na(suppressWarnings(as.numeric(sigamp[i]))) && suppressWarnings(as.numeric(sigamp[i]) >= 0)) {
                    if (input$SineCosine == 1) {
                      processNoise <- c(processNoise, as.numeric(sigamp[i])^2)
                      processNoise <- c(processNoise, 0)
                    } else if (input$SineCosine == 2) {
                      processNoise <- c(processNoise, as.numeric(sigamp[i])^2)
                      processNoise <- c(processNoise, as.numeric(sigamp[i])^2)
                    }
                  } else {
                    showNotification(HTML(paste("The process noise value for the sinusoid ",i," is not valid.<br>Check the input values.")), action = NULL, duration = 10, closeButton = T, id = "bad_sinusoidal_noise", type = "error", session = getDefaultReactiveDomain())
                    return(NULL)
                  }
                } else {
                  showNotification(HTML(paste("The process noise value for the sinusoid ",i," is missing.<br>Using a value of zero.")), action = NULL, duration = 10, closeButton = T, id = "missing_sinusoidal_noise", type = "warning", session = getDefaultReactiveDomain())
                  processNoise <- c(processNoise, 0)
                  processNoise <- c(processNoise, 0)
                }
              }
            } else {
              if (isTruthy(f)) {
                if (info$sampling == f) {
                  showNotification(paste("The period asked for sinusoid ",i," is equal to the series sampling and has been rejected"), action = NULL, duration = 10, closeButton = T, id = "bad_sinusoidal_period", type = "warning", session = getDefaultReactiveDomain())
                } else {
                  showNotification(paste("The period asked for sinusoid ",i," is way out of the data bounds and has been rejected"), action = NULL, duration = 10, closeButton = T, id = "bad_sinusoidal_period", type = "warning", session = getDefaultReactiveDomain())
                }
              } else {
                showNotification(paste("The period asked for sinusoid ",i," has wrong format and has been rejected"), action = NULL, duration = 10, closeButton = T, id = "bad_sinusoidal_period", type = "warning", session = getDefaultReactiveDomain())
              }
            }
          }
        }
      }
      # * Offset model ####
      if ("Offset" %in% input$model) {
        if (isTruthy(trans$offsetEpochs)) {
          i <- 0
          O0 <- unlist(strsplit(input$O0, split = ","))
          eO0 <- unlist(strsplit(input$eO0, split = ","))
          for (p in trans$offsetEpochs) {
            info$run <- T
            i <- i + 1
            label <- paste0("O",i)
            text <- sprintf("I(x>%s)",p)
            nouns <- c(nouns, label)
            if (input$fitType == 1) {
              model_lm <- paste0(model_lm, " + O(",p,")")
              model_nls <- paste(model_nls, paste(label,text,sep = "*"), sep = " + ")
            } else if (input$fitType == 2) {
              model_kf <- paste(model_kf, paste(label,text,sep = "*"), sep = " + ")
              model_kf_inst <- paste(model_kf_inst, paste0("e[k,",j,"]*I(x[k]>",p,")"), sep = " + ")
              model_kf_mean <- paste(model_kf_mean, paste0("e[k,",j,"]*I(x[k]>",p,")"), sep = " + ")
              j <- j + 1
              processNoise <- c(processNoise, 0)
            }
            if (!lm) {
              if (identical(O0,character(0)) || is.na(O0[i]) || O0[i] == "" || O0[i] == " ") {
                if (isTruthy(match(paste0("O",i), trans$names))) {
                  O0[i] <- trans$LScoefs[match(paste0("O",i), trans$names),1]
                  max_decimals <- signifdecimal(as.numeric(O0[i]), F) + 2
                  O0[i] <- sprintf("%.*f", max_decimals, as.numeric(O0[i]))
                  eO0[i] <- abs(as.numeric(trans$LScoefs[match(paste0("O",i), trans$names),2]))
                  max_decimals <- signifdecimal(as.numeric(eO0[i]), F) + 2
                  eO0[i] <- sprintf("%.*f", max_decimals, as.numeric(eO0[i]))
                } else {
                  if (length(y_detrend) > 0) {
                    y_now <- y_detrend
                  } else {
                    y_now <- y
                  }
                  O0[i] <- y_now[which.max(x >= p)] - y_now[which.max(x >= p) - 1]
                  if (!isTruthy(O0[i])) {
                    O0[i] <- 0
                  } else {
                    max_decimals <- signifdecimal(as.numeric(O0[i]), F) + 2
                    O0[i] <- sprintf("%.*f", max_decimals, as.numeric(O0[i]))
                  }
                  if (input$tunits == 1) {
                    sample <- 1/12 * 365
                  } else if (input$tunits == 2) {
                    sample <- 1/12 * 365/7
                  } else if (input$tunits == 3) {
                    sample <- 1/12
                  }
                  eO0[i] <- ( sd(y_now[which.max(trans$x > p) - sample & which.min(trans$x < p)]) + sd(y_now[which.max(trans$x > p) & which.min(trans$x < p) + sample]) ) / 2
                  if (!isTruthy(eO0[i])) {
                    eO0[i] <- 1
                  } else {
                    max_decimals <- signifdecimal(as.numeric(eO0[i]), F) + 2
                    eO0[i] <- sprintf("%.*f", max_decimals, as.numeric(eO0[i]))
                  }
                }
                if (input$fitType == 2) {
                  line_O0 <- paste(O0, collapse = ", ")
                  line_eO0 <- paste(eO0, collapse = ", ")
                  updateTextInput(session, "O0", value = line_O0)
                  updateTextInput(session, "eO0", value = line_eO0)
                }
              }
              apriori[[label]] <- as.numeric(O0[i])
              error[[label]] <- as.numeric(eO0[i])
            }
          }
        }
      } else {
        trans$offsetEpochs <- NULL
      }
      # * Exponential model ####
      if ("Exponential" %in% input$model) {
        expos <- unlist(strsplit(inputs$ExponenRef, split = ","))
        E0 <- unlist(strsplit(inputs$E0, split = ","))
        eE0 <- unlist(strsplit(input$eE0, split = ","))
        TE0 <- unlist(strsplit(inputs$TE0, split = ","))
        eTE0 <- unlist(strsplit(input$eTE0, split = ","))
        if (length(expos) > 0) {
          i <- 0
          update <- 0
          if (length(expos) < length(E0) || length(expos) < length(TE0)) {
            E0 <- ""
            TE0 <- ""
            update <- 1
          }
          for (refe in expos) {
            refe <- trim(refe)
            i <- i + 1
            if (nchar(refe) > 0 && !is.na(as.numeric(refe)) && refe < x[length(x)]) {
              if (identical(E0,character(0)) || identical(TE0,character(0)) || is.na(E0[i]) || is.na(TE0[i]) || E0[i] == "" || TE0[i] == "" || E0[i] == " " || TE0[i] == " ") {
                update <- 1
                if (isTruthy(trans$LScoefs) && isTruthy(match(paste0("E",i), trans$names))) {
                  E0[i] <- trans$LScoefs[match(paste0("E",i), trans$names),1]
                  TE0[i] <- trans$LScoefs[match(paste0("TauE",i), trans$names),1]
                  eE0[i] <- trans$LScoefs[match(paste0("E",i), trans$names),2]
                  eTE0[i] <- trans$LScoefs[match(paste0("TauE",i), trans$names),2]
                } else {
                  if (input$tunits == 1) {
                    span <- 3 * 365
                    forward <- 1 * 365
                    sample <- 1/12 * info$sampling*365.25
                  } else if (input$tunits == 2) {
                    span <- 3 * 365/7
                    forward <- 1 * 365/7
                    sample <- 1/12 * info$sampling*365.25/7
                  } else if (input$tunits == 3) {
                    span <- 3
                    forward <- 1
                    sample <- 1/12 * info$sampling*365.25
                  }
                  if (length(trans$x[trans$x > as.numeric(refe) + 3*sample & trans$x <= as.numeric(refe) + span]) > 0 && length(trans$x[trans$x > as.numeric(refe) & trans$x < as.numeric(refe) + 3*sample]) > 0) {
                    apriori_y_before <- trans$y[trans$x > as.numeric(refe) - span & trans$x < as.numeric(refe)]
                    apriori_y_after <- trans$y[trans$x > as.numeric(refe) & trans$x <= as.numeric(refe) + span]
                    apriori_x_before <- trans$x[trans$x > as.numeric(refe) - span & trans$x < as.numeric(refe)]
                    apriori_x_after <- trans$x[trans$x > as.numeric(refe) & trans$x <= as.numeric(refe) + span] - as.numeric(refe)
                    if (length(apriori_x_before) > 3) {
                      fitBefore <- lm(apriori_y_before ~ apriori_x_before)
                      trendBefore <- fitBefore$coef[2]
                    } else {
                      trendBefore <- 0
                    }
                    flat <- apriori_y_after - apriori_x_after * trendBefore
                    convex <- lm(flat ~ poly(apriori_x_after, 2))
                    if (convex$coef[3] > 0) {
                      coeff <- 1
                    } else {
                      coeff <- -1
                    }
                    flat <- coeff * flat - min(coeff * flat) + 0.0000000000001
                    forward <- apriori_x_after[which.min(abs(apriori_x_after - forward))]
                    if (length(apriori_x_after[apriori_x_after < sample]) > 3) {
                      x0 <- apriori_x_after[apriori_x_after < sample]
                      y0 <- flat[apriori_x_after < sample]
                    } else if (length(apriori_x_after[apriori_x_after < 2*sample]) > 3) {
                      x0 <- apriori_x_after[apriori_x_after < 2*sample]
                      y0 <- flat[apriori_x_after < 2*sample]
                    } else if (length(apriori_x_after[apriori_x_after < 3*sample]) > 3) {
                      x0 <- apriori_x_after[apriori_x_after < 3*sample]
                      y0 <- flat[apriori_x_after < 3*sample]
                    } else {
                      x0 <- 0
                      y0 <- 0
                      showNotification(HTML("Not enough data to obtain the a priori values of the exponential decay.<br>The a priori values must be provided to continue."), action = NULL, duration = 10, closeButton = T, id = "no_exponential", type = "warning", session = getDefaultReactiveDomain())
                    }
                    x1 <- apriori_x_after[apriori_x_after >= forward - sample/2 & apriori_x_after < forward + sample/2]
                    y1 <- flat[apriori_x_after >= forward - sample/2 & apriori_x_after < forward + sample/2]
                    E0[i] <- mean(y0) * coeff
                    if (!isTruthy(as.numeric(E0[i]))) {
                      E0[i] <- 0
                    }
                    TE0[i] <- (forward - mean(x0))/(log(mean(y0)) - log(mean(y1)))
                    if (!isTruthy(as.numeric(TE0[i]))) {
                      TE0[i] <- forward
                    }
                    if (input$fitType == 2) {
                      eE0[i] <- sd(y0)
                      eTE0[i] <- sqrt( ( -1*sd(y0)/(mean(y0) * log(mean(y0)/mean(y1))^2) )^2 + ( 1*sd(y1)/(mean(y1) * log(mean(y0)/mean(y1))^2) )^2 )
                    }
                  } else {
                    showNotification(HTML("Not enough data to obtain the a priori values of the exponential decay.<br>The a priori values must be provided to continue."), action = NULL, duration = 10, closeButton = T, id = "no_exponential", type = "warning", session = getDefaultReactiveDomain())
                  }
                }
              }
              if (isTruthy(as.numeric(E0[i])) && isTruthy(as.numeric(TE0[i]))) {
                max_decimals <- signifdecimal(as.numeric(E0[i]), F) + 2
                E0[i] <- sprintf("%.*f", max_decimals, as.numeric(E0[i]))
                max_decimals <- signifdecimal(as.numeric(TE0[i]), F) + 2
                TE0[i] <- sprintf("%.*f", max_decimals, as.numeric(TE0[i]))
              }
              if (input$fitType == 2 && isTruthy(as.numeric(eE0[i])) && isTruthy(as.numeric(eTE0[i]))) {
                max_decimals <- signifdecimal(as.numeric(eE0[i]), F) + 2
                eE0[i] <- sprintf("%.*f", max_decimals, as.numeric(eE0[i]))
                max_decimals <- signifdecimal(as.numeric(eTE0[i]), F) + 2
                eTE0[i] <- sprintf("%.*f", max_decimals, as.numeric(eTE0[i]))
              }
            } else {
              if (is.na(E0[i]) || trim(E0[i]) == "NA" || trim(E0[i]) == "") {
                E0[i] <- NA
                TE0[i] <- NA
              } else {
                E0[i] <- NA
                TE0[i] <- NA
                update <- 1
              }
            }
          }
          if (update > 0) {
            line_E0 <- paste(E0, collapse = ", ")
            line_TE0 <- paste(TE0, collapse = ", ")
            inputs$E0 <- line_E0
            inputs$TE0 <- line_TE0
            updateTextInput(session, "E0", value = line_E0)
            updateTextInput(session, "TE0", value = line_TE0)
            if (input$fitType == 1) {
              req(info$stop)
            } else if (input$fitType == 2) {
              line_eE0 <- paste(eE0, collapse = ", ")
              line_eTE0 <- paste(eTE0, collapse = ", ")
              updateTextInput(session, "eE0", value = line_eE0)
              updateTextInput(session, "eTE0", value = line_eTE0)
            }
          }
          for (i in seq_len(length(E0))) {
            if (!is.na(as.numeric(E0[i]))) {
              info$run <- T
              label1 <- paste0("E",i)
              label2 <- paste0("TauE",i)
              text_exp <- expos[i]
              model_nls <- paste(model_nls, paste(label1,"*I(x>",text_exp,")*(exp((",text_exp,"-x)/",label2,") - 1)"), sep = " + ")
              model_kf_inst <- paste(model_kf_inst, paste("e[k,",j,"]","*I(x[k]>",text_exp,")*(exp(I(abs((",text_exp,"-x[k])/e[k,",j + 1,"])<40)*(",text_exp,"-x[k])/e[k,",j + 1,"]))"), sep = " + ")
              model_kf_mean <- paste(model_kf_mean, paste("e[k,",j,"]","*I(x[k]>",text_exp,")*(exp(I(abs((",text_exp,"-x[k])/e[k,",j + 1,"])<40)*(",text_exp,"-x[k])/e[k,",j + 1,"]))"), sep = " + ")
              j <- j + 2
              apriori[[label1]] <- as.numeric(E0[i])
              error[[label1]] <- as.numeric(eE0[i])
              nouns <- c(nouns, label1)
              apriori[[label2]] <- as.numeric(TE0[i])
              error[[label2]] <- as.numeric(eTE0[i])
              nouns <- c(nouns, label2)
              if (input$fitType == 2) {
                processNoise <- c(processNoise, 0)
                processNoise <- c(processNoise, 0)
              }
            }
          }
        } else {
          inputs$E0 <- ""
          inputs$TE0 <- ""
          updateTextInput(session, "E0", value = "")
          updateTextInput(session, "TE0", value = "")
          if (input$fitType == 2) {
            updateTextInput(session, "eE0", value = "")
            updateTextInput(session, "eTE0", value = "")
          }
        }
      }
      # * Logarithmic model ####
      if ("Logarithmic" %in% input$model) {
        logas <- unlist(strsplit(inputs$LogariRef, split = ","))
        L0 <- unlist(strsplit(inputs$L0, split = ","))
        TL0 <- unlist(strsplit(inputs$TL0, split = ","))
        eL0 <- unlist(strsplit(input$eL0, split = ","))
        eTL0 <- unlist(strsplit(input$eTL0, split = ","))
        if (length(logas) > 0) {
          i <- 0
          update <- 0
          if (length(logas) < length(L0) || length(logas) < length(TL0)) {
            L0 <- ""
            TL0 <- ""
            update <- 1
          }
          for (refl in logas) {
            refl <- trim(refl)
            i <- i + 1
            if (nchar(refl) > 0 && !is.na(as.numeric(refl)) && refl < x[length(x)]) {
              if (identical(L0,character(0)) || identical(TL0,character(0)) || is.na(L0[i]) || is.na(TL0[i]) || L0[i] == "" || TL0[i] == "" || L0[i] == " " || TL0[i] == " ") {
                update <- 1
                if (isTruthy(trans$LScoefs) && isTruthy(match(paste0("L",i), trans$names))) {
                  L0[i] <- trans$LScoefs[match(paste0("L",i), trans$names),1]
                  TL0[i] <- trans$LScoefs[match(paste0("TauL",i), trans$names),1]
                  eL0[i] <- abs(as.numeric(trans$LScoefs[match(paste0("L",i), trans$names),2]))
                  eTL0[i] <- abs(as.numeric(trans$LScoefs[match(paste0("TauL",i), trans$names),2]))
                  TL0[i] <- ifelse(as.numeric(TL0[i]) - 10*as.numeric(eTL0[i]) <= 0, as.numeric(TL0[i])*10, TL0[i])
                } else {
                  if (input$tunits == 1) {
                    span <- 3 * 365
                    sample <- 1/12 * info$sampling*365.25
                    forward <- 1 * 365
                  } else if (input$tunits == 2) {
                    span <- 3 * 365/7
                    forward <- 1 * 365/7
                    sample <- 1/12 * info$sampling*365.25/7
                  } else if (input$tunits == 3) {
                    span <- 3
                    forward <- 1
                    sample <- 1/12 * info$sampling*365.25
                  }
                  if (length(trans$x[trans$x > as.numeric(refl) + 3*sample & trans$x <= as.numeric(refl) + span]) > 0 && length(trans$x[trans$x > as.numeric(refl) & trans$x < as.numeric(refl) + 3*sample]) > 0) {
                    apriori_x_before <- trans$x[trans$x < as.numeric(refl)]
                    apriori_y_before <- trans$y[trans$x < as.numeric(refl)]
                    apriori_y_after <- trans$y[trans$x > as.numeric(refl) & trans$x <= as.numeric(refl) + span]
                    apriori_x_after <- trans$x[trans$x > as.numeric(refl) & trans$x <= as.numeric(refl) + span] - as.numeric(refl)
                    if (length(apriori_x_before) > 3) {
                      fitBefore <- lm(apriori_y_before ~ apriori_x_before)
                      trendBefore <- fitBefore$coef[2]
                    } else {
                      trendBefore <- 0
                    }
                    flat <- apriori_y_after - apriori_x_after * trendBefore
                    convex <- lm(flat ~ poly(apriori_x_after, 2))
                    coeff <- 0
                    if (convex$coef[3] < 0) {
                      coeff <- -1
                    } else if (convex$coef[3] >= 0) {
                      coeff <- 1
                    }
                    flat <- coeff * flat - min(coeff * flat) + 0.0000000000001
                    forward <- apriori_x_after[which.min(abs(apriori_x_after - span))]
                    if (length(apriori_x_after[apriori_x_after < sample]) > 0) {
                      x0 <- apriori_x_after[apriori_x_after < sample]
                      y0 <- flat[apriori_x_after < sample]
                    } else if (length(apriori_x_after[apriori_x_after < 2*sample]) > 0) {
                      x0 <- apriori_x_after[apriori_x_after < 2*sample]
                      y0 <- flat[apriori_x_after < 2*sample]
                    } else if (length(apriori_x_after[apriori_x_after < 3*sample]) > 0) {
                      x0 <- apriori_x_after[apriori_x_after < 3*sample]
                      y0 <- flat[apriori_x_after < 3*sample]
                    } else {
                      x0 <- 0
                      y0 <- 0
                      showNotification(HTML("Not enough data to guess the a priori values of the logarithmic decay.<br>The a priori values must be provided to continue."), action = NULL, duration = 10, closeButton = T, id = "no_logarithmic", type = "warning", session = getDefaultReactiveDomain())
                    }
                    x1 <- apriori_x_after[apriori_x_after > forward - sample & apriori_x_after <= forward]
                    y1 <- flat[apriori_x_after > forward - sample & apriori_x_after <= forward]
                    L0[i] <- coeff * (mean(y0) - mean(y1))
                    sampling_tauL <- function(x) {
                      if (length(apriori_x_after[apriori_x_after > (span/x) - sample & apriori_x_after < span/x]) > 3) {
                        mean(apriori_x_after[apriori_x_after > (span/x) - sample & apriori_x_after < span/x])/(exp(mean(flat[apriori_x_after > (span/x) - sample & apriori_x_after < span/x])/as.numeric(L0[i])) - 1)
                      } else {
                        NA
                      }
                    }
                    tl <- sapply(3:8, function(x) sampling_tauL(x = x))
                    if (!isTruthy(tl)) {
                      tl <- 0
                    }
                    TL0[i] <- median(unlist(tl), na.rm = T) * coeff / 50
                    if (!isTruthy(TL0[i]) || as.numeric(TL0[i]) < 0) {
                      TL0[i] <- abs(as.numeric(TL0[i]))
                    }
                    if (input$fitType == 2) {
                      eL0[i] <- sd(y1)
                      eTL0[i] <- sd(unlist(tl), na.rm = T)
                    }
                  } else {
                    showNotification(HTML("Not enough data to guess the a priori values of the logarithmic decay.<br>The a priori values must be provided to continue."), action = NULL, duration = 10, closeButton = T, id = "no_logarithmic", type = "warning", session = getDefaultReactiveDomain())
                  }
                }
              }
              if (isTruthy(as.numeric(L0[i])) && isTruthy(as.numeric(TL0[i]))) {
                max_decimals <- signifdecimal(as.numeric(L0[i]), F) + 2
                L0[i] <- sprintf("%.*f", max_decimals, as.numeric(L0[i]))
                max_decimals <- signifdecimal(as.numeric(TL0[i]), F) + 2
                TL0[i] <- sprintf("%.*f", max_decimals, as.numeric(TL0[i]))
              }
              if (input$fitType == 2 && isTruthy(as.numeric(eL0[i])) && isTruthy(as.numeric(eTL0[i]))) {
                max_decimals <- signifdecimal(as.numeric(eL0[i]), F) + 2
                eL0[i] <- sprintf("%.*f", max_decimals, as.numeric(eL0[i]))
                max_decimals <- signifdecimal(as.numeric(eTL0[i]), F) + 2
                eTL0[i] <- sprintf("%.*f", max_decimals, as.numeric(eTL0[i]))
              }
            } else {
              if (is.na(L0[i]) || trim(L0[i]) == "NA" || trim(L0[i]) == "") {
                L0[i] <- NA
                TL0[i] <- NA
              } else {
                L0[i] <- NA
                TL0[i] <- NA
                update <- 1
              }
            }
          }
          if (update > 0) {
            line_L0 <- paste(L0, collapse = ", ")
            line_TL0 <- paste(TL0, collapse = ", ")
            inputs$L0 <- line_L0
            inputs$TL0 <- line_TL0
            updateTextInput(session, "L0", value = line_L0)
            updateTextInput(session, "TL0", value = line_TL0)
            if (input$fitType == 1) {
              req(info$stop)
            } else if (input$fitType == 2) {
              line_eL0 <- paste(eL0, collapse = ", ")
              line_eTL0 <- paste(eTL0, collapse = ", ")
              updateTextInput(session, "eL0", value = line_eL0)
              updateTextInput(session, "eTL0", value = line_eTL0)
            }
          }
          for (i in seq_len(length(L0))) {
            if (!is.na(as.numeric(L0[i]))) {
              info$run <- T
              label1 <- paste0("L",i)
              label2 <- paste0("TauL",i)
              text_log <- logas[i]
              model_nls <- paste(model_nls, paste(label1,"*log1p(I(x>",text_log,")*(x-",text_log,")/",label2,")"), sep = " + ")
              model_kf_inst <- paste(model_kf_inst, paste0("e[k,",j,"]*log1p(I(x[k] > ",text_log,")*(x[k]-",text_log,")/e[k,",j + 1,"])"), sep = " + ")
              model_kf_mean <- paste(model_kf_mean, paste0("e[k,",j,"]*log1p(I(x[k] > ",text_log,")*(x[k]-",text_log,")/e[k,",j + 1,"])"), sep = " + ")
              j <- j + 2
              apriori[[label1]] <- as.numeric(L0[i])
              error[[label1]] <- as.numeric(eL0[i])
              nouns <- c(nouns, label1)
              apriori[[label2]] <- as.numeric(TL0[i])
              error[[label2]] <- as.numeric(eTL0[i])
              nouns <- c(nouns, label2)
              if (input$fitType == 2) {
                processNoise <- c(processNoise, 0)
                processNoise <- c(processNoise, 0)
              }
            }
          }
        } else {
          inputs$L0 <- ""
          inputs$TL0 <- ""
          updateTextInput(session, "L0", value = "")
          updateTextInput(session, "TL0", value = "")
          if (input$fitType == 2) {
            updateTextInput(session, "eL0", value = "")
            updateTextInput(session, "eTL0", value = "")
          }
        }
      }
      # * Polynomial model ####
      if ("Polynomial" %in% input$model) {
        if (nchar(input$PolyCoef) > 0) {
          if (!is.na(inputs$PolyCoef) && inputs$PolyCoef > 1 && inputs$PolyCoef < 20) {
            P0 <- unlist(strsplit(input$P0, split = ","))
            eP0 <- unlist(strsplit(input$eP0, split = ","))
            if (isTruthy(info$PolyRef)) {
              refp <- inputs$PolyRef
            } else {
              if ("Linear" %in% input$model) {
                refp <- as.numeric(reft)
              } else {
                if (input$fitType == 1) {
                  refp <- sprintf("%.*f", info$decimalsx, mean(x, na.rm = T))
                  refp <- as.numeric(refp)
                } else if (input$fitType == 2) {
                  refp <- x[1]
                }
                inputs$PolyRef <- refp
              }
              info$PolyRef <- T
              inputs$PolyRef <- refp
              updateTextInput(session, "PolyRef", value = refp)
              if (input$fitType == 1) {
                req(info$stop)
              }
            }
            text_rate <- refp
            i <- 0
            for (degree in 2:inputs$PolyCoef) {
              i <- i + 1
              if (!lm) {
                if (identical(P0[i],character(0)) || is.na(P0[i])) {
                  P0[i] <- 0
                  if (input$fitType == 2) {
                    if (isTruthy(match(paste0("P",degree), trans$names))) {
                      P0[i] <- trans$LScoefs[match(paste0("P",degree), trans$names),1]
                      max_decimals <- signifdecimal(as.numeric(P0[i]), F) + 2
                      P0[i] <- sprintf("%.*f", max_decimals, as.numeric(P0[i]))
                      eP0[i] <- trans$LScoefs[match(paste0("P",degree), trans$names),2]
                      max_decimals <- signifdecimal(as.numeric(eP0[i]), F) + 2
                      eP0[i] <- sprintf("%.*f", max_decimals, as.numeric(eP0[i]))
                    } else {
                      eP0[i] <- 1
                    }
                    line_P0 <- paste(P0, collapse = ", ")
                    line_eP0 <- paste(eP0, collapse = ", ")
                    updateTextInput(session, "P0", value = line_P0)
                    updateTextInput(session, "eP0", value = line_eP0)
                  }
                }
              }
              info$run <- T
              if (input$fitType == 1) {
                if (input$breaking && length(trans$breakEpochs) > 0 && input$polyType > 0) {
                  for (breaks in seq_len(length(trans$breakEpochs) + 1)) {
                    label <- paste0("P",degree,breaks)
                    nouns <- c(nouns, label)
                    if (breaks == 1) {
                      if (lm) {
                        model_lm <- ifelse(nchar(model_lm) > 3, paste(model_lm,"+"), model_lm)
                      }
                      model_lm <- paste0(model_lm, " P(-Inf,",trans$breakEpochs[breaks],",",degree,")")
                      model_nls <- paste(model_nls, paste0(label,"*((x-",text_rate,")^",degree,")*I(x<=",trans$breakEpochs[breaks],")"), sep = " + ")
                    } else if (breaks == length(trans$breakEpochs) + 1) {
                      if (i == 1 && !any(grepl(paste0("Intercept",breaks),nouns))) {
                        nouns <- c(nouns, paste0("Intercept", breaks))
                      }
                      model_lm <- paste0(model_lm, " + I(",trans$breakEpochs[breaks - 1],",Inf) + P(",trans$breakEpochs[breaks - 1],",Inf,",degree,")")
                      model_nls <- paste(model_nls, paste0(label,"*((x-",text_rate,")^",degree,")*I(x>",trans$breakEpochs[breaks - 1],")"), sep = " + ")
                    } else {
                      if (i == 1 && !any(grepl(paste0("Intercept",breaks),nouns))) {
                        nouns <- c(nouns, paste0("Intercept", breaks))
                      }
                      model_lm <- paste0(model_lm, " + I(",trans$breakEpochs[breaks - 1],",",trans$breakEpochs[breaks],") + P(",trans$breakEpochs[breaks - 1],",",trans$breakEpochs[breaks],",",degree,")")
                      model_nls <- paste(model_nls, paste0(label,"*((x-",text_rate,")^",degree,")*I(x>",trans$breakEpochs[breaks - 1]," & x<=",trans$breakEpochs[breaks],")"), sep = " + ")
                    }
                  }
                } else {
                  label <- paste0("P",degree)
                  nouns <- c(nouns, label)
                  if (lm) {
                    model_lm <- ifelse(nchar(model_lm) > 3, paste(model_lm,"+"), model_lm)
                  }
                  model_lm <- paste0(model_lm, " P(-Inf,Inf,",degree,")")
                  model_nsl <- paste(model_nls, paste0(label,"*(x-",text_rate,")^",degree), sep = " + ")
                }
              } else if (input$fitType == 2) {
                label <- paste0("P",degree)
                nouns <- c(nouns, label)
                model_kf <- paste(model_kf, paste0(label,"*(x-",text_rate,")^",degree), sep = " + ")
                model_kf_inst <- paste(model_kf_inst, paste0("e[k,",j,"]*(x[k]-",text_rate,")^",degree), sep = " + ")
                model_kf_mean <- paste(model_kf_mean, paste0("e[k,",j,"]*(x[k]-",text_rate,")^",degree), sep = " + ")
                j <- j + 1
                apriori[[label]] <- as.numeric(P0[i])
                error[[label]] <- as.numeric(eP0[i])
                processNoise <- c(processNoise, 0)
              }
            }
          } else {
            showNotification(HTML("The requested degree of the polynomial is not valid.<br>Check the input value."), action = NULL, duration = 10, closeButton = T, id = "bad_degree", type = "error", session = getDefaultReactiveDomain())
          }
        }
      }
      if (input$fitType == 1) {
        info$parameters <- nouns
        list(model_nls = model_nls, model_lm = model_lm, apriori = apriori)
      } else if (input$fitType == 2) {
        list(model = model_kf, model_kf_mean = model_kf_mean, model_kf_inst = model_kf_inst, apriori = apriori, nouns = nouns, processNoise = processNoise, error = error)
      }
    })
  }
  #
  ReadLog <- function(x) {
    removeNotification("bad_sitelog")
    antrec <- grep("^[34].[x0-9]+ ",readLines(con = x, n = -1L, ok = T, warn = F, skipNul = T), ignore.case = F, perl = T, value = T)
    dates <- grep(" Date Removed             :",readLines(con = x, n = -1L, ok = T, warn = F, skipNul = T), ignore.case = F, perl = T, value = T)
    if (length(antrec) > 0 && length(dates) > 0) {
      ante = c()
      rece = c()
      for (l in seq_len(length(dates))) {
        if (!(grepl('CCYY',dates[[l]]))) {
          f <- data.frame(strsplit(dates[[l]], " :"))[2,]
          t <- strptime(f, format = '%Y-%m-%dT%H:%M', tz = "GMT")
          if (is.na(t)) {
            t <- strptime(f, format = '%Y-%m-%d', tz = "GMT")
          }
          if (!isTruthy(input$tunits) || input$tunits == 3) {
            e <- decimal_date(t)
          } else if (input$tunits == 1) {
            e <- time_length(ymd_hms("1858-11-17 00:00:00") %--% t, unit = "second")/86400  #mjd
          } else if (input$tunits == 2) {
            e <- time_length(ymd_hms("1980-01-06 00:00:00") %--% t, unit = "second")/604800 # GPS week
          }
          if (grepl('Antenna',antrec[[l]])) {
            ante <- c(ante,e)
          } else if (grepl('Receiver',antrec[[1]])) {
            rece <- c(rece,e)
          }
        }
      }
      return(list(ante,rece))
    } else {
      showNotification("The input sitelog file is empty or has a wrong format.", action = NULL, duration = 10, closeButton = T, id = "bad_sitelog", type = "warning", session = getDefaultReactiveDomain())
      return(NULL)
    }
  }
  #
  ReadInfo <- function(x,y,z) {
    antes = c()
    reces = c()
    removeNotification("bad_stationinfo")
    if (!is.null(x)) {
      pattern <- paste0("^ ",x)
      record <- grep(pattern, readLines(con = z$datapath, n = -1L, ok = T, warn = F, skipNul = T), ignore.case = F, perl = T, value = T)
      if (length(record) > 1) {
        for (l in seq_len(length(record))) {
          elements1 <- unlist(strsplit(record[[l]], "\\s+", fixed = F, perl = T, useBytes = F))
          if (length(record) > l) {
            elements2 <- unlist(strsplit(record[[l + 1]], "\\s+", fixed = F, perl = T, useBytes = F))
            t <- strptime(substr(record[[l + 1]],26,43), format = '%Y %j %H %M %S', tz = "GMT")
            if (!isTruthy(input$tunits) || input$tunits == 3) {
              e <- decimal_date(t)
            } else if (input$tunits == 1) {
              e <- time_length(ymd_hms("1858-11-17 00:00:00") %--% t, unit = "second")/86400  #mjd
            } else if (input$tunits == 2) {
              e <- time_length(ymd_hms("1980-01-06 00:00:00") %--% t, unit = "second")/604800 # GPS week
            }
            if (substr(record[[l]],171,213) != substr(record[[l + 1]],171,213)) {
              antes <- c(antes,e)
            } else {
              reces <- c(reces,e)
            }
          }
        }
      } else {
        showNotification(paste("Station",x,"not found in the station.info file."), action = NULL, duration = 10, closeButton = T, id = "bad_stationinfo", type = "warning", session = getDefaultReactiveDomain())
      }
      reces <- unique(reces)
      antes <- unique(antes)
    }
    if (!is.null(y)) {
      pattern <- paste0("^ ",y)
      record <- grep(pattern,readLines(con = z$datapath, n = -1L, ok = T, warn = F, skipNul = T), ignore.case = F, perl = T, value = T)
      if (length(record) > 1) {
        for (l in seq_len(length(record))) {
          elements1 <- unlist(strsplit(record[[l]], "\\s+", fixed = F, perl = T, useBytes = F))
          if (length(record) > l) {
            elements2 <- unlist(strsplit(record[[l + 1]], "\\s+", fixed = F, perl = T, useBytes = F))
            t <- strptime(substr(record[[l + 1]],26,43), format = '%Y %j %H %M %S', tz = "GMT")
            if (input$tunits == 1) {
              e <- time_length(ymd_hms("1858-11-17 00:00:00") %--% t, unit = "second")/86400  #mjd
            } else if (input$tunits == 2) {
              e <- time_length(ymd_hms("1980-01-06 00:00:00") %--% t, unit = "second")/604800 # GPS week
            } else if (input$tunits == 3) {
              e <- decimal_date(t)
            }
            if (substr(record[[l]],171,213) != substr(record[[l + 1]],171,213)) {
              antes <- c(antes,e)
            } else {
              reces <- c(reces,e)
            }
          }
        }
      } else {
        showNotification(paste("Station",y,"not found in the station.info file."), action = NULL, duration = 10, closeButton = T, id = "bad_stationinfo", type = "warning", session = getDefaultReactiveDomain())
      }
    }
    return(list(antes,reces))
  }
  #
  ReadSoln <- function(x,y,z) {
    req(x,z)
    removeNotification("bad_id9")
    ante = c()
    rece = c()
    site <- paste0(" ",x," ")
    antes <- substring(grep(' P -', grep("antenna|radome", grep(site,readLines(z$datapath, warn = F),value = T), ignore.case = T, value = T, invert = F), value = T), 17, 28)
    reces <- substring(grep(' P -', grep("antenna|radome", grep(site,readLines(z$datapath, warn = F),value = T), ignore.case = T, value = T, invert = T), value = T), 17, 28)
    if (length(antes) + length(reces) == 0 && nchar(x) == 9) {
      antes_4char <- substring(grep(' P -', grep("antenna|radome", grep(paste0(" ",substr(x, 1, 4)," "),readLines(z$datapath, warn = F),value = T), ignore.case = T, value = T, invert = F), value = T), 17, 28)
      reces_4char <- substring(grep(' P -', grep("antenna|radome", grep(paste0(" ",substr(x, 1, 4)," "),readLines(z$datapath, warn = F),value = T), ignore.case = T, value = T, invert = T), value = T), 17, 28)
      if (length(antes_4char) + length(reces_4char) != 0) {
        showNotification(HTML(paste("WARNING: the station",x,"was not found in the soln file, but the station",substr(x, 1, 4),"was found.<br>Change the series ID on the left panel if you are sure it corresponds to the same station.")), action = NULL, duration = 10, closeButton = T, id = "bad_id9", type = "warning", session = getDefaultReactiveDomain())
      }
    }
    if (!is.null(y)) {
      site2 <- paste0(" ",y," ")
      antes2 <- substring(grep(' P -', grep("antenna|radome", grep(site2,readLines(z$datapath, warn = F),value = T), ignore.case = T, value = T, invert = F), value = T), 17, 28)
      reces2 <- substring(grep(' P -', grep("antenna|radome", grep(site2,readLines(z$datapath, warn = F),value = T), ignore.case = T, value = T, invert = T), value = T), 17, 28)
      antes <- rbind(antes,antes2)
      reces <- rbind(reces,reces2)
    }
    antes <- antes[antes != "00:000:00000"]
    reces <- reces[reces != "00:000:00000"]
    if (length(antes) > 0) {
      years <- as.numeric(substring(antes, 1, 2)) + 1900
      days <- as.numeric(substring(antes, 4, 6))
      segs <- as.numeric(substring(antes, 8, 12))
      years[years < 1950] <- years[years < 1950] + 100
      antes <- decimal_date(as.Date(days - 1 + segs/86400, origin = paste0(years,"-01-01")))
    }
    if (length(reces) > 0) {
      years <- as.numeric(substring(reces, 1, 2)) + 1900
      days <- as.numeric(substring(reces, 4, 6))
      segs <- as.numeric(substring(reces, 8, 12))
      years[years < 1950] <- years[years < 1950] + 100
      reces <- decimal_date(as.Date(days - 1 + segs/86400, origin = paste0(years,"-01-01")))
    }
    antes <- na.omit(antes)
    reces <- na.omit(reces)
    return(list(antes,reces))
  }
  #
  ReadCustom <- function(x,y,z) {
    req(x,z)
    removeNotification("bad_custom")
    ante = c()
    rece = c()
    cols <- try(range(count.fields(z$datapath, comment.char = "#")), silent = F)
    if (!isTruthy(cols) || inherits(cols,"try-error")) {
      showNotification("Unable to read the input custom discontinuity file.", action = NULL, duration = 15, closeButton = T, id = "bad_custom", type = "error", session = getDefaultReactiveDomain())
      req(info$stop)
    }
    if (!is.na(cols[1]) && !is.na(cols[2]) && cols[2] < 100) {
      if (cols[1] > 1) {
        col <- 2
      } else {
        col <- 1
      }
      table <- try(read.table(z$datapath, comment.char = "#", fill = T), silent = F)
      if (isTruthy(table) && !inherits(table,"try-error")) {
        if (col == 2) {
          if (all(grepl("^\\d{2}\\w{3}\\d{2}$", table$V2, ignore.case = F, perl = T))) { #NGL steps file
            table$dyear <- decimal_date(as.Date(ymd(table$V2)))
            antennaChange <- grepl(pattern = "antenna|radome", x = table$V4[table$V1 == x], fixed = F, ignore.case = T, perl = F)
            if (any(table$V1 == x)) {
              ante <- as.numeric(unlist(unique(table$dyear[table$V1 == x][antennaChange])))
              rece <- as.numeric(unlist(unique(table$dyear[table$V1 == x][!antennaChange])))
            }
            if (!is.null(y)) {
              if (any(table$V1 == y)) {
                ante <- unique(c(ante, as.numeric(unlist(unique(table$dyear[table$V1 == y][antennaChange])))))
                rece <- unique(c(rece, as.numeric(unlist(unique(table$dyear[table$V1 == y][!antennaChange])))))
              }
            }
          } else if (grepl(pattern = "# Offset file|# Events file", x = readLines(z$datapath, n = 1), ignore.case = F, perl = T, fixed = F)) { #FORMATERRE offset file
            table$dyear <- decimal_date(strptime("18581117", format = '%Y%m%d', tz = "GMT") + as.numeric(table$V2)*86400)
            antennaChange <- apply(table, 1, function(row) any(grepl(pattern = "antenna|radome", x = row, fixed = F, ignore.case = T, perl = F)))
            ante <- as.numeric(unlist(unique(table$dyear[table$V1 == x & antennaChange])))
            rece <- as.numeric(unlist(unique(table$dyear[table$V1 == x & !antennaChange])))
            ante <- unique(c(ante, as.numeric(unlist(unique(table$dyear[table$V1 == y & antennaChange])))))
            rece <- unique(c(rece, as.numeric(unlist(unique(table$dyear[table$V1 == y & !antennaChange])))))
          } else {
            if (cols[2] > 2 && info$custom_warn == 0) {
              info$custom_warn <- 1
              showNotification(HTML("The input custom discontinuity file contains more than 2 columns.<br>Only the first 2 will be used."), action = NULL, duration = 15, closeButton = T, id = "bad_custom", type = "warning", session = getDefaultReactiveDomain())
            }
            if (length(table[table$V2 == x,]) > 0) {
              ante <- as.numeric(unique(unlist(table$V1[table$V2 == x])))
            }
            if (!is.null(y)) {
              if (length(table[table$V2 == y,]) > 0) {
                ante <- unique(c(ante, as.numeric(unlist(table$V1[table$V2 == y]))))
              }
            }
          }
        } else {
          ante <- as.numeric(unique(unlist(table)))
        }
        ante <- sort(na.omit(ante), decreasing = F)
        rece <- sort(na.omit(rece), decreasing = F)
      }
    }
    return(list(ante,rece))
  }
  #
  plot_series <- function(x,y,z,rangex,rangey,sigma,title,symbol,unit,xlab) {
    if (symbol == 0) {
      s <- 'p'
    } else if (symbol == 1) {
      s <- 'l'
    } else if (symbol == 2) {
      s <- 'o'
    }
    units <- ""
    if (unit) {
      if (input$sunits == 1) {
        units <- "(m)"
      } else if (input$sunits == 2) {
        units <- "(mm)"
      }
    }
    mini <- min(y, na.rm = T)
    maxi <- max(y, na.rm = T)
    if ((abs(mini) > 999 || abs(maxi) > 999) && abs(maxi - mini) < 999) {
      if (mini < 0) {
        const <- maxi
        ylab <- paste(intToUtf8(8210),abs(mini),units)
      } else {
        const <- mini
        ylab <- paste("+",abs(mini),units)
      }
    } else {
      const <- 0
      ylab <- units
    }
    plot(x, y, type = s, pch = 20, lwd = 2, xlab = xlab, ylab = ylab, xlim = rangex, ylim = rangey, main = title, yaxt = "n")
    p <- par("usr")[3:4] # min/max Y-axis values
    pout <- base::pretty(p - const) # round new min/max Y-axis values
    pin <- pout + const
    axis(2, at = pin, labels = pout)
    if (isTruthy(input$tunits)) {
      if (input$tunits == 1) {
        offset <- 0
        if (all(x < 35000)) {
          offset <- 33282
        }
        if (isTruthy(rangex)) {
          ticks <- base::pretty(x[x > rangex[1] & x < rangex[2]])
        } else {
          ticks <- base::pretty(x)
        }
        labels_dyear <- sprintf("%.2f", decimal_date(as.Date("1858-11-17") + ticks + offset))
        axis(3, at = ticks, labels = labels_dyear)
      } else if (input$tunits == 2) {
        if (isTruthy(rangex)) {
          ticks <- base::pretty(x[x > rangex[1] & x < rangex[2]])
        } else {
          ticks <- base::pretty(x)
        }
        labels_dyear <- sprintf("%.2f", decimal_date(as.Date("1980-01-06") + ticks*7))
        axis(3, at = ticks, labels = labels_dyear)
      }
    }
    if (sigma == T) {
      if (length(y) == length(z)) {
        ba <- y + z
        bb <- y - z
        polygon(c(x, rev(x)), c(ba, rev(bb)), col = rgb(0,0,0,0.2), border = NA)
      } else {
        if (messages > 0) cat(file = stderr(), mySession, paste0("Different length of the series values (", length(y), ") and errorbars (", length(z), "\n"))
        showNotification(HTML("Something is wrong with the series plot and the errorbars could not be plotted.<br>Please contact the author to provide feedback"), action = NULL, duration = 10, closeButton = T, id = "wrong_series", type = "error", session = getDefaultReactiveDomain())
      }
    }
  }
  #
  plot3series <- function(component) {
    removeNotification("wrong_series")
    req(input$tab > 3)
    if (messages > 0) cat(file = stderr(), mySession, "Plotting component", component, "\n")
    if (input$tab == 4) {
      if (input$format2 == 4) {
        component2 <- 1
      } else if (input$ne && component < 3) {
        component2 <- as.numeric(chartr("12", "21", as.character(component)))
      } else {
        component2 <- component
      }
      x0 <- db1[[info$db1]][[paste0("x",input$tunits)]][!is.na(db1[[info$db1]][[paste0("status",component)]])]
      x1 <- db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]][[paste0("status",component)]] %in% T]
      xe <- db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]][[paste0("status",component)]] %in% F]
      y0 <- db1[[info$db1]][[paste0("y",component)]][!is.na(db1[[info$db1]][[paste0("status",component)]])]
      y1 <- db1[[info$db1]][[paste0("y",component)]][db1[[info$db1]][[paste0("status",component)]] %in% T]
      ye <- db1[[info$db1]][[paste0("y",component)]][db1[[info$db1]][[paste0("status",component)]] %in% F]
      centerx <- median(db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]][[paste0("status",component)]]], na.rm = T)
      centery <- median(db1[[info$db1]][[paste0("y",component)]], na.rm = T)
      if (component < 3 && isTruthy(trans$plate) && input$eulerType == 2 && isTruthy(allCoordinates()[c(7,8,9)]) && info$db1 != "merged") {
        y0 <- y0 - trans$plate[component]*(x0 - centerx) - centery
        y1 <- y1 - trans$plate[component]*(x1 - centerx) - centery
        ye <- ye - trans$plate[component]*(xe - centerx) - centery
      }
      if (component > 2 && isTruthy(trans$gia) && input$giaType == 2 && info$db1 != "merged") {
        y0 <- y0 - trans$gia[component]*(x0 - centerx) - centery
        y1 <- y1 - trans$gia[component]*(x1 - centerx) - centery
        ye <- ye - trans$gia[component]*(xe - centerx) - centery
      }
      sy1 <- db1[[info$db1]][[paste0("sy",component)]][db1[[info$db1]][[paste0("status",component)]] %in% T]
    } else if (input$tab == 5) {
      x0 <- x1 <- db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]][[paste0("status",component)]] %in% T & !is.na(db1[[info$db1]][[paste0("res",component)]])]
      xe <- ye <- NULL
      y0 <- y1 <- db1[[info$db1]][[paste0("res",component)]][db1[[info$db1]][[paste0("status",component)]] %in% T & !is.na(db1[[info$db1]][[paste0("res",component)]])]
      sy1 <- db1[[info$db1]][[paste0("reserror",component)]][db1[[info$db1]][[paste0("status",component)]] %in% T & !is.na(db1[[info$db1]][[paste0("res",component)]])]
    } else {
      req(info$stop)
    }
    title <- ""
    sigmas <- F
    if (isTruthy(y1) && length(y1) > 0) {
      if (isTruthy(input$sigmas) && ((info$format == 4 && isTruthy(inputs$errorBar)) || input$format != 4)) {
        sigmas <- T
      }
      rangeX <- range(x0)
      if (input$tab == 4 && input$optionSecondary == 1 && isTruthy(db2[[info$db2]]) && sum(abs(db2[[info$db2]][[paste0("y",component2)]]), na.rm = T) > 0) {
        x2 <- db2[[info$db2]][[paste0("x",input$tunits)]]
        y2 <- db2[[info$db2]][[paste0("y",component2)]] * inputs$scaleFactor
        if (isTruthy(input$fullSeries)) {
          info$minx <- min(x0, x2, na.rm = T)
          info$maxx <- max(x0, x2, na.rm = T)
          rangeX <- c(info$minx, info$maxx)
        } else {
          rangeX <- range(x0)
        }
      }
      if (isTruthy(ranges$x1) && (ranges$x1[1] > rangeX[1] || ranges$x1[2] < rangeX[2])) {
        if (any(!is.na(y1[x1 > ranges$x1[1] & x1 < ranges$x1[2]]))) {
          shinyjs::show(paste0("zoomin",input$tab))
          rangeX <- ranges$x1
        } else {
          ranges$x1 <- NULL
        }
      } else {
        shinyjs::hide(paste0("zoomin",input$tab))
        ranges$x1 <- rangeX
      }
      if (isTruthy(ranges$y1)) {
        rangeY <- ranges$y1
      } else {
        rangeY <- range(y0[x0 >= rangeX[1] & x0 <= rangeX[2]])
      }
      if (input$tab == 4 && input$optionSecondary == 1 && isTruthy(db2[[info$db2]]) && sum(abs(db2[[info$db2]][[paste0("y",component2)]]), na.rm = T) > 0) {
        sy2 <- db2[[info$db2]][[paste0("sy",component2)]] * inputs$scaleFactor
        if (component2 < 3 && isTruthy(trans$plate2) && input$eulerType == 2 && isTruthy(allCoordinates()[c(10,11,12)])) {
          y2 <- y2 - trans$plate2[component2]*(x2 - centerx)*inputs$scaleFactor - centery
        }
        if (component2 > 2  && isTruthy(trans$gia2) && input$giaType == 2) {
          y2 <- y2 - trans$gia2[component2]*(x2 - centerx)*inputs$scaleFactor - centery
        }
        if (input$symbol == 0) {
          symbol <- 'p'
        } else if (input$symbol == 1) {
          symbol <- 'l'
        } else if (input$symbol == 2) {
          symbol <- 'o'
        }
        if (input$sameScale) {
          pointsX1 <- x1[x1 >= rangeX[1] & x1 <= rangeX[2]]
          pointsX2 <- x2[x2 >= rangeX[1] & x2 <= rangeX[2]]
          pointsY1 <- y1[x1 >= rangeX[1] & x1 <= rangeX[2]]
          pointsY2 <- y2[x2 >= rangeX[1] & x2 <= rangeX[2]]
          rangeY2 <- range(pointsY2)
          range1 <- diff(range(pointsY1))
          range2 <- diff(rangeY2)
          if (input$fullSeries) {
            if (range1 >= range2) {
              rangeY2[1] <- rangeY2[1] - (range1 - range2)/2
              rangeY2[2] <- rangeY2[2] + (range1 - range2)/2
            } else {
              rangeY[1] <- rangeY[1] - (range2 - range1)/2
              rangeY[2] <- rangeY[2] + (range2 - range1)/2
            }
          } else {
            middle <- ifelse(isTruthy(pointsY2), median(pointsY2), 0)
            rangeY2 <- c(middle - range1/2, middle + range1/2)
          }
          # adjusting the vertical offset within the same scale (range)
          if (length(pointsX1) == 0 || length(pointsX2) == 0) {
            # NA
          } else if (pointsX2[1] > pointsX1[length(pointsX1)]) {
            # NA
          } else if (pointsX1[1] > pointsX2[length(pointsX2)]) {
            # NA
          } else {
            tie1 <- sort(sapply(pointsX1, function(x) min(abs(pointsX2 - x))), index.return = T)$ix
            tie2 <- sort(sapply(pointsX2, function(x) min(abs(pointsX1 - x))), index.return = T)$ix
            tie1 <- tie1[1:min(length(tie1),length(tie2))]
            tie2 <- tie2[1:min(length(tie1),length(tie2))]
            pointsBias <- median(pointsY1[tie1] - pointsY2[tie2])
            if (input$fullSeries) {
              if (range1 >= range2) {
                rangeY2 <- rangeY2 + (rangeY[1] - rangeY2[1]) - pointsBias
              } else {
                rangeY <- rangeY + (rangeY2[1] - rangeY[1]) + pointsBias
              } 
            } else {
              rangeY2 <- rangeY2 + (rangeY[1] - rangeY2[1]) - pointsBias
            }
          }
        } else if (isTruthy(input$same_axis)) {
          if (input$fullSeries) {
            pointsY1 <- y1[x1 >= rangeX[1] & x1 <= rangeX[2]]
            pointsY2 <- y2[x2 >= rangeX[1] & x2 <= rangeX[2]]
            range <- range(c(pointsY1,pointsY2))
            rangeY2 <- rangeY <- range
          } else {
            rangeY2 <- rangeY 
          }
        } else {
          ids <- x2 >= rangeX[1] & x2 <= rangeX[2]
          if (sum(ids) > 0) {
            rangeY2 <- range(y2[ids], na.rm = T)
          } else {
            rangeY2 <- range(y2, na.rm = T)
          }
        }
        ranges[[paste0("y3D",component,2)]] <- rangeY2
        plot(x2, y2, type = symbol, lwd = 2, cex = 1.1, pch = 23, col = SARIcolors[3], axes = F, xlab = NA, ylab = NA, xlim = rangeX, ylim = rangeY2)
        if (isTruthy(sigmas)) {
          color <- SARIcolors[3]
          alfa <- 0.2
          shade <- adjustcolor(color, alpha.f = alfa)
          ba <- y2 + sy2
          bb <- y2 - sy2
          polygon(c(x2, rev(x2)), c(ba, rev(bb)), col = shade, border = NA)
        }
        axis(side = 4, at = NULL, labels = T, tick = T, line = NA, pos = NA, outer = F)
        par(new = T)
      }
      ranges[[paste0("y3D",component,1)]] <- rangeY
      plot_series(x1,y1,sy1,rangeX,rangeY,sigmas,title,input$symbol,T,info$tunits.label)
      points(xe, ye, type = "p", col = SARIcolors[2], bg = 2, pch = 21)
      output[[paste0("component",input$tab,component)]] <- renderText(sub(" component", "", info$components[component]))
      xx <- median(x1[x1 > rangeX[1] & x1 < rangeX[2]], na.rm = T)
      yy <- median(y1[x1 > rangeX[1] & x1 < rangeX[2]], na.rm = T)
      centerx <- which(abs(x1 - xx) == min(abs(x1 - xx)))[1]
      centery <- which(abs(y1 - yy) == min(abs(y1 - yy)))[1]
      if (component < 3 && input$eulerType == 1 && length(trans$plate[!is.na(trans$plate)]) == 3) {
        rate <- trans$plate[component]
      }
      if (component > 2 && input$giaType == 1 && length(trans$gia[!is.na(trans$gia)]) == 3) {
        rate <- trans$gia[component]
      }
      if (input$tab == 4 && exists("rate") && is.numeric(rate)) {
        lines(c(x1[1],x1[length(x1)]),c(y1[centery] + rate*(x1[1] - x1[centerx]),y1[centery] + rate*(x1[length(x1)] - x1[centerx])), col = SARIcolors[4], lwd = 3)
      }
      if (input$traceLog && length(info$log) > 0) {
        for (r in info$log[[2]]) {
          abline(v = r, col = SARIcolors[4], lty = 2)
        }
        for (a in info$log[[1]]) {
          abline(v = a, col = SARIcolors[4])
        }
      }
      if (input$traceSinfo && length(info$sinfo) > 0) {
        for (r in info$sinfo[[2]]) {
          abline(v = r, col = SARIcolors[6], lty = 2)
        }
        for (a in info$sinfo[[1]]) {
          abline(v = a, col = SARIcolors[6])
        }
      }
      if (input$traceSoln && length(info$soln) > 0) {
        for (r in info$soln[[2]]) {
          abline(v = r, col = SARIcolors[8], lty = 2)
        }
        for (a in info$soln[[1]]) {
          abline(v = a, col = SARIcolors[8])
        }
      }
      if (input$traceCustom && length(info$custom) > 0) {
        for (r in info$custom[[2]]) {
          abline(v = r, col = SARIcolors[5], lty = 2)
        }
        for (a in info$custom[[1]]) {
          abline(v = a, col = SARIcolors[5])
        }
      }
      if (input$tab == 4 && isTruthy(db1[[info$db1]][[paste0("mod",component)]]) > 0) {
        lines(db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]][[paste0("status",component)]] %in% T],db1[[info$db1]][[paste0("mod",component)]][db1[[info$db1]][[paste0("status",component)]] %in% T], col = SARIcolors[2], lwd = 3)
        if (input$breaking && isTruthy(trans$breakEpochs) && (input$trendType > 0 || input$sinusoidType > 0 || input$polyType > 0)) {
          for (p in trans$breakEpochs) {
            abline(v = p, col = SARIcolors[3], lwd = 2, lty = 3)
          }
        }
      }
      if (input$tab == 5) {
        if (length(trans[[paste0("offsetEpochs",component)]]) > 0) {
          for (p in trans[[paste0("offsetEpochs",component)]]) {
            abline(v = p, col = SARIcolors[2], lwd = 2)
          }
        }
        if (input$breaking && isTruthy(trans$breakEpochs) && (input$trendType > 0 || input$sinusoidType > 0 || input$polyType > 0)) {
          for (p in trans$breakEpochs) {
            abline(v = p, col = SARIcolors[3], lwd = 2, lty = 3)
          }
        }
      }
    }
  }
  #
  periodogram <- function(serie) {
    req(trans$fs)
    if (messages > 0) cat(file = stderr(), mySession, "Computing periodogram", serie, "\n")
    info$clickX <- info$clickY <- info$closestX <- info$closestY <- NULL
    withProgress(message = 'Computing  periodogram.',
                 detail = 'This may take a while ...', value = 0, {
                   incProgress(0.5)
                   if (input$spectrumOriginal && any("all" %in% serie || "original" %in% serie)) {
                     trans$title[2] <- "original (black), "
                     lombscargle <- spec.lomb(y = trans$y, x = trans$x - trans$x[1], f = trans$fs, w = trans$sy, mode = "normal")
                     trans$fs <- lombscargle$f
                     trans$spectra <- 1/lombscargle$f
                     trans$amp[,1] <- lombscargle$A
                     trans$psd[,1] <- lombscargle$PSD*var(trans$y)
                     trans$var <- var(trans$y)
                   }
                   if (input$spectrumModel && length(trans$mod) > 0 && length(trans$res) > 0 && any("all" %in% serie || "model" %in% serie)) {
                     trans$title[3] <- "model (red), "
                     ideal <- trans$mod
                     lombscargle <- spec.lomb(y = ideal, x = trans$x - trans$x[1], f = trans$fs, mode = "normal")
                     trans$fs <- lombscargle$f
                     trans$spectra <- 1/lombscargle$f
                     trans$amp[,2] <- lombscargle$A
                     trans$psd[,2] <- lombscargle$PSD*var(ideal)
                     trans$var <- var(ideal)
                   }
                   if (input$spectrumResiduals && length(trans$res) > 0 && any("all" %in% serie || "residuals" %in% serie)) {
                     trans$title[4] <- "model residuals (green), "
                     if (length(trans$reserror) > 0) {
                       sy <- trans$reserror
                     } else {
                       sy <- trans$sy
                     }
                     lombscargle <- spec.lomb(y = as.vector(trans$res), x = trans$x - trans$x[1], f = trans$fs, w = sy, mode = "normal")
                     trans$fs <- lombscargle$f
                     trans$spectra <- 1/lombscargle$f
                     trans$amp[,3] <- lombscargle$A
                     trans$psd[,3] <- lombscargle$PSD*var(as.vector(trans$res))
                     trans$var <- var(as.vector(trans$res))
                   }
                   if (input$spectrumFilter && length(trans$filter > 0) && any("all" %in% serie || "filter" %in% serie)) {
                     trans$title[5] <- "filter (blue), "
                     lombscargle <- spec.lomb(y = as.vector(trans$filter), x = trans$x - trans$x[1], f = trans$fs, mode = "normal")
                     trans$fs <- lombscargle$f
                     trans$spectra <- 1/lombscargle$f
                     trans$amp[,4] <- lombscargle$A
                     trans$psd[,4] <- lombscargle$PSD*lombscargle$PSD*var(as.vector(trans$filter))
                     trans$var <- var(as.vector(trans$filter))
                   }
                   if (input$spectrumFilterRes && length(trans$filterRes) > 0 && any("all" %in% serie || "filterRes" %in% serie)) {
                     trans$title[6] <- "filter residuals (cyan), "
                     lombscargle <- spec.lomb(y = as.vector(trans$filterRes), x = trans$x - trans$x[1], f = trans$fs, mode = "normal")
                     trans$fs <- lombscargle$f
                     trans$spectra <- 1/lombscargle$f
                     trans$amp[,5] <- lombscargle$A
                     trans$psd[,5] <- lombscargle$PSD*var(as.vector(trans$filterRes))
                     trans$var <- var(as.vector(trans$filterRes))
                   }
                   trans$spectra_old <- c(input$spectrumOriginal,input$spectrumModel,input$spectrumResiduals,input$spectrumFilter,input$spectrumFilterRes)
                 })
  }
  #
  vondrak <- function(x,y,yp,p) {
    #code adapted from Sylvain Loyer's Fortran code and from Vondrak's 1969 paper
    removeNotification("bad_vondrak_period")
    n <- length(x)
    p <- as.numeric(p)/(0.791020*log(n) - 2.339407)
    yp <- yp/sum(yp)
    xdim <- n - 3
    sr <- as.numeric(tail(x, n = 1) - x[1])
    if (p/sr >= 0.1) {
      showNotification(HTML("The input period of the Vondrak filter is larger than T/10.<br>Results may be unreliable."), action = NULL, duration = 10, closeButton = T, id = "bad_vondrak_period", type = "warning", session = getDefaultReactiveDomain())
    }
    eps <- ((10^4.64)*p^-6)/xdim
    kmoy <- 10
    xpu <- matrix(0,n,1)
    for (i in seq_len(n)) {
      pm <- 0
      if (i < kmoy + 1) {
        ir <- 1
      } else if (i > n - kmoy) {
        ir <- n - 2*kmoy
      } else {
        ir <- i - kmoy
      }
      is <- ir + 2*kmoy
      pm <- sum(sapply(ir:is, function(x) yp[x]/(2*kmoy + 1)))
      xpu[i] <- yp[i]/pm
    }
    aa <- matrix(0,7,n)
    yl <- matrix(0,n,1)
    xpp <- matrix(0,4,4)
    nlim <- n - 2
    ls <- n - 3
    for (i in seq_len(n)) {
      delx <- x[i + 2] - x[i + 1]
      aux <- (6*sqrt(delx))/sqrt(sr)
      if (i > ls) {
        xpp[,4] <- 0
      } else {
        xpp[1,4] <- aux/((x[i] - x[i + 1])*(x[i] - x[i + 2])*(x[i] - x[i + 3]))
        xpp[2,4] <- aux/((x[i + 1] - x[i])*(x[i + 1] - x[i + 2])*(x[i + 1] - x[i + 3]))
        xpp[3,4] <- aux/((x[i + 2] - x[i + 1])*(x[i + 2] - x[i])*(x[i + 2] - x[i + 3]))
        xpp[4,4] <- aux/((x[i + 3] - x[i + 1])*(x[i + 3] - x[i + 2])*(x[i + 3] - x[i]))
      }
      aa[1,i] <- xpp[1,1]*xpp[4,1]
      aa[2,i] <- xpp[1,2]*xpp[3,2] + xpp[2,1]*xpp[4,1]
      aa[3,i] <- xpp[1,3]*xpp[2,3] + xpp[2,2]*xpp[3,2] + xpp[3,1]*xpp[4,1]
      aa[4,i] <- eps*yp[i] + xpp[1,4]*xpp[1,4] + xpp[2,3]*xpp[2,3] + xpp[3,2]*xpp[3,2] + xpp[4,1]*xpp[4,1]
      aa[5,i] <- xpp[1,4]*xpp[2,4] + xpp[2,3]*xpp[3,3] + xpp[3,2]*xpp[4,2]
      aa[6,i] <- xpp[1,4]*xpp[3,4] + xpp[2,3]*xpp[4,3]
      aa[7,i] <- xpp[1,4]*xpp[4,4]
      for (j in seq_len(3)) {
        for (l in seq_len(4)) {
          xpp[l,j] <- xpp[l,j + 1]
        }
      }
      yl[i] <- eps*yp[i]*y[i]
    }
    ndep <- 0
    repeat {
      i1 <- 4
      if (ndep == 0) {
        j1 <- 1
        ndep <- 1
      } else {
        j1 <- j1 + 1
      }
      if (j1 == nlim) {
        i1 <- 4
        j1 <- n - 2
        i2 <- 3
        j2 <- n - 1
        while (i2 != 1) {
          ls <- i2 + 2
          coef <- aa[i2,j2]/aa[i1,j1]
          il1 <- 3
          for (il in i2:ls) {
            il1 <- il1 + 1
            aa[il,j2] <- aa[il,j2] - aa[il1,j1]*coef
          }
          yl[j2] <- yl[j2] - yl[j1]*coef
          i2 <- i2 - 1
          j2 <- j2 + 1
        }
        j1 <- n - 1
        coef <- aa[3,n]/aa[4,j1]
        aa[4,n] <- aa[4,n] - aa[5,j1]*coef
        yl[n] <- yl[n] - yl[j1]*coef
        yl[n] <- yl[n]/aa[4,n]
        yl[j1] <- (yl[j1] - aa[5,j1]*yl[n])/aa[4,j1]
        j2 <- n - 2
        yl[j2] <- (yl[j2] - aa[5,j2]*yl[j1] - aa[6,j2]*yl[n])/aa[4,j2]
        jl <- n - 3
        for (j in seq_len(jl)) {
          inn <- j2 - j
          yl[inn] <- (yl[inn] - aa[5,inn]*yl[inn + 1] - aa[6,inn]*yl[inn + 2] - aa[7,inn]*yl[inn + 3])/aa[4,inn]
        }
        break
      } else {
        i2 <- 3
        j2 <- j1 + 1
        while (i2 != 0) {
          coef <- aa[i2,j2]/aa[i1,j1]
          ls <- i2 + 3
          il1 <- 3
          for (il in i2:ls) {
            il1 <- il1 + 1
            aa[il,j2] <- aa[il,j2] - aa[il1,j1]*coef
          }
          yl[j2] <- yl[j2] - yl[j1]*coef
          i2 <- i2 - 1
          j2 <- j2 + 1
        }
      }
    }
    return(yl)
  }
  #
  trim    <- function(x) { gsub("^\\s+|\\s+$", "", x) }
  #
  collect <- function(file_out) {
    if (messages > 0) cat(file = stderr(), mySession, "Downloading results", "\n")
    id <- showNotification("Preparing file to download ...", action = NULL, duration = NULL, closeButton = T, id = NULL, type = "warning", session = getDefaultReactiveDomain())
    now <- paste0(" run on ",Sys.time()," ",Sys.timezone())
    cat(paste0("# ",version,now), file = file_out, sep = "\n", fill = F, append = F)
    cat(paste0("# Original series: ",file$primary$name), file = file_out, sep = "\n", fill = F, append = T)
    if (input$format != 4) {
      if (input$tab < 4) {
        cat(paste0("# Coordinate component: ", info$components[as.numeric(input$tab)]), file = file_out, sep = "\n", fill = F, append = T)
      }
    } else {
      if (isTruthy(input$sigmas)) {
        cat(paste0("# Column numbers for data and errorbars: ",inputs$variable," ",inputs$errorBar), file = file_out, sep = "\n", fill = F, append = T)
      } else {
        cat(paste0("# Column number for data: ",inputs$variable), file = file_out, sep = "\n", fill = F, append = T)
      }
    }
    if (input$tunits == 1) {
      period <- "day"
      periods <- "days"
    } else if (input$tunits == 2) {
      period <- "week"
      periods <- "weeks"
    } else if (input$tunits == 3) {
      period <- "year"
      periods <- "years"
    }
    if (input$sunits == 1) {
      unit <- "m"
      units <- paste0("m/",period)
    } else if (input$sunits == 2) {
      unit <- "mm"
      units <- paste0("mm/",period)
    } else {
      unit <- ""
      units <- ""
    }
    cat(paste('# Series units:', unit, periods, units), file = file_out, sep = "\n", fill = F, append = T)
    if (isTruthy(inputs$step) && inputs$step > 0) {
      if (info$stepUnit == 1) {
        stepUnit <- "days"
      } else if (info$stepUnit == 2) {
        stepUnit <- "weeks"
      } else if (info$stepUnit == 3) {
        stepUnit <- "years"
      }
      cat(paste('# Resampling:', inputs$step, stepUnit), file = file_out, sep = "\n", fill = F, append = T)
    }
    if (input$optionSecondary == 2) {
      if (length(file$secondary$name) > 1) {
        cat(paste('# Corrected with:', paste(input$product2, collapse = " & ")), file = file_out, sep = "\n", fill = F, append = T)
      } else {
        cat(sprintf('# Corrected with: %s',file$secondary$name), file = file_out, sep = "\n", fill = F, append = T)
      }
    } else if (input$optionSecondary == 3) {
      if (length(file$secondary$name) > 1) {
        cat(paste('# Averaged with:', paste(input$product2, collapse = " & ")), file = file_out, sep = "\n", fill = F, append = T)
      } else {
        cat(sprintf('# Averaged with: %s',file$secondary$name), file = file_out, sep = "\n", fill = F, append = T)
      }
    } else if (input$optionSecondary == 4) {
      if (length(file$secondary$name) > 1) {
        cat(paste('# Merged with:', paste(input$product2, collapse = " & ")), file = file_out, sep = "\n", fill = F, append = T)
      } else {
        cat(sprintf('# Merged with: %s',file$secondary$name), file = file_out, sep = "\n", fill = F, append = T)
      }
    }
    if (input$eulerType == 2 && length(trans$plate) > 0) {
      if (input$tab == 4 || input$tab == 5) {
        if (isTruthy(input$plateModel) && isTruthy(input$plate)) {
          cat(paste(sprintf('# Plate model rate removed %s: %f', info$components[1], trans$plate[1]), units, "from model", input$plateModel, "and plate", input$plate), file = file_out, sep = "\n", fill = F, append = T)
          cat(paste(sprintf('# Plate model rate removed %s: %f', info$components[2], trans$plate[2]), units, "from model", input$plateModel, "and plate", input$plate), file = file_out, sep = "\n", fill = F, append = T)
        } else {
          cat(paste(sprintf('# Plate model rate removed %s: %f', info$components[1], trans$plate[1]), units), file = file_out, sep = "\n", fill = F, append = T)
          cat(paste(sprintf('# Plate model rate removed %s: %f', info$components[2], trans$plate[2]), units), file = file_out, sep = "\n", fill = F, append = T)
        }
      } else if (input$format == 4 || input$tab < 3) {
        cat(paste(sprintf('# Plate model rate removed: %f', trans$plate[as.numeric(input$tab)]), units, "from model", input$plateModel, "and plate", input$plate), file = file_out, sep = "\n", fill = F, append = T)
      }
    }
    if (input$giaType == 2 && length(trans$gia) > 0 && (input$format == 4 || input$tab > 2)) {
      cat(paste(sprintf('# GIA model uplift removed: %f', trans$gia[3]), units, "from model", input$giaModel), file = file_out, sep = "\n", fill = F, append = T)
    }
    if (input$tab < 4) {
      if (input$fitType == 1 && length(trans$results) > 0) {
        cat(paste0("# Model LS: ", gsub("Epoch", "x", gsub("\\(I", "I", sub("=", " = ", gsub("&" , " \\+ ", gsub("\\s+", "", gsub(" \\+ ", "&", gsub(" > ", ">", gsub(" - ", "-", gsub(" \\* ", "\\*", gsub("))", ")", gsub("I\\(", "if(", gsub("I\\(cos", "cos", gsub("I\\(sin", "sin", gsub("^ *|(?<= ) | *$", "", Reduce(paste, trans$equation), perl = TRUE))))))))))))))), file = file_out, sep = "\n", fill = F, append = T)
        param <- data.frame(formatting(trans$LScoefs[,c(1,2)],0), check.names = F)
        param <- cbind(e = rep("=",length(param[1])), param[1], s = rep("+/-",length(param[1])), param[2])
        rownames(param) <- format(paste("# Parameter:",rownames(param)), justify = "left")
        write.table(param, file = file_out, col.names = F, row.names = T, append = T, quote = F)
        if (isTruthy(trans$results$sinusoidales)) {
          for (i in 1:dim(trans$results$sinusoidales)[1]) {
            cat(paste('# Sinusoidal period', sprintf('%*s', max(nchar(trans$results$sinusoidales[,1])), trans$results$sinusoidales[i,1]), ':   Amplitude', formatting(trans$results$sinusoidales[i,2],1), '+/-', formatting(trans$results$sinusoidales[i,3],1), unit, '   Phase ', formatting(trans$results$sinusoidales[i,4],1), '+/-', formatting(trans$results$sinusoidales[i,5],1), 'rad'), file = file_out, sep = "\n", fill = F, append = T)
          }
        }
        cat(paste("# Standard error scale factor:", formatting(trans$results$sigma,0)), file = file_out, sep = "\n", fill = F, append = T)
      } else if (input$fitType == 2 && length(trans$kalman) > 0) {
        if (input$kf == 1) {
          cat(paste0("# Model EKF: ",gsub(" > ", ">", gsub(" - ", "-", gsub(" \\* ", "\\*", gsub("))", ")", gsub("I\\(x>", "if(x>", gsub("I\\(cos", "cos", gsub("I\\(sin", "sin", gsub("^ *|(?<= ) | *$", "", Reduce(paste, trans$equation), perl = TRUE))))))))), file = file_out, sep = "\n", fill = F, append = T)
        } else if (input$kf == 2) {
          cat(paste0("# Model UKF: ",gsub(" > ", ">", gsub(" - ", "-", gsub(" \\* ", "\\*", gsub("))", ")", gsub("I\\(x>", "if(x>", gsub("I\\(cos", "cos", gsub("I\\(sin", "sin", gsub("^ *|(?<= ) | *$", "", Reduce(paste, trans$equation), perl = TRUE))))))))), file = file_out, sep = "\n", fill = F, append = T)
        }
        cat(paste('# Parameter:', colnames(trans$kalman), '=', formatting(colMeans(trans$kalman),1), '+/-', formatting(colMeans(trans$kalman_unc),1)), file = file_out, sep = "\n", fill = F, append = T)
        cat(paste('# Initial:', trans$kalman_info$nouns, '=', formatting(trans$kalman_info$apriori,1), '+/-', formatting(trans$kalman_info$error,1)), file = file_out, sep = "\n", fill = F, append = T)
        cat(paste('# Process noise:', trans$kalman_info$nouns, '=', as.list(formatting(sqrt(trans$kalman_info$processNoise),1))), file = file_out, sep = "\n", fill = F, append = T)
        cat(paste('# Measurement noise:', formatting(inputs$ObsError,1), unit), file = file_out, sep = "\n", fill = F, append = T)
      }
      if (length(trans$offsetEpochs) > 0) {
        cat(paste0('# Discontinuities at: ',paste(trans$offsetEpochs, collapse = ", ")), file = file_out, sep = "\n", fill = F, append = T)
      }
      if (length(trans$breakEpochs) > 0) {
        cat(paste0('# Breakpoints at: ',paste(trans$breakEpochs, collapse = ", ")), file = file_out, sep = "\n", fill = F, append = T)
      }
      if (isTruthy(trans$midas_vel) && isTruthy(input$midas)) {
        if (isTruthy(trans$midas_vel2)) {
          formatted <- formatting(c(trans$midas_vel,trans$midas_sig),1)
          cat(paste('# MIDAS rate:', formatted[1], '+/-', formatted[2], units, '#discontinuities included'), file = file_out, sep = "\n", fill = F, append = T)
          formatted <- formatting(c(trans$midas_vel2,trans$midas_sig2),1)
          cat(paste('# MIDAS rate:', formatted[1], '+/-', formatted[2], units, '#discontinuities skipped'), file = file_out, sep = "\n", fill = F, append = T)
        } else {
          formatted <- formatting(c(trans$midas_vel,trans$midas_sig),1)
          cat(paste('# MIDAS rate:', formatted[1], '+/-', formatted[2], units), file = file_out, sep = "\n", fill = F, append = T)
        }
      }
      if (isTruthy(trans$entropy_vel) && isTruthy(input$entropy)) {
        formatted <- formatting(c(trans$entropy_vel,trans$entropy_sig),1)
        cat(paste('# Minimum entropy rate:', formatted[1], '+/-', formatted[2], units), file = file_out, sep = "\n", fill = F, append = T)
      }
      if (input$waveform && inputs$waveformPeriod > 0) {
        cat(paste('# Waveform:', as.numeric(inputs$waveformPeriod), periods), file = file_out, sep = "\n", fill = F, append = T)
      }
      if (isTruthy(input$filter)) {
        if (isTruthy(trans$vondrak) && (isTruthy(inputs$low) || isTruthy(inputs$high))) {
          if (input$series2filter == 1) {
            origen <- " from original series"
          } else if (input$series2filter == 2) {
            origen <- " from residual series"
          }
          if (isTruthy(trans$vondrak[1]) && isTruthy(trans$vondrak[2])) {
            cat(paste('# Vondrak:', trans$vondrak[1], periods, '(low)', trans$vondrak[2], periods, '(high)', origen), file = file_out, sep = "\n", fill = F, append = T)
          } else if (isTruthy(trans$vondrak[1])) {
            cat(paste('# Vondrak:', trans$vondrak[1], periods, '(low)', origen), file = file_out, sep = "\n", fill = F, append = T)
          } else if (isTruthy(trans$vondrak[2])) {
            cat(paste('# Vondrak:', trans$vondrak[2], periods, '(high)'), file = file_out, sep = "\n", fill = F, append = T)
          }
        }
      }
      if (isTruthy(trans$noise) && (isTruthy(input$mle))) {
        if (isTruthy(trans$noise[1])) {
          cat(paste('# Noise: WH', formatting(trans$noise[1],0), '+/-', formatting(trans$noise[2],0), unit), file = file_out, sep = "\n", fill = F, append = T)
        }
        if (isTruthy(trans$noise[3])) {
          cat(paste('# Noise: FL', formatting(trans$noise[3],0), '+/-', formatting(trans$noise[4],0), unit, paste0(period,"^(-1/4)")), file = file_out, sep = "\n", fill = F, append = T)
        }
        if (isTruthy(trans$noise[5])) {
          cat(paste('# Noise: RW', formatting(trans$noise[5],0), '+/-', formatting(trans$noise[6],0), unit, paste0(period,"^(-1/2)")), file = file_out, sep = "\n", fill = F, append = T)
        }
        if (isTruthy(trans$noise[7])) {
          cat(paste('# Noise: PL', formatting(trans$noise[7],0), '+/-', formatting(trans$noise[8],0), unit, paste0(period,"^(K/4)")), file = file_out, sep = "\n", fill = F, append = T)
        }
        if (isTruthy(trans$noise[9])) {
          cat(paste('# Noise: K', format(trans$noise[9], nsmall = 3, scientific = F, trim = F), '+/-', format(trans$noise[10], nsmall = 3, scientific = F, trim = F)), file = file_out, sep = "\n", fill = F, append = T)
        }
        if (isTruthy(trans$noise[11])) {
          cat(sprintf('# Noise: MLE %s', format(trans$noise[11]/-1, nsmall = 2, scientific = F, trim = F)), file = file_out, sep = "\n", fill = F, append = T)
        }
      }
    } else if (input$tab == 5) {
      if (length(trans$offsetEpochs1) > 0) {
        cat(paste0('# Discontinuities ', info$components[1], ' at: ',paste(trans$offsetEpochs1, collapse = ", ")), file = file_out, sep = "\n", fill = F, append = T)
      }
      if (length(trans$offsetEpochs2) > 0) {
        cat(paste0('# Discontinuities ', info$components[2], ' at: ',paste(trans$offsetEpochs2, collapse = ", ")), file = file_out, sep = "\n", fill = F, append = T)
      }
      if (length(trans$offsetEpochs3) > 0) {
        cat(paste0('# Discontinuities ', info$components[3], ' at: ',paste(trans$offsetEpochs3, collapse = ", ")), file = file_out, sep = "\n", fill = F, append = T)
      }
    }
    # Checking sigmas
    useSigmas <- F
    if (isTruthy(input$sigmas)) {
      if (input$tab < 4) {
        u <- data.frame(sy = trans$sy)
      } else if (input$tab == 4) {
        u <- data.frame(sy1 = db1[[info$db1]]$sy1[db1[[info$db1]]$status1 %in% T],
                        sy2 = db1[[info$db1]]$sy2[db1[[info$db1]]$status2 %in% T],
                        sy3 = db1[[info$db1]]$sy3[db1[[info$db1]]$status3 %in% T])
      } else if (input$tab == 5) {
        u <- data.frame(sy1 = db1[[info$db1]]$reserror1[db1[[info$db1]]$status1 %in% T],
                        sy2 = db1[[info$db1]]$reserror2[db1[[info$db1]]$status2 %in% T],
                        sy3 = db1[[info$db1]]$reserror3[db1[[info$db1]]$status3 %in% T])
      }
      if (all(apply(u,2,function(col) length(unique(col))) > 0) || (all(apply(u,2,function(col) length(unique(col))) == 1) && all(u > 1.5e-9))) {
        useSigmas <- T
      }
    }
    # Adding input data columns
    if (input$tab < 4) {
      if (isTruthy(useSigmas)) {
        OutPut$df <- data.frame(x = trans$x, y = trans$y, sy = trans$sy)
        names(OutPut$df) <- c("# Epoch", "Data", "Sigma")
      } else {
        OutPut$df <- data.frame(x = trans$x, y = trans$y)
        names(OutPut$df) <- c("# Epoch", "Data")
      }
    } else if (input$tab == 4) {
      if (isTruthy(trans$plate) && info$db1 != "merged") {
        centerx <- median(db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]]$status1], na.rm = T)
        centery <- median(db1[[info$db1]]$y1, na.rm = T)
        component1 <- data.frame(x = db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]]$status1 %in% T], y = db1[[info$db1]]$y1[db1[[info$db1]]$status1 %in% T] - trans$plate[1]*(db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]]$status1 %in% T] - centerx) - centery)
        centerx <- median(db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]]$status2], na.rm = T)
        centery <- median(db1[[info$db1]]$y2, na.rm = T)
        component2 <- data.frame(x = db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]]$status2 %in% T], y = db1[[info$db1]]$y2[db1[[info$db1]]$status2 %in% T] - trans$plate[2]*(db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]]$status2 %in% T] - centerx) - centery)
      } else {
        component1 <- data.frame(x = db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]]$status1 %in% T], y = db1[[info$db1]]$y1[db1[[info$db1]]$status1 %in% T])
        component2 <- data.frame(x = db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]]$status2 %in% T], y = db1[[info$db1]]$y2[db1[[info$db1]]$status2 %in% T])
      }
      if (isTruthy(trans$gia) && info$db1 != "merged") {
        centerx <- median(db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]]$status3], na.rm = T)
        centery <- median(db1[[info$db1]]$y3, na.rm = T)
        component3 <- data.frame(x = db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]]$status3 %in% T], y = db1[[info$db1]]$y3[db1[[info$db1]]$status3 %in% T] - trans$gia[3]*(db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]]$status3 %in% T] - centerx) - centery)
      } else {
        component3 <- data.frame(x = db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]]$status3 %in% T], y = db1[[info$db1]]$y3[db1[[info$db1]]$status3 %in% T])
      }
      if (isTruthy(useSigmas)) {
        component1$sy <- u$sy1
        component2$sy <- u$sy2
        component3$sy <- u$sy3
        component_list <- list(component1, component2, component3)
        OutPut$df <- Reduce(function(x, y) merge(x, y, by = "x", all = F, sort = T), component_list)[,c("x","y.x","y.y","y","sy.x","sy.y","sy")]
        names(OutPut$df) <- c("# Epoch", sub(" component","",info$components[1]), sub(" component","",info$components[2]), sub(" component","",info$components[3]), sub(" component","Sigma",info$components[1]), sub(" component","Sigma",info$components[2]), sub(" component","Sigma",info$components[3]))
      } else {
        component_list <- list(component1, component2, component3)
        OutPut$df <- Reduce(function(x, y) merge(x, y, by = "x", all = F, sort = T), component_list)
        names(OutPut$df) <- c("# Epoch", sub(" component","",info$components[1]), sub(" component","",info$components[2]), sub(" component","",info$components[3]))
      }
    } else if (input$tab == 5) {
      component1 <- data.frame(x = db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]]$status1 %in% T], y = db1[[info$db1]]$res1[db1[[info$db1]]$status1 %in% T])
      component2 <- data.frame(x = db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]]$status2 %in% T], y = db1[[info$db1]]$res2[db1[[info$db1]]$status2 %in% T])
      component3 <- data.frame(x = db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]]$status3 %in% T], y = db1[[info$db1]]$res3[db1[[info$db1]]$status3 %in% T])
      if (isTruthy(useSigmas)) {
        component1$sy <- u$sy1
        component2$sy <- u$sy2
        component3$sy <- u$sy3
        component_list <- list(component1, component2, component3)
        OutPut$df <- Reduce(function(x, y) merge(x, y, by = "x", all = F, sort = T), component_list)[,c("x","y.x","y.y","y","sy.x","sy.y","sy")]
        names(OutPut$df) <- c("# Epoch", sub(" component","Res",info$components[1]), sub(" component","Res",info$components[2]), sub(" component","Res",info$components[3]), sub(" component","Sigma",info$components[1]), sub(" component","Sigma",info$components[2]), sub(" component","Sigma",info$components[3]))
      } else {
        component_list <- list(component1, component2, component3)
        OutPut$df <- Reduce(function(x, y) merge(x, y, by = "x", all = F, sort = T), component_list)
        names(OutPut$df) <- c("# Epoch", sub(" component","Res",info$components[1]), sub(" component","Res",info$components[2]), sub(" component","Res",info$components[3]))
      }
    }
    req(OutPut$df)
    # Formatting input data columns
    # OutPut$df[,"# Epoch"] <- format(OutPut$df[,"# Epoch"], nsmall = info$decimalsx, trim = F, scientific = F)
    # OutPut$df[,"# Epoch"] <- format(as.numeric(sprintf("%.*f", info$decimalsx, OutPut$df[,"# Epoch"])), scientific = F)
    OutPut$df[,"# Epoch"] <- formatting(OutPut$df[,"# Epoch"],"x")
    if (input$tab < 4) {
      if (isTruthy(info$scientific)) {
        OutPut$df[,"Data"] <- formatting(OutPut$df[,"Data"],0)
        if (isTruthy(useSigmas)) {
          OutPut$df[,"Sigma"] <- formatting(OutPut$df[,"Sigma"],0)
        }
      } else {
        OutPut$df[,"Data"] <- format(as.numeric(sprintf("%.*f", info$decimalsy, OutPut$df[,"Data"])), scientific = F)
        if (isTruthy(useSigmas)) {
          OutPut$df[,"Sigma"] <- format(as.numeric(sprintf("%.*f", info$decimalsy, OutPut$df[,"Sigma"])), scientific = F)
        }
      }
    } else if (input$tab == 4 || input$tab == 5) {
      for (comp in seq(3)) {
        if (isTruthy(info$scientific)) {
          OutPut$df[,comp + 1] <- formatting(OutPut$df[,comp + 1],0)
          if (isTruthy(useSigmas)) {
            OutPut$df[,comp + 4] <- formatting(OutPut$df[,comp + 4],0)
          }
        } else {
          OutPut$df[,comp + 1] <- format(as.numeric(sprintf("%.*f", info$decimalsy, OutPut$df[,comp + 1])), scientific = F)
          if (isTruthy(useSigmas)) {
            OutPut$df[,comp + 4] <- format(as.numeric(sprintf("%.*f", info$decimalsy, OutPut$df[,comp + 4])), scientific = F)
          }
        }
      }
    }
    # Adding and formatting the fit/filter/noise columns for each component
    if (input$tab < 4) {
      if ((input$fitType == 1 || input$fitType == 2) && length(trans$res) > 0) {
        if (length(trans$pattern) > 0 && input$waveform && inputs$waveformPeriod > 0) {
          model <- trans$mod - trans$pattern
          residuals <- trans$res + trans$pattern
        } else {
          model <- trans$mod
          residuals <- trans$res
        }
        if (isTruthy(info$scientific)) {
          OutPut$df$Model <- formatting(model,0)
          OutPut$df$Residuals <- formatting(residuals,0)
        } else {
          OutPut$df$Model <- format(as.numeric(sprintf("%.*f", info$decimalsy, model)), scientific = F)
          OutPut$df$Residuals <- format(as.numeric(sprintf("%.*f", info$decimalsy, residuals)), scientific = F)
        }
      }
      if (useSigmas && input$fitType == 1 && length(input$model) > 0) {
        if (isTruthy(info$scientific)) {
          if (length(trans$moderror) > 0) {
            OutPut$df$Sigma.Model <- formatting(trans$moderror,0)
          }
          if (length(trans$reserror) > 0) {
            OutPut$df$Sigma.Residuals <- formatting(trans$reserror,0)
          }
        } else {
          if (length(trans$moderror) > 0) {
            OutPut$df$Sigma.Model <- format(as.numeric(sprintf("%.*f", info$decimalsy, trans$moderror)), scientific = F)
          }
          if (length(trans$reserror) > 0) {
            OutPut$df$Sigma.Residuals <- format(as.numeric(sprintf("%.*f", info$decimalsy, trans$reserror)), scientific = F)
          }
        }
      }
      if (input$filter == T && (inputs$low != "" || inputs$high != "") && length(trans$filter) > 0) {
        if (length(trans$pattern) > 0 && input$waveform && inputs$waveformPeriod > 0 && length(trans$filterRes) > 0 && input$series2filter == 1) {
          smooth <- trans$filter - trans$pattern
          smooth.residuals <- trans$filterRes + trans$pattern
        } else {
          smooth <- trans$filter
          smooth.residuals <- trans$filterRes
        }
        if (isTruthy(info$scientific)) {
          OutPut$df$Smooth <- formatting(smooth,0)
          OutPut$df$Smooth.Residuals <- formatting(smooth.residuals,0)
        } else {
          OutPut$df$smooth <- format(as.numeric(sprintf("%.*f", info$decimalsy, smooth)), scientific = F)
          OutPut$df$smooth.Residuals <- format(as.numeric(sprintf("%.*f", info$decimalsy, smooth.residuals)), scientific = F)
        }
      }
      if (input$wiener && input$mle) {
        if (input$white && length(trans$white) > 0) {
          if (isTruthy(info$scientific)) {
            OutPut$df$White <- formatting(trans$white,0)
            if (useSigmas && length(trans$white_sig) > 0) {
              OutPut$df$Sigma.White <- formatting(trans$white_sig,0)
            }
          } else {
            OutPut$df$White <- format(as.numeric(sprintf("%.*f", info$decimalsy, trans$white)), scientific = F)
            if (useSigmas && length(trans$white_sig) > 0) {
              OutPut$df$Sigma.White <- format(as.numeric(sprintf("%.*f", info$decimalsy, trans$white_sig)), scientific = F)
            }
          }
        }
        if (input$flicker && length(trans$flicker) > 0) {
          if (isTruthy(info$scientific)) {
            OutPut$df$Flicker <- formatting(trans$flicker,0)
            if (useSigmas && length(trans$flicker_sig) > 0) {
              OutPut$df$Sigma.Flicker <- formatting(trans$flicker_sig,0)
            }
          } else {
            OutPut$df$Flicker <- format(as.numeric(sprintf("%.*f", info$decimalsy, trans$flicker)), scientific = F)
            if (useSigmas && length(trans$flicker_sig) > 0) {
              OutPut$df$Sigma.Flicker <- format(as.numeric(sprintf("%.*f", info$decimalsy, trans$flicker_sig)), scientific = F)
            }
          }
        }
        if (input$randomw && length(trans$randomw) > 0) {
          if (isTruthy(info$scientific)) {
            OutPut$df$RandomWalk <- formatting(trans$randomw,0)
            if (useSigmas && length(trans$randomw_sig) > 0) {
              OutPut$df$Sigma.RandomWalk <- formatting(trans$randomw_sig,0)
            }
          } else {
            OutPut$df$RandomWalk <- format(as.numeric(sprintf("%.*f", info$decimalsy, trans$randomw)), scientific = F)
            if (useSigmas && length(trans$randomw_sig) > 0) {
              OutPut$df$Sigma.RandomWalk <- format(as.numeric(sprintf("%.*f", info$decimalsy, trans$randomw_sig)), scientific = F)
            }
          }
        }
        if (input$powerl && length(trans$powerl) > 0) {
          if (isTruthy(info$scientific)) {
            OutPut$df$PowerLaw <- formatting(trans$powerl,0)
            if (useSigmas && length(trans$powerl_sig) > 0) {
              OutPut$df$Sigma.PowerLaw <- formatting(trans$powerl_sig,0)
            }
          } else {
            OutPut$df$PowerLaw <- format(as.numeric(sprintf("%.*f", info$decimalsy, trans$powerl)), scientific = F)
            if (useSigmas && length(trans$powerl_sig) > 0) {
              OutPut$df$Sigma.PowerLaw <- format(as.numeric(sprintf("%.*f", info$decimalsy, trans$powerl_sig)), scientific = F)
            }
          }
        }
      }
      if (input$fitType == 2 && length(trans$res) > 0) {
        colnames(trans$kalman_unc) <- paste0("sigma.",colnames(trans$kalman_unc))
        if (isTruthy(info$scientific)) {
          OutPut$df <- cbind(OutPut$df,formatting(trans$kalman,0))
        } else {
          OutPut$df <- cbind(OutPut$df, format(apply(apply(trans$kalman, c(1, 2), sprintf, fmt = paste0("%.",info$decimalsy,"f")), c(1, 2), as.numeric), scientific = F))
        }
        # if (isTruthy(info$scientific)) {
          OutPut$df <- cbind(OutPut$df,formatting(trans$kalman_unc,0))
        # } else {
        #   OutPut$df <- cbind(OutPut$df, format(trans$kalman_unc, digits = 1, scientific = F))
        # }
      }
      if (length(trans$pattern) > 0 && input$waveform && inputs$waveformPeriod > 0) {
        if (isTruthy(info$scientific)) {
          OutPut$df$Waveform <- formatting(trans$pattern,0)
        } else {
          OutPut$df$Waveform <- format(as.numeric(sprintf("%.*f", info$decimalsy, trans$pattern)), scientific = F)
        }
      }
    }
    # Adding excluded points
    if (isTruthy(input$add_excluded)) {
      if (input$tab < 4) {
        excluded <- !(db1[[info$db1]][[paste0("status",input$tab)]] %in% T)
        names(excluded) <- NULL
        if (isTruthy(useSigmas)) {
          output_excluded$df <- data.frame(x = trans$x0[excluded], y = trans$y0[excluded], sy = trans$sy0[excluded])
          names(output_excluded$df) <- c("# Epoch", "Data", "Sigma")
          if (isTruthy(info$scientific)) {
            output_excluded$df[,"Sigma"] <- formatting(output_excluded$df[,"Sigma"],0)
          } else {
            output_excluded$df[,"Sigma"] <- format(as.numeric(sprintf("%.*f", info$decimalsy, output_excluded$df[,"Sigma"])), scientific = F)
          }
        } else {
          output_excluded$df <- data.frame(x = trans$x0[excluded], y = trans$y0[excluded])
          names(output_excluded$df) <- c("# Epoch", "Data")
        }
        if (isTruthy(info$scientific)) {
          output_excluded$df[,"# Epoch"] <- formatting(output_excluded$df[,"# Epoch"],0)
          output_excluded$df[,"Data"] <- formatting(output_excluded$df[,"Data"],0)
        } else {
          output_excluded$df[,"# Epoch"] <- format(as.numeric(sprintf("%.*f", info$decimalsy, output_excluded$df[,"# Epoch"])), scientific = F)
          output_excluded$df[,"Data"] <- format(as.numeric(sprintf("%.*f", info$decimalsy, output_excluded$df[,"Data"])), scientific = F)
        }
        if (isTruthy(useSigmas)) {
          OutPut$df <- merge(OutPut$df,output_excluded$df,by = c("# Epoch", "Data", "Sigma"), all = T)
        } else {
          OutPut$df <- merge(OutPut$df,output_excluded$df,by = c("# Epoch", "Data"), all = T)
        }
      } else {
        excluded <- apply(db1[[info$db1]][, c("status1", "status2", "status3")], 1, function(row) all(row == F) || all(is.na(row)))
        names(excluded) <- NULL
        if (isTruthy(trans$plate)) {
          centerx <- median(db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]]$status1], na.rm = T)
          centery <- median(db1[[info$db1]]$y1, na.rm = T)
          if (isTruthy(info$scientific)) {
            component1 <- data.frame(x = formatting(db1[[info$db1]][[paste0("x",input$tunits)]][excluded],0), y = formatting(db1[[info$db1]]$y1[excluded] - trans$plate[1]*(db1[[info$db1]][[paste0("x",input$tunits)]][excluded] - centerx) - centery,0))
          } else {
            component1 <- data.frame(x = format(as.numeric(sprintf("%.*f", info$decimalsx, db1[[info$db1]][[paste0("x",input$tunits)]][excluded])), scientific = F),
                                     y = format(as.numeric(sprintf("%.*f", info$decimalsy, db1[[info$db1]]$y1[excluded] - trans$plate[1]*(db1[[info$db1]][[paste0("x",input$tunits)]][excluded] - centerx) - centery)), scientific = F))
          }
          centerx <- median(db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]]$status2], na.rm = T)
          centery <- median(db1[[info$db1]]$y2, na.rm = T)
          if (isTruthy(info$scientific)) {
            component2 <- data.frame(x = formatting(db1[[info$db1]][[paste0("x",input$tunits)]][excluded],0), y = formatting(db1[[info$db1]]$y2[excluded] - trans$plate[2]*(db1[[info$db1]][[paste0("x",input$tunits)]][excluded] - centerx) - centery,0))
          } else {
            component2 <- data.frame(x = format(as.numeric(sprintf("%.*f", info$decimalsx, db1[[info$db1]][[paste0("x",input$tunits)]][excluded])), scientific = F),
                                     y = format(as.numeric(sprintf("%.*f", info$decimalsy, db1[[info$db1]]$y2[excluded] - trans$plate[2]*(db1[[info$db1]][[paste0("x",input$tunits)]][excluded] - centerx) - centery)), scientific = F))
          }
        } else {
          if (isTruthy(info$scientific)) {
            component1 <- data.frame(x = formatting(db1[[info$db1]][[paste0("x",input$tunits)]][excluded],0), y = formatting(db1[[info$db1]]$y1[excluded],0))
            component2 <- data.frame(x = formatting(db1[[info$db1]][[paste0("x",input$tunits)]][excluded],0), y = formatting(db1[[info$db1]]$y2[excluded],0))
          } else {
            component1 <- data.frame(x = format(as.numeric(sprintf("%.*f", info$decimalsx, db1[[info$db1]][[paste0("x",input$tunits)]][excluded])), scientific = F),
                                     y = format(as.numeric(sprintf("%.*f", info$decimalsy, db1[[info$db1]]$y1[excluded])), scientific = F))
            component2 <- data.frame(x = format(as.numeric(sprintf("%.*f", info$decimalsx, db1[[info$db1]][[paste0("x",input$tunits)]][excluded])), scientific = F),
                                     y = format(as.numeric(sprintf("%.*f", info$decimalsy, db1[[info$db1]]$y2[excluded])), scientific = F))
          }
        }
        if (isTruthy(trans$gia)) {
          centerx <- median(db1[[info$db1]][[paste0("x",input$tunits)]][db1[[info$db1]]$status3], na.rm = T)
          centery <- median(db1[[info$db1]]$y3, na.rm = T)
          if (isTruthy(info$scientific)) {
            component3 <- data.frame(x = formatting(db1[[info$db1]][[paste0("x",input$tunits)]][excluded],0), y = formatting(db1[[info$db1]]$y3[excluded] - trans$gia[3]*(db1[[info$db1]][[paste0("x",input$tunits)]][excluded] - centerx) - centery,0))
          } else {
            component3 <- data.frame(x = format(as.numeric(sprintf("%.*f", info$decimalsx, db1[[info$db1]][[paste0("x",input$tunits)]][excluded])), scientific = F),
                                     y = format(as.numeric(sprintf("%.*f", info$decimalsy, db1[[info$db1]]$y3[excluded] - trans$gia[3]*(db1[[info$db1]][[paste0("x",input$tunits)]][excluded] - centerx) - centery)), scientific = F))
          }
        } else {
          if (isTruthy(info$scientific)) {
            component3 <- data.frame(x = formatting(db1[[info$db1]][[paste0("x",input$tunits)]][excluded],0), y = formatting(db1[[info$db1]]$y3[excluded],0))
          } else {
            component3 <- data.frame(x = format(as.numeric(sprintf("%.*f", info$decimalsx, db1[[info$db1]][[paste0("x",input$tunits)]][excluded])), scientific = F),
                                     y = format(as.numeric(sprintf("%.*f", info$decimalsy, db1[[info$db1]]$y3[excluded])), scientific = F))
          }
        }
        if (isTruthy(useSigmas)) {
          if (isTruthy(info$scientific)) {
            component1$sy <- formatting(db1[[info$db1]]$sy1[excluded],0)
            component2$sy <- formatting(db1[[info$db1]]$sy2[excluded],0)
            component3$sy <- formatting(db1[[info$db1]]$sy3[excluded],0)
          } else {
            component1$sy <- format(as.numeric(sprintf("%.*f", info$decimalsy, db1[[info$db1]]$sy1[excluded])), scientific = F)
            component2$sy <- format(as.numeric(sprintf("%.*f", info$decimalsy, db1[[info$db1]]$sy2[excluded])), scientific = F)
            component3$sy <- format(as.numeric(sprintf("%.*f", info$decimalsy, db1[[info$db1]]$sy3[excluded])), scientific = F)
          }
        }
        component_list <- list(component1, component2, component3)
        if (isTruthy(useSigmas)) {
          output_excluded$df <- Reduce(function(x, y) merge(x, y, by = "x", all = F, sort = T), component_list)[,c("x","y.x","y.y","y","sy.x","sy.y","sy")]
        } else {
          output_excluded$df <- Reduce(function(x, y) merge(x, y, by = "x", all = F, sort = T), component_list)[,c("x","y.x","y.y","y")]
        }
        if (input$tab == 5) {
          names(output_excluded$df)[1] <- "# Epoch"
          if (isTruthy(input$sigmas)) {
            OutPut$df <- merge(OutPut$df, output_excluded$df, by = c("# Epoch"), all = T)[,c("# Epoch", "EastRes", "NorthRes", "UpRes", "EastSigma", "NorthSigma", "UpSigma")]
          } else {
            OutPut$df <- merge(OutPut$df, output_excluded$df, by = c("# Epoch"), all = T)[,c("# Epoch", "EastRes", "NorthRes", "UpRes")]
          }
        } else {
          if (isTruthy(input$sigmas)) {
            names(output_excluded$df) <- c("# Epoch", sub(" component","",info$components[1]), sub(" component","",info$components[2]), sub(" component","",info$components[3]), sub(" component","Sigma",info$components[1]), sub(" component","Sigma",info$components[2]), sub(" component","Sigma",info$components[3]))
            OutPut$df <- merge(OutPut$df,output_excluded$df,by = c("# Epoch", "East", "North", "Up", "EastSigma", "NorthSigma", "UpSigma"), all = T)
          } else {
            names(output_excluded$df) <- c("# Epoch", sub(" component","",info$components[1]), sub(" component","",info$components[2]), sub(" component","",info$components[3]))
            OutPut$df <- merge(OutPut$df,output_excluded$df,by = c("# Epoch", "East", "North", "Up"), all = T)
          }
        }
      }
      for (i in which(excluded)) {
        OutPut$df[i,"# Epoch"] <- paste0("#",OutPut$df[i,"# Epoch"])
      }
    }
    # Formatting the final file
    colnames(OutPut$df) <- sapply(1:length(colnames(OutPut$df)), function(x) paste(colnames(OutPut$df)[x],"[",x,"]", sep = ""))
    suppressWarnings(write.table(OutPut$df,file_out,append = T,quote = F,sep = " ",eol = "\n",na = "NA",dec = ".",row.names = F,col.names = T))
    shinyjs::delay(2000, removeNotification(id = id, session = getDefaultReactiveDomain()))
  }
  #
  collect_periodogram <- function(file_out) {
    removeNotification("bad_output")
    if (messages > 0) cat(file = stderr(), mySession, "Downloading periodogram", "\n")
    now <- paste0(" run on ",Sys.time()," ",Sys.timezone())
    cat(paste0("# ",version,now), file = file_out, sep = "\n", fill = F, append = F)
    cat(paste0("# Original series: ",file$primary$name), file = file_out, sep = "\n", fill = F, append = T)
    if (input$format != 4) {
      cat(paste0("# Coordinate component: ", info$components[as.numeric(input$tab)]), file = file_out, sep = "\n", fill = F, append = T)
    } else {
      if (isTruthy(input$sigmas)) {
        cat(paste0("# Column numbers for data and errorbars: ",inputs$variable," ",inputs$errorBar), file = file_out, sep = "\n", fill = F, append = T)
      } else {
        cat(paste0("# Column number for data: ",inputs$variable), file = file_out, sep = "\n", fill = F, append = T)
      }
    }
    if (input$tunits == 1) {
      period <- "days"
    } else if (input$tunits == 2) {
      period <- "weeks"
    } else if (input$tunits == 3) {
      period <- "years"
    }
    if (input$sunits == 1) {
      units <- "(m)"
    } else if (input$sunits == 2) {
      units <- "(mm)"
    } else {
      units <- ""
    }
    if (input$spectrumType == 0) {
      cat(paste("# Amplitude spectrum", units), file = file_out, sep = "\n", fill = F, append = T)
    } else if (input$spectrumType == 1) {
      cat("# Power spectrum", file = file_out, sep = "\n", fill = F, append = T)
    }
    cat(paste("# Longest period  =",inputs$long_period, period), file = file_out, sep = "\n", fill = F, append = T)
    cat(paste("# Shortest period =",inputs$short_period, period), file = file_out, sep = "\n", fill = F, append = T)
    cat(paste("# Oversampling =",inputs$ofac), file = file_out, sep = "\n", fill = F, append = T)
    OutPut$df <- as.data.frame(trans$spectra)
    if (isTruthy(OutPut$df) && ncol(OutPut$df) > 1) {
      names(OutPut$df)[1] <- "# period"
      column <- 2
      if (input$spectrumOriginal) {
        names(OutPut$df)[column] <- "original"
        column <- column + 1
      }
      if (input$spectrumModel && isolate(length(trans$mod) > 0) && isolate(length(trans$res) > 0)) {
        names(OutPut$df)[column] <- "model"
        column <- column + 1
      }
      if (input$spectrumResiduals && length(trans$res) > 0) {
        names(OutPut$df)[column] <- "modelResiduals"
        column <- column + 1
      }
      if (input$spectrumFilter && isolate(length(trans$filter) > 0)) {
        names(OutPut$df)[column] <- "filter"
        column <- column + 1
      }
      if (input$spectrumFilterRes && length(trans$filterRes) > 0) {
        names(OutPut$df)[column] <- "filterResiduals"
        column <- column + 1
      }
      colnames(OutPut$df) <- sapply(1:length(colnames(OutPut$df)), function(x) paste(colnames(OutPut$df)[x],"[",x,"]", sep = ""))
      suppressWarnings(write.table(format(OutPut$df, digits = 6, nsmall = 6, trim = F, scientific = F),file_out,append = T,quote = F,sep = "  ",eol = "\n",na = "NA",dec = ".",row.names = F,col.names = T))
    } else {
      showNotification("Problem when writing the periodogram data to a file.", action = NULL, duration = 10, closeButton = T, id = "bad_output", type = "error", session = getDefaultReactiveDomain())
    }
  }
  #Based on www.datall-analyse.nl/R/UKF.R
  UKF <- function(y, mod, GGfunction, FFfunction, kappa=0, sqrtMethod="Cholesky", logLik=FALSE, simplify=FALSE) {
    mod1 <- mod
    y <- as.matrix(y)
    ym <- ncol(y)
    yAttr <- attributes(y)
    p <- length(mod$m0)

    if (!is.null(mod$FF) | !is.null(mod$GG))
      warning("FF or GG matrix will not be used in the UKF")

    if (!is.null(mod$JFF) | !is.null(mod$JGG))
      warning("Time varying FF or GG matrix will not be used in the UKF")

    if (!is.null(mod$JW) | !is.null(mod$JV))
      warning("Time varying V or W matrix will not be used in the UKF")

    if (!(sqrtMethod == "Cholesky" | sqrtMethod == "svd"))
      stop("Name of sqrtMethod is incorrect")

    m <- rbind(mod$m0, matrix(0, nrow = nrow(y), ncol = length(mod$m0))) # a posteriori estimated state
    a <- matrix(0, nrow = nrow(y), ncol = length(mod$m0)) # a priori state in time update
    f <- matrix(0, nrow = nrow(y), ncol = ncol(y)) # predicted measurement from a priori state
    C <- vector(1 + nrow(y), mode = "list") # a posteriori state covariance
    R <- vector(nrow(y), mode = "list") # a priori state covariance in time update
    ll <- 0 # log-likelihood
    w <- as.vector(c(kappa/(p + kappa), rep(1/(2*(p + kappa)), 2*p))) # weights of sigma points

    C[[1]] <- mod$C0

    for (i in seq(length = nrow(y))) {

      setProgress(round(i/info$points, digits = 1))

      ##time update

      ## Increase the process noise by a factor depending on the number of missing observations from the last one
      ## This is approximate for series that are irregularly sampled (excluding gaps)
      gapFactor <- 1
      if (i > 1) {
        gapFactor <- round((trans$x[i] - trans$x[i - 1]) / info$sampling, digits = 1)
      }
      #compute sigma points
      if (sqrtMethod == "Cholesky") {
        sigmaPlus <- t(chol((p + kappa)*C[[i]]))
      } else {
        tmpxs <- La.svd((p + kappa)*C[[i]], nu = 0)
        sigmaPlus <- t(sqrt(tmpxs$d)*tmpxs$vt)}
      sigmax <- t(m[i, ] + cbind(0, sigmaPlus, -sigmaPlus))
      #a priori state estimate
      tmpx <- matrix(sapply(1:nrow(sigmax), function(x) GGfunction(x = sigmax[x,], k = i)), nrow = p)
      a[i, ] <- tcrossprod(w, tmpx)
      #a priori error covariance
      # R[[i]] <- tcrossprod(crossprod(t(tmpx - a[i, ]), diag(w)), tmpx - a[i, ]) + mod$W
      R[[i]] <- tcrossprod(crossprod(t(tmpx - a[i, ]), diag(w)), tmpx - a[i, ]) + mod$W * gapFactor

      ##measurement update

      #compute sigma points
      if (sqrtMethod == "Cholesky") {
        sigmaPlus <- t(chol((p + kappa)*R[[i]]))}
      else {
        tmpys <- La.svd((p + kappa)*R[[i]], nu = 0)
        sigmaPlus <- t(sqrt(tmpys$d)*tmpys$vt)
      }
      sigmay <- t(a[i, ] + cbind(0, sigmaPlus, -sigmaPlus))
      taulog <- which(grepl("TauL", trans$KFnames))
      if (any(sigmay[,taulog] <= 0)) {
        showNotification(HTML("Negative values in some sigma points of the logarithmic decay rate.<br>The logarithmic decay must always be positive."), action = NULL, duration = 10, closeButton = T, id = "bad_sigmaPoints", type = "error", session = getDefaultReactiveDomain())
      }
      #predicted measurement
      tmpy <- matrix(sapply(1:nrow(sigmay), function(x) FFfunction(x = sigmay[x,], k = i)), nrow = ym)
      f[i, ] <- tcrossprod(w, tmpy)
      #covariance of predicted measurement
      # Qy <- tcrossprod(crossprod(t(tmpy - f[i, ]), diag(w)), tmpy - f[i, ]) + mod$V
      if (!isTruthy(mod$V[i])) {
        mod$V[i] <- mod$V[1] # ugly but necessary for running the measurement noise optimization only
      }
      Qy <- tcrossprod(crossprod(t(tmpy - f[i, ]), diag(w)), tmpy - f[i, ]) + mod$V[i]
      #cross covariance between a priori state estimate and predicted measurement
      Qxy <- tcrossprod(crossprod(t(t(sigmay) - a[i, ]), diag(w)), tmpy - f[i, ])

      ##a posteriori estimates

      #Kalman gain
      Kk <- crossprod(t(Qxy), solve(Qy, tol = 1e-30))
      #a posteriori state estimate
      m[i + 1, ] <- a[i, ] + crossprod(t(Kk), as.matrix(y[i, ] - f[i, ]))
      #a posteriori error covariance
      C[[i + 1]] <- R[[i]] - crossprod(t(Kk), tcrossprod(Qy, Kk))

      #compute log-likelihood
      if (logLik) {
        e <- as.matrix(y[i, ] - f[i,])
        ll <- ll + ym*log(2*pi) + sum(log(eigen(Qy)$values)) + crossprod(e, tcrossprod(solve(Qy, tol = 1e-30), t(e)))}
    }
    ans <- list(m = m, C = C, a = a, R = R, f = f)

    attributes(ans$f) <- yAttr

    if (logLik)
      ans <- c(ans, logLik = 0.5*ll)

    if (simplify)
      ans <- c(mod = list(mod1), kappa = list(kappa), GGfunction = list(GGfunction), FFfunction = list(FFfunction), sqrtMethod = list(sqrtMethod), ans)
    else {
      attributes(y) <- yAttr
      ans <- c(y = list(y), mod = list(mod1), kappa = list(kappa), GGfunction = list(GGfunction), FFfunction = list(FFfunction), sqrtMethod = list(sqrtMethod), ans)
    }
    return(ans)
  }
  #
  UKFsmooth <- function(filterData, GGfunction) {

    mod <- filterData
    mAttr <- attributes(mod$m)
    mod$m <- as.matrix(mod$m)
    mod$a <- as.matrix(mod$a)
    mod$W <- as.matrix(mod$mod$W)
    kappa <- mod$kappa
    sqrtMethod <- mod$sqrtMethod

    n <- length(mod$R)
    p <- ncol(mod$m)
    w <- as.vector(c(kappa/(p + kappa), rep(1/(2*(p + kappa)), 2*p)))
    s <- rbind(matrix(0, n, p), mod$m[n + 1, ])
    S <- vector("list", length = n + 1)

    S[[n + 1]] <- mod$C[[n + 1]]

    if (n > 0)
      for (i in n:1) {

        # setProgress(0.5*i/info$points + 0.5)

        #compute sigma points
        if (sqrtMethod == "Cholesky") {
          sigmaPlus <- t(chol((p + kappa)*mod$C[[i]]))}
        else {
          tmpxs <- La.svd((p + kappa)*mod$C[[i]], nu = 0)
          sigmaPlus <- t(sqrt(tmpxs$d)*tmpxs$vt)}
        sigmax <- t(mod$m[i, ] + cbind(0, sigmaPlus, -sigmaPlus))
        tmpx <- matrix(sapply(1:nrow(sigmax), function(x) GGfunction(x = sigmax[x,], k = i)), nrow = p)

        #cross covariance between a priori state estimate (at k+1) and posterior state estimate (at k)
        Qxy <- tcrossprod(crossprod(t(t(sigmax) - mod$m[i, ]), diag(w)), tmpx - mod$a[i, ])

        #smoother Kalman gain
        Kk <- crossprod(t(Qxy), solve(mod$R[[i]], tol = 1e-30))
        #smoothed state estimate
        s[i, ] <- mod$m[i, ] + crossprod(t(Kk), s[i + 1, ] - mod$a[i,])
        #smoothed error covariance
        S[[i]] <- mod$C[[i]] + tcrossprod(crossprod(t(Kk), S[[i + 1]] - mod$R[[i]]), Kk)

      }
    ans <- list(s = s, S = S)

    attributes(ans$s) <- mAttr
    return(ans)
  }
  #Based on http://www.datall-analyse.nl/EKF.R
  dlmExtFilter <- function(y, mod, GGfunction, FFfunction,
                            GGjacobian=NULL, FFjacobian=NULL,
                            logLik=FALSE, simplify=FALSE) {

    eps <- .Machine$double.eps^0.3
    mod1 <- mod
    y <- as.matrix(y)
    ym <- ncol(y)
    yAttr <- attributes(y)
    p <- length(mod$m0)

    if (!is.null(mod$FF) | !is.null(mod$GG))
      warning("FF or GG matrix will not be used in the EKF")

    if (!is.null(mod$JFF) | !is.null(mod$JGG))
      warning("Time varying FF or GG matrix will not be used in the EKF")

    if (!is.null(mod$JW) | !is.null(mod$JV))
      warning("Time varying V or W matrix will not be used in the EKF")

    m <- rbind(mod$m0, matrix(0, nrow = nrow(y), ncol = length(mod$m0)))
    a <- matrix(0, nrow = nrow(y), ncol = length(mod$m0))
    f <- matrix(0, nrow = nrow(y), ncol = ncol(y))
    dGG.dx <- vector(nrow(y), mode = "list")
    dFF.dx <- vector(nrow(y), mode = "list")
    U.C <- vector(1 + nrow(y), mode = "list")
    D.C <- matrix(0, 1 + nrow(y), length(mod$m0))
    U.R <- vector(nrow(y), mode = "list")
    D.R <- matrix(0, nrow(y), length(mod$m0))
    ll <- 0

    # this code is now run below for each observation
    # svdV <- La.svd(mod$V, nu = 0)
    # Uv <- t(svdV$vt)
    # Dv <- sqrt(svdV$d)
    # if (any(Dv < eps)) {
    #   Dv <- pmax(Dv, eps)
    #   warning("a numerically singular 'V' has been slightly perturbed to make it nonsingular")
    # }
    # Dv.inv <- 1/Dv
    # Dv.inv[abs(Dv.inv) == Inf] <- 0
    # sqrtVinv <- Dv.inv * svdV$vt

    # svdW <- La.svd(mod$W, nu = 0)
    # sqrtW <- sqrt(svdW$d) * svdW$vt

    tmp <- La.svd(mod$C0, nu = 0)
    U.C[[1]] <- t(tmp$vt)
    D.C[1, ] <- sqrt(tmp$d)

    for (i in seq(length = nrow(y))) {

      setProgress(round(i/info$points, digits = 1))

      ## Increase the process noise by a factor depending on the number of missing observations from the last one
      ## This implies the series must be sampled regularly with data gaps
      if (!isTruthy(mod$V[i])) {
        mod$V[i] <- mod$V[1] # ugly but necessary for running the measurement noise optimization only
      }
      svdV <- La.svd(mod$V[i], nu = 0)
      Uv <- t(svdV$vt)
      Dv <- sqrt(svdV$d)
      if (any(Dv < eps)) {
        Dv <- pmax(Dv, eps)
        warning("a numerically singular 'V' has been slightly perturbed to make it nonsingular")
      }
      Dv.inv <- 1/Dv
      Dv.inv[abs(Dv.inv) == Inf] <- 0
      sqrtVinv <- Dv.inv * svdV$vt
      gapFactor <- 1
      if (i > 1) {
        gapFactor <- round((trans$x[i] - trans$x[i - 1]) / info$sampling, digits = 1)
      }
      svdW <- La.svd(mod$W * gapFactor, nu = 0)
      sqrtW <- sqrt(svdW$d) * svdW$vt

      if (is.null(GGjacobian)) {
        dGG.dx[[i]] <- jacobian(GGfunction, x = m[i,], k = i)
      } else {
        dGG.dx[[i]] <- matrix(GGjacobian(x = m[i,], k = i), ncol = p, byrow = T)
      }

      if (!any(whereNA <- is.na(y[i, ]))) {

        a[i, ] <- GGfunction(x = m[i, ], k = i)
        if (is.null(FFjacobian)) {
          dFF.dx[[i]] <- jacobian(FFfunction, x = a[i,], k = i)
        } else {
          dFF.dx[[i]] <- matrix(FFjacobian(x = a[i,], k = i), ncol = p, byrow = T)
        }
        tmp <- La.svd(rbind(D.C[i, ] * t(dGG.dx[[i]] %*% U.C[[i]]), sqrtW), nu = 0)
        U.R[[i]] <- t(tmp$vt)
        D.R[i, ] <- tmp$d
        f[i, ] <- FFfunction(x = a[i, ], k = i)
        D.Rinv <- 1/D.R[i, ]
        D.Rinv[abs(D.Rinv) == Inf] <- 0
        tmp <- La.svd(rbind(sqrtVinv %*% dFF.dx[[i]] %*% U.R[[i]], diag(x = D.Rinv, nrow = length(D.Rinv))), nu = 0)
        U.C[[i + 1]] <- U.R[[i]] %*% t(tmp$vt)
        foo <- 1/tmp$d
        foo[abs(foo) == Inf] <- 0
        D.C[i + 1, ] <- foo
        tF.Vinv <- t(dFF.dx[[i]]) %*% crossprod(sqrtVinv)
        m[i + 1, ] <- a[i, ] + crossprod(D.C[i + 1, ] * t(U.C[[i + 1]])) %*% tF.Vinv %*% as.matrix(y[i, ] - f[i, ])
        if (logLik) {
          e <- as.matrix(y[i, ] - f[i,])
          Rt <- tcrossprod(rep(D.R[i, ], each = p) * U.R[[i]])
          # Qt <- mod$V + dFF.dx[[i]] %*% Rt %*% t(dFF.dx[[i]])
          Qt <- mod$V[i] + dFF.dx[[i]] %*% Rt %*% t(dFF.dx[[i]])
          ll <- ll + ym*log(2*pi) + sum(log(eigen(Qt)$values)) + crossprod(e, solve(Qt)) %*% e
        }
      }
      else {
        if (all(whereNA)) {
          m[i + 1, ] <- a[i, ] <- GGfunction(x = m[i, ], k = i)
          tmp <- La.svd(rbind(D.C[i, ] * t(dGG.dx[[i]] %*% U.C[[i]]), sqrtW), nu = 0)
          U.C[[i + 1]] <- U.R[[i]] <- t(tmp$vt)
          D.C[i + 1, ] <- D.R[i, ] <- tmp$d
          if (is.null(FFjacobian)) dFF.dx[[i]] <- jacobian(FFfunction, x = a[i,], k = i)
          else dFF.dx[[i]] <- matrix(FFjacobian(x = a[i,], k = i), ncol = p, byrow = T)
          f[i, ] <- FFfunction(x = a[i, ], k = i)
        }

        else {
          good <- !whereNA

          a[i, ] <- GGfunction(x = m[i, ], k = i)
          tmp <- La.svd(rbind(D.C[i, ] * t(dGG.dx[[i]] %*% U.C[[i]]), sqrtW), nu = 0)
          U.R[[i]] <- t(tmp$vt)
          D.R[i, ] <- tmp$d
          if (is.null(FFjacobian)) dFF.dx[[i]] <- jacobian(FFfunction, x = a[i,], k = i)
          else dFF.dx[[i]] <- matrix(FFjacobian(x = a[i,], k = i), ncol = p, byrow = T)
          f[i, ] <- FFfunction(x = a[i, ], k = i)
          tmp <- La.svd(mod$V[good, good], nu = 0)
          Dv <- sqrt(tmp$d)
          Dv.inv <- 1/Dv
          Dv.inv[abs(Dv.inv) == Inf] <- 0
          sqrtVinvTMP <- Dv.inv * tmp$vt
          tF.VinvTMP <- t(dFF.dx[[i]][good, , drop = FALSE]) %*% crossprod(sqrtVinvTMP)
          D.Rinv <- 1/D.R[i, ]
          D.Rinv[abs(D.Rinv) == Inf] <- 0
          tmp <- La.svd(rbind(sqrtVinvTMP %*% dFF.dx[[i]][good, , drop = FALSE] %*% U.R[[i]], diag(x = D.Rinv, nrow = length(D.Rinv))), nu = 0)
          U.C[[i + 1]] <- U.R[[i]] %*% t(tmp$vt)
          foo <- 1/tmp$d
          foo[abs(foo) == Inf] <- 0
          D.C[i + 1, ] <- foo
          m[i + 1, ] <- a[i, ] + crossprod(D.C[i + 1, ] * t(U.C[[i + 1]])) %*% tF.VinvTMP %*% as.matrix(y[i, good] - f[i, good])
          if (logLik) {
            e <- as.matrix(y[i, good] - f[i, good])
            Rt <- tcrossprod(rep(D.R[i, ], each = p) * U.R[[i]])
            Qt <- (mod$V[i] + dFF.dx[[i]] %*% Rt %*% t(dFF.dx[[i]]))[good, good]
            ll <- ll + sum(good)*log(2*pi) + sum(log(eigen(Qt)$values)) + crossprod(e, solve(Qt)) %*% e
          }
        }
      }
    }
    ans <- list(m = m, U.C = U.C, D.C = D.C, a = a, U.R = U.R, D.R = D.R, f = f , dGG.dx = dGG.dx, dFF.dx = dFF.dx)

    attributes(ans$f) <- yAttr

    if (logLik)
      ans <- c(ans, logLik = 0.5*ll)

    if (simplify)
      ans <- c(mod = list(mod1), GGfunction = list(GGfunction), FFfunction = list(FFfunction), GGjacobian = list(GGjacobian), FFjacobian = list(FFjacobian), ans)
    else {
      attributes(y) <- yAttr
      ans <- c(y = list(y), mod = list(mod1), GGfunction = list(GGfunction), FFfunction = list(FFfunction), GGjacobian = list(GGjacobian), FFjacobian = list(FFjacobian), ans)
    }
    class(ans) <- "dlmFiltered"
    return(ans)
  }
  #
  dlmExtSmooth <- function(filterData) {

    big <- 1/sqrt(.Machine$double.eps)
    mod <- filterData
    mAttr <- attributes(mod$m)
    mod$m <- as.matrix(mod$m)
    mod$a <- as.matrix(mod$a)
    mod$W <- as.matrix(mod$mod$W)

    n <- length(mod$U.R)
    p <- NCOL(mod$m)
    s <- rbind(matrix(0, n, p), mod$m[n + 1, ])
    U.S <- vector("list", length = n + 1)
    U.S[[n + 1]] <- mod$U.C[[n + 1]]
    D.S <- rbind(matrix(0, n, p), mod$D.C[n + 1, ])

    # this code is now run below for each observation
    # svdW <- La.svd(mod$W, nu = 0)
    # Dw <- sqrt(svdW$d)
    # Dw.inv <- pmin(1/Dw, big)
    # sqrtWinv <- Dw.inv * svdW$vt

    if (n > 0)
      for (i in n:1) {

        gapFactor <- 1
        if (i > 1) {
          gapFactor <- round((trans$x[i] - trans$x[i - 1]) / info$sampling, digits = 1)
        }
        svdW <- La.svd(mod$W * gapFactor, nu = 0)
        Dw <- sqrt(svdW$d)
        Dw.inv <- pmin(1/Dw, big)
        sqrtWinv <- Dw.inv * svdW$vt

        Dinv <- 1/mod$D.R[i, ]
        Dinv[abs(Dinv) == Inf] <- 0
        H <- crossprod(mod$D.C[i, ] * t(mod$U.C[[i]])) %*% t(mod$dGG.dx[[i]]) %*% crossprod(Dinv * t(mod$U.R[[i]]))
        Dinv <- 1/mod$D.C[i, ]
        Dinv[abs(Dinv) == Inf] <- 0
        tmp <- La.svd(rbind(sqrtWinv %*% mod$dGG.dx[[i]], Dinv * t(mod$U.C[[i]])), nu = 0)
        Dinv <- 1/tmp$d
        Dinv[abs(Dinv) == Inf] <- 0
        tmp <- La.svd(rbind(Dinv * tmp$vt, D.S[i + 1, ] * t(H %*% U.S[[i + 1]])))
        U.S[[i]] <- t(tmp$vt)
        D.S[i, ] <- tmp$d
        s[i, ] <- mod$m[i, ] + H %*% (s[i + 1, ] - mod$a[i, ])
      }
    ans <- list(s = s, U.S = U.S, D.S = D.S)

    attributes(ans$s) <- mAttr
    return(ans)
  }
  # Based on https://github.com/daattali/advanced-shiny/blob/master/busy-indicator/helpers.R
  withBusyIndicatorServer <- function(buttonId, expr) {
    loadingEl <- sprintf("[data-for-btn=%s] .btn-loading-indicator", buttonId)
    doneEl <- sprintf("[data-for-btn=%s] .btn-done-indicator", buttonId)
    errEl <- sprintf("[data-for-btn=%s] .btn-err", buttonId)
    shinyjs::disable(buttonId)
    shinyjs::show(selector = loadingEl)
    shinyjs::hide(selector = doneEl)
    shinyjs::hide(selector = errEl)
    on.exit({
      shinyjs::enable(buttonId)
      shinyjs::hide(selector = loadingEl)
    })
    tryCatch({
      value <- expr
      shinyjs::show(selector = doneEl)
      shinyjs::delay(4000, shinyjs::hide(selector = doneEl, anim = TRUE, animType = "fade", time = 5))
      value
    })
  }
  #
  midas_vel <- function(m,t,disc,x,y) {
    setProgress(round(m/info$points, digits = 1))
    vel_f <- -999999
    vel_b <- -999999
    index_f <- which.min(abs(x - (x[m] + t)))
    index_b <- which.min(abs(x - (x[m] - t)))
    # checking forward pair
    if (abs(x[index_f] - x[m] - t) < info$tol) {
      if (disc == 1) {
        if (length(trans$offsetEpochs > 0)) {
          if (!any(x[m] < as.numeric(trans$offsetEpochs) & x[index_f] > as.numeric(trans$offsetEpochs))) {
            vel_f <- (y[index_f] - y[m]) / (x[index_f] - x[m])
          }
        }
      } else {
        vel_f <- (y[index_f] - y[m]) / (x[index_f] - x[m])
      }
    }
    # checking backward pair
    if (abs(x[m] - x[index_b] - t) < info$tol) {
      if (disc == 1) {
        if (length(trans$offsetEpochs > 0)) {
          if (!any(x[index_b] < as.numeric(trans$offsetEpochs) & x[m] > as.numeric(trans$offsetEpochs))) {
            vel_b <- (y[m] - y[index_b]) / (x[m] - x[index_b])
          }
        }
      } else {
        vel_b <- (y[m] - y[index_b]) / (x[m] - x[index_b])
      }
    }
    return(c(vel_f,vel_b))
  }
  #Based on https://stackoverflow.com/questions/5173692/how-to-return-number-of-decimal-places-in-r
  decimalplaces <- function(x,extra) {
    if (all(is.numeric(x))) {
      info$scientific <- F
      frac <- abs(x - as.integer(x))
      if (all(frac == 0)) {
        return(extra)
      }
      frac <- frac[frac != 0]
      fracEnt <- sub("[0-9]*\\.", "", format(frac, scientific = F))
      decimals1 <- min(nchar(fracEnt))
      incr <- abs(as.numeric(sprintf("%.*f", decimals1, diff(sort(frac)))))
      incr <- incr[incr != 0]
      if (isTruthy(incr)) {
        min_incr <- format(min(incr), nsmall = 1, scientific = F)
        decimals2 <- nchar(min_incr) - 2
        decimals <- min(decimals1,decimals2)
        if (!isTruthy(is.numeric(decimals)) || decimals < 1) {
          return(extra)
        }
      } else if (isempty(incr)) {
        epoch <- unique(fracEnt)
        if (length(epoch) == 1) {
          decimals <- nchar(epoch)
        } else {
          return(extra)
        }
      } else {
        return(extra)
      }
      zeroDecimals <- min(nchar(sub("(^0*).*", "\\1", sub("[0-9]*\\.", "", format(x, scientific = F)))))
      if (zeroDecimals > 5) {
        decimals <- decimals - zeroDecimals
        info$scientific <- T
      }
      return(decimals + extra)
    } else {
      if (messages > 2) cat(file = stderr(), mySession, "Bad series:", head(x), "\n")
      showNotification("Unable to obtain the appropriate number of decimal places of the series.", action = NULL, duration = 10, closeButton = T, id = "bad_decimalplaces", type = "error", session = getDefaultReactiveDomain())
      info$scientific <- F
      return(0)
    }
  }
  #
  signifdecimal <- function(x, rounded) {
    if (abs(x) >= 1) {
      return(0)
    } else {
      decimal <- nchar(format(signif(x,1), scientific = F)) - 3
      if (rounded) {
        if (round(x, decimal) > 0) {
          return(decimal)
        } else {
          return(decimal + 1)
        }
      } else {
        return(decimal)
      }
    }
  }
  #
  average <- function(p,x,y1,y2,y3,sy1,sy2,sy3,tol,w,s,second,sigmas) {
    index <- x >= x[1] + (p - 1)*s - tol & x < x[1] + p*s - tol * 2/3
    x_ <- y1_ <- y2_ <- y3_ <- NULL
    if (sigmas) sy1_ <- sy2_ <- sy3_ <- NULL
    if (length(x[index]) == 1) {
      x_ <- x[1] + (p - 0.5)*s
      if (isTruthy(second)) {
        y1_ <- y1[index]
        if (isTruthy(y2)) y2_ <- y2[index]
        if (isTruthy(y3)) y3_ <- y3[index]
        if (sigmas) {
          sy1_ <- sy1[index]
          if (isTruthy(sy2)) sy2_ <- sy2[index]
          if (isTruthy(sy3)) sy3_ <- sy3[index]
        }
      } else {
        y1_ <- y1[index & db1$original$status1]
        if (isTruthy(y2)) y2_ <- y2[index & db1$original$status2]
        if (isTruthy(y3)) y3_ <- y3[index & db1$original$status3]
        if (sigmas) {
          sy1_ <- sy1[index & db1$original$status1]
          if (isTruthy(sy2)) sy2_ <- sy2[index & db1$original$status2]
          if (isTruthy(sy3)) sy3_ <- sy3[index & db1$original$status3]
        }
      }
    } else if (length(x[index]) > 1) {
      x_ <- x[1] + (p - 0.5)*s
      if (isTruthy(second)) {
        if (sigmas) {
          y1_ <- weighted.mean(y1[index], 1/(sy1[index])^2, na.rm = T)
          if (isTruthy(y2)) y2_ <- weighted.mean(y2[index], 1/(sy2[index])^2, na.rm = T)
          if (isTruthy(y3)) y3_ <- weighted.mean(y3[index], 1/(sy3[index])^2, na.rm = T)
          sy1_ <- sqrt(1/sum(1/sy1[index]^2, na.rm = T))
          if (isTruthy(sy2)) sy2_ <- sqrt(1/sum(1/sy2[index]^2, na.rm = T))
          if (isTruthy(sy3)) sy3_ <- sqrt(1/sum(1/sy3[index]^2, na.rm = T))
        } else {
          y1_ <- mean(y1[index], na.rm = T)
          if (isTruthy(y2)) y2_ <- mean(y2[index], na.rm = T)
          if (isTruthy(y3)) y3_ <- mean(y3[index], na.rm = T)
        }
      } else {
        if (sigmas) {
          y1_ <- weighted.mean(y1[index & db1$original$status1], 1/(sy1[index & db1$original$status1])^2, na.rm = T)
          if (isTruthy(y2)) y2_ <- weighted.mean(y2[index & db1$original$status2], 1/(sy2[index & db1$original$status2])^2, na.rm = T)
          if (isTruthy(y3)) y3_ <- weighted.mean(y3[index & db1$original$status3], 1/(sy3[index & db1$original$status3])^2, na.rm = T)
          sy1_ <- sqrt(1/sum(1/sy1[index & db1$original$status1]^2, na.rm = T))
          if (isTruthy(sy2)) sy2_ <- sqrt(1/sum(1/sy2[index & db1$original$status2]^2, na.rm = T))
          if (isTruthy(sy3)) sy3_ <- sqrt(1/sum(1/sy3[index & db1$original$status3]^2, na.rm = T))
        } else {
          y1_ <- mean(y1[index & db1$original$status1], na.rm = T)
          if (isTruthy(y2)) y2_ <- mean(y2[index & db1$original$status2], na.rm = T)
          if (isTruthy(y3)) y3_ <- mean(y3[index & db1$original$status3], na.rm = T)
        }
      }
    }
    if (input$format == 4) {
      if (sigmas) {
        if (isTruthy(x_) && isTruthy(y1_) && isTruthy(sy1_)) {
          out <- c(x_,y1_,sy1_)
        } else {
          out <- c(NA,NA,NA)
        }
      } else {
        if (isTruthy(x_) && isTruthy(y1_)) {
          out <- c(x_,y1_)
        } else {
          out <- c(NA,NA)
        }
      }
    } else {
      if (sigmas) {
        if (isTruthy(x_) && isTruthy(y1_) && isTruthy(sy1_) && isTruthy(y2_) && isTruthy(sy2_) && isTruthy(y3_) && isTruthy(sy3_)) {
          out <- c(x_,y1_,y2_,y3_,sy1_,sy2_,sy3_)
        } else {
          out <- c(NA,NA,NA,NA,NA,NA,NA)
        }
      } else {
        if (isTruthy(x_) && isTruthy(y1_) && isTruthy(y2_) && isTruthy(y3_)) {
          out <- c(x_,y1_,y2_,y3_)
        } else {
          out <- c(NA,NA,NA,NA)
        }
      }
    }
    setProgress(round(p/w, digits = 1))
    return(out)
  }
  #
  get_URL_info <- function(server,station,product,series) {
    if (isTruthy(series)) {
      if (series == 1) {
        variable <- "station1"
      } else if (series == 2) {
        variable <- "station2"
      }
    }
    logfile <- NULL
    server <- toupper(server)
    product <- toupper(product)
    ## NGL ####
    if (server == "NGL") {
      format <- 3
      pattern <- ".tenv3"
      if (product == "IGS14") {
        url <- "https://geodesy.unr.edu/gps_timeseries/tenv3/IGS14/"
        listFile <- "www/NGL_database_IGS14.txt"
      } else if (product == "IGS20") {
        url <- "https://geodesy.unr.edu/gps_timeseries/IGS20/tenv3/IGS20/"
        listFile <- "www/NGL_database_IGS20.txt"
      } else if (product == "RAPID") {
        url <- "https://geodesy.unr.edu/gps_timeseries/rapids/tenv3/"
        listFile <- "www/NGL_database_rapid.txt"
      } else {
        showNotification(HTML(paste0("Unknown product ",product,".<br>No file was downloaded.")), action = NULL, duration = 10, closeButton = T, id = "bad_url", type = "error", session = getDefaultReactiveDomain())
        return(NULL)
      }
      if (isTruthy(station)) {
        name <- paste0(toupper(station),pattern)
        filepath <- paste0(url,name)
        if (file.exists("www/steps.txt") && series == 1) {
          file$custom$name <- "steps.txt"
          file$custom$datapath <- "www/steps.txt"
          session$sendCustomMessage("custom", "steps.txt")
          shinyjs::delay(100, updateCheckboxInput(inputId = "traceCustom", value = T))
        }
      } else {
        withBusyIndicatorServer(variable, {
          if (file.exists(listFile)) {
            stations_available <- readLines(listFile, warn = F)
          } else {
            dir_contents <- try(XML::readHTMLTable(url, skip.rows = 1:2, trim = T)[[1]]$Name, silent = T)
            if (isTruthy(dir_contents) && !inherits(dir_contents,"try-error")) {
              stations_available <- sub(pattern, "", grep(pattern, dir_contents, fixed = T, value = T))
              writeLines(stations_available, listFile, sep = "\n")
            } else {
              showNotification(HTML(paste("Server", server, "seems to be unreachable.<br>It is not possible to get the list of available stations.")), action = NULL, duration = 10, closeButton = T, id = "no_answer", type = "warning", session = getDefaultReactiveDomain())
              return(NULL)
            }
          }
          if (series == 1) {
            output$showStation1 <- renderUI({
              suppressWarnings(selectInput(inputId = "station1", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
            })
          } else if (series == 2) {
            output$showStation2 <- renderUI({
              suppressWarnings(selectInput(inputId = "station2", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
            })
            if (input$sunits == 2) {
              updateTextInput(session, inputId = "scaleFactor", value = "1000")
            } else {
              updateTextInput(session, inputId = "scaleFactor", value = "1")
            }
          }
          return(NULL)
        })
      }
    ## RENAG ####
    } else if (server == "RENAG") {
      format <- 2
      if (product == "UGA") {
        url <- "ftp://webrenag.unice.fr/products/POS/gamitUGA/"
        pattern <- "_raw.pos_UGA_ITRF14.pos"
        if (isTruthy(station)) {
          name <- paste0(toupper(station),pattern)
          filepath <- paste0(url,name)
          url_log <- "ftp://webrenag.unice.fr/sitelogs/"
          logfile <- paste0(url_log,toupper(station),"00FRA.log")
        } else {
          withBusyIndicatorServer(variable, {
            dir_contents <- try(getURL(url, ftp.use.epsv = FALSE, ftplistonly = TRUE, crlf = TRUE), silent = T)
            if (isTruthy(dir_contents) && !inherits(dir_contents,"try-error")) {
              stations_available <- sapply(strsplit(grep(pattern, strsplit(dir_contents, "\r*\n")[[1]], perl = F, value = T, fixed = T), split = pattern, fixed = T), "[[", 1)
              if (series == 1) {
                output$showStation1 <- renderUI({
                  suppressWarnings(selectInput(inputId = "station1", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
                })
              } else if (series == 2) {
                output$showStation2 <- renderUI({
                  suppressWarnings(selectInput(inputId = "station2", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
                })
                if (input$sunits == 2) {
                  updateTextInput(session, inputId = "scaleFactor", value = "1000")
                } else {
                  updateTextInput(session, inputId = "scaleFactor", value = "1")
                }
              }
            } else {
              showNotification(HTML(paste("Server", server, "seems to be unreachable.<br>It is not possible to get the list of available stations.")), action = NULL, duration = 10, closeButton = T, id = "no_answer", type = "warning", session = getDefaultReactiveDomain())
            }
            return(NULL)
          })
        }
      } else {
        showNotification(HTML(paste0("Unknown product ",product,".<br>No file was downloaded.")), action = NULL, duration = 10, closeButton = T, id = "bad_url", type = "error", session = getDefaultReactiveDomain())
        return(NULL)
      }
    ## JPL ####
    } else if (server == "JPL") {
      format <- 1
      if (product == "REPRO2018A") {
        url <- "https://sideshow.jpl.nasa.gov/pub/JPL_GPS_Timeseries/repro2018a/post/point/"
        pattern <- ".series"
        if (isTruthy(station)) {
          name <- paste0(toupper(station),pattern)
          filepath <- paste0(url,name)
        } else {
          withBusyIndicatorServer(variable, {
            if (!file.exists("www/JPL_database.txt")) {
              fullFile <- try(suppressWarnings(read.table("https://sideshow.jpl.nasa.gov/post/tables/table1.html", skip = 6, fill = T)), silent = T)
              if (isTruthy(fullFile) && !inherits(fullFile,"try-error")) {
                listStations <- fullFile[fullFile$V2 == "POS", c(1,3,4,5)]
                listStations$V3 <- as.numeric(listStations$V3) / 1000
                listStations$V4 <- as.numeric(listStations$V4) / 1000
                listStations$V5 <- as.numeric(listStations$V5) / 1000
                write.table(listStations, "www/JPL_database.txt", append = F, quote = F, sep = " ", row.names = F, col.names = F)
              } else {
                showNotification(HTML(paste("Server", server, "seems to be unreachable.<br>It is not possible to get the list of available stations.")), action = NULL, duration = 10, closeButton = T, id = "no_answer", type = "warning", session = getDefaultReactiveDomain())
                return(NULL)
              }
            }
            stations_available <- read.table("www/JPL_database.txt")$V1
            if (series == 1) {
              output$showStation1 <- renderUI({
                suppressWarnings(selectInput(inputId = "station1", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
              })
            } else if (series == 2) {
              output$showStation2 <- renderUI({
                suppressWarnings(selectInput(inputId = "station2", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
              })
              if (input$sunits == 2) {
                updateTextInput(session, inputId = "scaleFactor", value = "1000")
              } else {
                updateTextInput(session, inputId = "scaleFactor", value = "1")
              }
            }
            return(NULL)
          })
        }
      } else {
        showNotification(HTML(paste0("Unknown product ",product,".<br>No file was downloaded.")), action = NULL, duration = 10, closeButton = T, id = "bad_url", type = "error", session = getDefaultReactiveDomain())
        return(NULL)
      }
    ## IGS ####
    } else if (server == "IGS") {
      format <- 1
      if (product == "IGS20") {
        url <- "ftp://igs-rf.ign.fr/pub/crd/"
        pattern <- "_igs.plh"
        if (isTruthy(station)) {
          name <- paste0(toupper(station),pattern)
          filepath <- paste0(url,name)
          if (file.exists("www/soln.snx") && series == 1) {
            file$soln$name <- "soln.snx"
            file$soln$datapath <- "www/soln.snx"
            session$sendCustomMessage("soln", "soln.snx")
            shinyjs::delay(100, updateCheckboxInput(inputId = "traceSoln", value = T))
          }
        } else {
          withBusyIndicatorServer(variable, {
            dir_contents <- try(getURL(url, ftp.use.epsv = FALSE, ftplistonly = TRUE, crlf = TRUE), silent = T)
            if (isTruthy(dir_contents) && !inherits(dir_contents,"try-error")) {
              stations_available <- sapply(strsplit(grep(pattern, strsplit(dir_contents, "\r*\n")[[1]], perl = F, value = T, fixed = T), split = pattern, fixed = T), "[[", 1)
              if (series == 1) {
                output$showStation1 <- renderUI({
                  suppressWarnings(selectInput(inputId = "station1", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
                })
              } else if (series == 2) {
                output$showStation2 <- renderUI({
                  suppressWarnings(selectInput(inputId = "station2", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
                })
                if (input$sunits == 2) {
                  updateTextInput(session, inputId = "scaleFactor", value = "1000")
                } else {
                  updateTextInput(session, inputId = "scaleFactor", value = "1")
                }
              }
            } else {
              showNotification(HTML(paste("Server", server, "seems to be unreachable.<br>It is not possible to get the list of available stations.")), action = NULL, duration = 10, closeButton = T, id = "no_answer", type = "warning", session = getDefaultReactiveDomain())
            }
            return(NULL)
          })
        }
      } else {
        showNotification(HTML(paste0("Unknown product ",product,".<br>No file was downloaded.")), action = NULL, duration = 10, closeButton = T, id = "bad_url", type = "error", session = getDefaultReactiveDomain())
        return(NULL)
      }
    ## SONEL ####
    } else if (server == "SONEL") {
      format <- 1
      if (product == "ULR7A") {
        if (isTruthy(station)) {
          name <- paste0(toupper(station), ".neu")
          station4 <- substring(station, 1, 4)
          filepath <- paste0("https://api.sonel.org/v1/products/vlm/gnss/timeseries?solution=ULR7A&acro=",station,"&format=neu&sampling=daily")
          url_log <- "ftp://ftp.sonel.org/meta/gpslog/"
          dir_contents <- try(getURL(url_log, ftp.use.epsv = FALSE, ftplistonly = TRUE, crlf = TRUE), silent = T)
          if (isTruthy(dir_contents) && !inherits(dir_contents,"try-error")) {
            found <- grep(paste0("^",tolower(station)), strsplit(dir_contents, "\r*\n")[[1]], perl = T, value = T, fixed = F)
            if (isTruthy(found)) {
              logfile <- paste0(url_log,found)
            }
          }
        } else {
          url <- "https://api.sonel.org/v1/products/vlm/gnss/meta?mode=solution"
          withBusyIndicatorServer(variable, {
            dir_contents <- try(fromJSON(txt = url), silent = T)
            if (isTruthy(dir_contents) && !inherits(dir_contents,"try-error")) {
              code <- which(dir_contents$code == product)
              if (code > 0) {
                stations_available <- dir_contents$stations[[code]]
                if (series == 1) {
                  output$showStation1 <- renderUI({
                    suppressWarnings(selectInput(inputId = "station1", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
                  })
                } else if (series == 2) {
                  output$showStation2 <- renderUI({
                    suppressWarnings(selectInput(inputId = "station2", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
                  })
                  if (input$sunits == 2) {
                    updateTextInput(session, inputId = "scaleFactor", value = "1000")
                  } else {
                    updateTextInput(session, inputId = "scaleFactor", value = "1")
                  }
                }
              }
            } else {
              showNotification(HTML(paste("Server", server, "seems to be unreachable.<br>It is not possible to get the list of available stations.")), action = NULL, duration = 10, closeButton = T, id = "no_answer", type = "warning", session = getDefaultReactiveDomain())
            }
            return(NULL)
          })
        }
      } else {
        showNotification(HTML(paste0("Unknown product ",product,".<br>No file was downloaded.")), action = NULL, duration = 10, closeButton = T, id = "bad_url", type = "error", session = getDefaultReactiveDomain())
        return(NULL)
      }
    ## UNAVCO ####
    } else if (server == "EARTHSCOPE") {
      format <- 1
      if (isTruthy(product)) {
        if (isTruthy(station)) {
          if (product == "CWU" || product == "PBO" || product == "NMT") {
            name <- paste0(toupper(station),".",tolower(product),".igs14.pos")
            filepath <- paste0("https://web-services.unavco.org/gps/data/position/", toupper(station), "/v3?analysisCenter=", tolower(product), "&referenceFrame=igs14&starttime=&endtime=&report=long&dataPostProcessing=Uncleaned&refCoordOption=from_analysis_center")
          } else {
            return(NULL)
          }
        } else {
          withBusyIndicatorServer(variable, {
            if (file.exists("www/UNAVCO_database.txt")) {
              stations_available <- readLines("www/UNAVCO_database.txt", warn = F)
            } else {
              tmp_unavco <- tempfile()
              download.file("https://web-services.unavco.org/gps/metadata/sites/v1?minlatitude=-90&maxlatitude=90&minlongitude=-180&maxlongitude=180&starttime=&endtime=&summary=false", destfile = tmp_unavco, method = "curl", extra = "-X GET", headers = c(accept = "text/csv"), quiet = T, cacheOK = F)
              stations_available <- sort(unique(read.csv(tmp_unavco, comment.char = "#")[,1]))
              writeLines(stations_available, "www/UNAVCO_database.txt", sep = "\n")
            }
            if (series == 1) {
              output$showStation1 <- renderUI({
                suppressWarnings(selectInput(inputId = "station1", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
              })
            } else if (series == 2) {
              output$showStation2 <- renderUI({
                suppressWarnings(selectInput(inputId = "station2", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
              })
              if (input$sunits == 2) {
                updateTextInput(session, inputId = "scaleFactor", value = "1000")
              } else {
                updateTextInput(session, inputId = "scaleFactor", value = "1")
              }
            }
            return(NULL)
          })
        }
      } else {
        return(NULL)
      }
    ## EUREF ####
    } else if (server == "EUREF") {
      format <- 2
      if (product == "IGB14") {
        url <- "https://epncb.eu/ftp/product/cumulative/C2235/pbo/"
        pattern <- ".pos"
        if (isTruthy(station)) {
          name <- paste0(toupper(station),pattern)
          filepath <- paste0(url,name)
          url_log <- "https://gnss-metadata.eu/data/station/log/"
          found <- grep(paste0(tolower(station),""), readHTMLTable(readLines(url_log), header = F)$list$V1, perl = F, value = T, fixed = T)
          if (isTruthy(found)) {
            logfile <- paste0(url_log,found)
          }
        } else {
          withBusyIndicatorServer(variable, {
            dir_contents <- try(readHTMLTable(getURL(url, crlf = TRUE), skip.rows = 1:2, trim = T)[[1]]$Name, silent = T)
            if (isTruthy(dir_contents) && !inherits(dir_contents,"try-error")) {
              stations_available <- sub(pattern, "", grep(pattern, dir_contents, ignore.case = F, value = T))
              if (series == 1) {
                output$showStation1 <- renderUI({
                  suppressWarnings(selectInput(inputId = "station1", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
                })
              } else if (series == 2) {
                output$showStation2 <- renderUI({
                  suppressWarnings(selectInput(inputId = "station2", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
                })
                if (input$sunits == 2) {
                  updateTextInput(session, inputId = "scaleFactor", value = "1000")
                } else {
                  updateTextInput(session, inputId = "scaleFactor", value = "1")
                }
              }
            } else {
              showNotification(HTML(paste("Server", server, "seems to be unreachable.<br>It is not possible to get the list of available stations.")), action = NULL, duration = 10, closeButton = T, id = "no_answer", type = "warning", session = getDefaultReactiveDomain())
            }
            return(NULL)
          })
        }
      } else {
        showNotification(paste0("Unknown product ",product,". No file was downloaded."), action = NULL, duration = 10, closeButton = T, id = "bad_url", type = "error", session = getDefaultReactiveDomain())
        return(NULL)
      }
    ## FORMATERRE ####
    } else if (server == "FORMATERRE") {
      if (product == "SPOTGINS" || product == "SPOTGINS_POS") {
        format <- 1
        pattern1 <- "SPOTGINS_"
        pattern2 <- ".enu"
        solution <- "SPOTGINS"
        name <- paste0(pattern1,toupper(station),pattern2)
      } else if (product == "UGA" || product == "UGA_POS") {
        format <- 2
        pattern1 <- "UGA_"
        pattern2 <- ".pos"
        solution <- "UGA_"
        name <- paste0(pattern1,toupper(station),"_01D",pattern2)
      } else if (product == "IGS20") {
        format <- 2
        pattern1 <- "IGS_"
        pattern2 <- ".pos"
        solution <- "IGS"
        name <- paste0(pattern1,toupper(station),pattern2)
      } else if (product == "ENS") {
        format <- 2
        pattern1 <- "ENS_"
        pattern2 <- ".pos"
        solution <- "_GNSS_solENS"
        name <- paste0(pattern1,toupper(station),pattern2)
      }
      url <- "https://geodesy-plotter.ipgp.fr/"
      if (product == "SPOTGINS" || product == "SPOTGINS_POS" || product == "UGA" || product == "UGA_POS" || product == "IGS20" || product == "ENS") {
        if (isTruthy(station)) {
          filepath <- paste0(url,"data/",toupper(station),"/",name)
          if (series == 1) {
            if (product == "SPOTGINS" || product == "SPOTGINS_POS") {
              # url_log <- "https://geodesy-plotter.ipgp.fr/api/1.0/solutions/SPOTGINS/offsets"
              if (file.exists("www/SPOTGINS_events.dat")) {
                file$custom$name <- "SPOTGINS_events.dat"
                file$custom$datapath <- "www/SPOTGINS_events.dat"
                session$sendCustomMessage("custom", "SPOTGINS_events.dat")
                shinyjs::delay(100, updateCheckboxInput(inputId = "traceCustom", value = T))
              }
            } else if (product == "UGA" || product == "UGA_POS") {
              url_log <- "https://gnss-metadata.eu/data/station/log/"
              found <- grep(paste0(tolower(station),""), readHTMLTable(readLines(url_log), header = F)$list$V1, perl = F, value = T, fixed = T)
              if (isTruthy(found)) {
                logfile <- paste0(url_log,found)
              }
            } else if (product == "IGS20") {
              if (file.exists("www/soln.snx") && series == 1) {
                file$soln$name <- "soln.snx"
                file$soln$datapath <- "www/soln.snx"
                session$sendCustomMessage("soln", "soln.snx")
                shinyjs::delay(100, updateCheckboxInput(inputId = "traceSoln", value = T))
              }
            } else if (product == "ENS") {
              # url_log <- "https://geodesy-plotter.ipgp.fr/api/1.0/solutions/SOAM_GNSS_solENS/offsets"
              if (file.exists("www/SOAM_GNSS_solENS_offset.dat")) {
                file$custom$name <- "SOAM_GNSS_solENS_offset.dat"
                file$custom$datapath <- "www/SOAM_GNSS_solENS_offset.dat"
                session$sendCustomMessage("custom", "SOAM_GNSS_solENS_offset.dat")
                shinyjs::delay(100, updateCheckboxInput(inputId = "traceCustom", value = T))
              }
            }
          }
        } else {
          withBusyIndicatorServer(variable, {
            url <- paste0(url,"api/1.0/products/?output=csv")
            dir_contents <- try(read.csv(url, skip = 2, header = T), silent = T)
            if (isTruthy(dir_contents) && !inherits(dir_contents,"try-error")) {
              stations_available <- sort(as.character(dir_contents$STATION[grepl(solution, dir_contents$SOLUTION)]))
              if (length(stations_available) > 0) {
                if (series == 1) {
                  output$showStation1 <- renderUI({
                    suppressWarnings(selectInput(inputId = "station1", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
                  })
                } else if (series == 2) {
                  output$showStation2 <- renderUI({
                    suppressWarnings(selectInput(inputId = "station2", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
                  })
                  if (input$sunits == 2) {
                    updateTextInput(session, inputId = "scaleFactor", value = "1000")
                  } else {
                    updateTextInput(session, inputId = "scaleFactor", value = "1")
                  }
                }
              } else {
                showNotification(HTML(paste("Server", server, "seems to be unreachable.<br>It is not possible to get the list of available stations.")), action = NULL, duration = 10, closeButton = T, id = "no_answer", type = "warning", session = getDefaultReactiveDomain())
              }
            } else {
              showNotification(HTML(paste("Server", server, "seems to be unreachable.<br>It is not possible to get the list of available stations.")), action = NULL, duration = 10, closeButton = T, id = "no_answer", type = "warning", session = getDefaultReactiveDomain())
            }
            return(NULL)
          })
        }
      } else {
        showNotification(paste0("Unknown product ",product,". No file was downloaded."), action = NULL, duration = 10, closeButton = T, id = "bad_url", type = "error", session = getDefaultReactiveDomain())
        return(NULL)
      }
    ## EPOS ####
    } else if (server == "EPOS") {
      format <- 1
      if (product == "INGV" || product == "SGO-EPND" || product == "UGA-CNRS" || product == "ROB-EUREF") {
        if (isTruthy(station)) {
          name <- paste0("timeseries", station, "_", product, ".json")
          filepath <- paste0("https://gnssproducts.epos.ubi.pt/GlassFramework/webresources/products/timeseries/", station, "/", product, "/enu/json/?file=true")
          url_log <- "https://gnss-metadata.eu/data/station/log/"
          found <- grep(paste0(tolower(station),""), readHTMLTable(readLines(url_log), header = F)$list$V1, perl = F, value = T, fixed = T)
          if (isTruthy(found)) {
            logfile <- paste0(url_log,found)
          }
        } else {
          withBusyIndicatorServer(variable, {
            if (file.exists("www/EPOS_database.txt")) {
              stationsFromEPOS <- read.table(file = "www/EPOS_database.txt", header = T)
              stations_available <- stationsFromEPOS[grepl(product, stationsFromEPOS$provider), 1]
            } else {
              url <- "https://gnssproducts.epos.ubi.pt/GlassFramework/webresources/stations/v2/station/bbox/-25.664/35.60371874069731/27.07/68.0075?with=2"
              stationsFromEPOS.json <- jsonlite::fromJSON(readLines(url, ok = T, warn = F))
              if (isTruthy(stationsFromEPOS.json)) {
                stationsFromEPOS <- data.frame(id = stationsFromEPOS.json$features$properties$`GNSS Station ID`, lat = stationsFromEPOS.json$features$properties$Latitude, lon = stationsFromEPOS.json$features$properties$Longitude, provider = stationsFromEPOS.json$features$properties$`TimeSeries Data Providers`)
                stationsFromEPOS$provider <- gsub(" ", "|", stationsFromEPOS$provider)
                stations_available <- stationsFromEPOS[grepl(product, stationsFromEPOS$provider), 1]
                write.table(stationsFromEPOS, file = "www/EPOS_database.txt", append = F, quote = F, row.names = F)
              } else {
                showNotification(HTML(paste("Server", server, "seems to be unreachable.<br>It is not possible to get the list of available stations.")), action = NULL, duration = 10, closeButton = T, id = "no_answer", type = "warning", session = getDefaultReactiveDomain())
                return(NULL)
              }
            }
            if (series == 1) {
              output$showStation1 <- renderUI({
                suppressWarnings(selectInput(inputId = "station1", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
              })
            } else if (series == 2) {
              output$showStation2 <- renderUI({
                suppressWarnings(selectInput(inputId = "station2", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
              })
              if (input$sunits == 1) {
                updateTextInput(session, inputId = "scaleFactor", value = "0.001")
              } else {
                updateTextInput(session, inputId = "scaleFactor", value = "1")
              }
            }
            return(NULL)
          })
        }
      } else {
        showNotification(paste0("Unknown product ",product,". No file was downloaded."), action = NULL, duration = 10, closeButton = T, id = "bad_url", type = "error", session = getDefaultReactiveDomain())
        return(NULL)
      }
    ## EOSTLS ####
    } else if (server == "EOSTLS") {
      format <- 1
      pattern <- "_NEU."
      patternd <- "_NEU_daily."
      if (isTruthy(station)) {
        filepath <- c()
        name <- c()
        station <- strsplit(station, split = " ")[[1]][1]
        for (p in product) {
          naming <- paste0(toupper(station),pattern,tolower(p))
          url <- "http://loading.u-strasbg.fr/ITRF/CF/"
          if (tolower(p) == "atmib") {
            url <- paste0(url, "ATMIB/")
          } else if (tolower(p) == "atmib(d)") {
            url <- paste0(url, "ATMIB_daily/")
            naming <- paste0(toupper(station),patternd,"atmib")
          } else if (tolower(p) == "atmmo") {
            url <- paste0(url, "ATMMO/")
          } else if (tolower(p) == "ecco") {
            url <- paste0(url, "ECCO/")
          } else if (tolower(p) == "ecco2") {
            url <- paste0(url, "ECCO2/")
          } else if (tolower(p) == "era5ib") {
            naming <- paste0(toupper(station),pattern,"era5")
            url <- paste0(url, "ERA5_IB/")
          } else if (tolower(p) == "era5ib(d)") {
            naming <- paste0(toupper(station),patternd,"era5")
            url <- paste0(url, "ERA5_IB_daily/")
          } else if (tolower(p) == "era5tugo") {
            naming <- paste0(toupper(station),pattern,"era5")
            url <- paste0(url, "ERA5_TUGO/")
          } else if (tolower(p) == "era5tugo(d)") {
            naming <- paste0(toupper(station),patternd,"era5")
            url <- paste0(url, "ERA5_TUGO_daily/")
          } else if (tolower(p) == "era5hyd") {
            naming <- paste0(toupper(station),pattern,"era5")
            url <- paste0(url, "ERA5_hydro/")
          } else if (tolower(p) == "era5hyd(d)") {
            naming <- paste0(toupper(station),patternd,"era5")
            url <- paste0(url, "ERA5_hydro_daily/")
          } else if (tolower(p) == "era5land") {
            naming <- paste0(toupper(station),pattern,"era5land")
            url <- paste0(url, "ERA5_land/")
          } else if (tolower(p) == "gldas2") {
            url <- paste0(url, "GLDAS2/")
          } else if (tolower(p) == "gldas2(d)") {
            naming <- paste0(toupper(station),patternd,"gldas2")
            url <- paste0(url, "GLDAS2_daily/")
          } else if (tolower(p) == "glorys") {
            url <- paste0(url, "GLORYS/")
          } else if (tolower(p) == "grace") {
            url <- paste0(url, "GRACE/")
          } else if (tolower(p) == "merra2atm") {
            naming <- paste0(toupper(station),"_NEU_ib.merra2")
            url <- paste0(url, "MERRA2_atm/")
          } else if (tolower(p) == "merra2atm(d)") {
            naming <- paste0(toupper(station),"_NEU_daily_ib.merra2")
            url <- paste0(url, "MERRA2_atm_daily/")
          } else if (tolower(p) == "merra2hyd") {
            naming <- paste0(toupper(station),pattern,"merra2")
            url <- paste0(url, "MERRA2_hyd/")
          } else if (tolower(p) == "merra2hyd(d)") {
            naming <- paste0(toupper(station),patternd,"merra2")
            url <- paste0(url, "MERRA2_hyd_daily/")
          } else {
            showNotification(paste0("Unknown product ",p,". No file was downloaded."), action = NULL, duration = 10, closeButton = T, id = "bad_url", type = "error", session = getDefaultReactiveDomain())
            return(NULL)
          }
          name <- c(name, naming)
          filepath <- c(filepath, paste0(url,naming))
        }
      } else {
        withBusyIndicatorServer(variable, {
          if (file.exists("www/EOSTLS_database.txt")) {
            database <- read.table("www/EOSTLS_database.txt", fill = T, comment.char = "!", header = F)
            stations_available <- paste(paste(database$V1,database$V2,sep = "_"),database$V7,database$V6)
            if (series == 1) {
              output$showStation1 <- renderUI({
                suppressWarnings(selectInput(inputId = "station1", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
              })
            } else if (series == 2) {
              output$showStation2 <- renderUI({
                suppressWarnings(selectInput(inputId = "station2", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
              })
              if (isTruthy(inputs$step) && info$db1 == "resampled") {
                step <- inputs$step
              } else {
                if (input$tunits == 1) {
                  step <- 1
                } else if (input$tunits == 2) {
                  step <- 1/7
                } else if (input$tunits == 3) {
                  step <- 1/daysInYear
                }
              }
              updateTextInput(session, inputId = "step2", value = step)
              if (input$sunits == 1) {
                updateTextInput(session, inputId = "scaleFactor", value = "0.001")
              } else {
                updateTextInput(session, inputId = "scaleFactor", value = "1")
              }
            }
          } else {
            showNotification(HTML("The list of EOSTLS stations is not found.<br>It is not possible to get the list of available stations."), action = NULL, duration = 10, closeButton = T, id = "no_answer", type = "warning", session = getDefaultReactiveDomain())
          }
          return(NULL)
        })
      }
    ## SIRGAS ####
    } else if (server == "SIRGAS") {
      if (product == "IGB14") {
        format <- 1
        pattern <- ".PLH"
        if (isTruthy(station)) {
          url <- "https://www.sirgas.org/fileadmin/docs/SIRGAS_CRD/"
          name <- paste0(toupper(station),".PLH")
          filepath <- paste0(url,name)
          url_log <- "ftp://ftp.sirgas.org/pub/gps/DGF/station/log/"
          dir_contents <- try(getURL(url_log, ftp.use.epsv = FALSE, ftplistonly = TRUE, crlf = TRUE), silent = T)
          if (isTruthy(dir_contents) && !inherits(dir_contents,"try-error")) {
            found <- grep(tolower(station), strsplit(dir_contents, "\r*\n")[[1]], perl = F, value = T, fixed = T)
            if (isTruthy(found)) {
              logfile <- paste0(url_log,found)
            }
          }
        } else {
          url <- "https://www.sirgas.org/en/stations/station-list/"
          url2 <- "https://sirgas.ipgh.org/maps/stations/stations-list.php"
          withBusyIndicatorServer(variable, {
            dir_contents <- try(httr::GET(url), silent = T)
            if (isTruthy(dir_contents) && !inherits(dir_contents,"try-error")) {
              stations_available <- strtrim(readHTMLTable(rawToChar(dir_contents$content))[[1]]$ID, 4)
              if (series == 1) {
                output$showStation1 <- renderUI({
                  suppressWarnings(selectInput(inputId = "station1", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
                })
              } else if (series == 2) {
                output$showStation2 <- renderUI({
                  suppressWarnings(selectInput(inputId = "station2", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
                })
                if (input$sunits == 2) {
                  updateTextInput(session, inputId = "scaleFactor", value = "1000")
                } else {
                  updateTextInput(session, inputId = "scaleFactor", value = "1")
                }
              }
            } else {
              dir_contents <- try(httr::GET(url2), silent = T)
              if (isTruthy(dir_contents) && !inherits(dir_contents,"try-error")) {
                stations_available <- strtrim(readHTMLTable(rawToChar(dir_contents$content))[[1]]$ID, 4)
                if (series == 1) {
                  output$showStation1 <- renderUI({
                    suppressWarnings(selectInput(inputId = "station1", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
                  })
                } else if (series == 2) {
                  output$showStation2 <- renderUI({
                    suppressWarnings(selectInput(inputId = "station2", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
                  })
                }
              } else {
                showNotification(HTML(paste("Server", server, "seems to be unreachable.<br>It is not possible to get the list of available stations.")), action = NULL, duration = 10, closeButton = T, id = "no_answer", type = "warning", session = getDefaultReactiveDomain())
              }
            }
            return(NULL)
          })
        }
      } else {
        showNotification(paste0("Unknown product ",product,". No file was downloaded."), action = NULL, duration = 10, closeButton = T, id = "bad_url", type = "error", session = getDefaultReactiveDomain())
        return(NULL)
      }
    ## DORIS ####
    } else if (server == "DORIS") {
      format <- 1
      solution <- "25wd03"
      if (product == "ESA") {
        pattern <- "esa"
      } else if (product == "GOP") {
        pattern <- "gop"
      } else if (product == "GRG") {
        pattern <- "grg"
      } else if (product == "GSC") {
        pattern <- "gsc"
      } else if (product == "IDS") {
        pattern <- "ids"
      } else if (product == "IGN") {
        pattern <- "ign"
      }
      name <- station
      url <- paste0("https://apps.ids-doris.org/api/v1/position/",pattern,solution,"/")
      listFile <- "www/DORIS_database.txt"
      if (product == "ESA" || product == "GOP" || product == "GRG" || product == "GSC" || product == "IDS" || product == "IGN") {
        if (isTruthy(station)) {
          filepath <- paste0(url,name)
        } else {
          withBusyIndicatorServer(variable, {
            if (file.exists(listFile)) {
              dorisStations <- read.table(listFile, sep = ";")
              colnames(dorisStations) <- c("id","lat","lon","altitude","domes","mnemonic","startDate","endDate","technique","site.id","site.name","site.country","site.lat","site.lon","site.altitude")
            } else {
              dorisStations <- try(fromJSON(txt = "https://apps.ids-doris.org/api/v1/station"), silent = T)
              write.table(dorisStations[dorisStations$technique == "DORIS",], "www/DORIS_database.txt", append = F, row.names = F, col.names = F, sep = ";")
            }
            if (isTruthy(dorisStations) && !inherits(dorisStations,"try-error")) {
              stations_available <- sort(dorisStations[dorisStations$technique == "DORIS",]$mnemonic)
              if (length(stations_available) > 0) {
                if (series == 1) {
                  output$showStation1 <- renderUI({
                    suppressWarnings(selectInput(inputId = "station1", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
                  })
                } else if (series == 2) {
                  output$showStation2 <- renderUI({
                    suppressWarnings(selectInput(inputId = "station2", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
                  })
                  if (input$sunits == 2) {
                    updateTextInput(session, inputId = "scaleFactor", value = "1000")
                  } else {
                    updateTextInput(session, inputId = "scaleFactor", value = "1")
                  }
                }
              } else {
                showNotification(HTML(paste("Server", server, "seems to be unreachable.<br>It is not possible to get the list of available stations.")), action = NULL, duration = 10, closeButton = T, id = "no_answer", type = "warning", session = getDefaultReactiveDomain())
              }
            } else {
              showNotification(HTML(paste("Server", server, "seems to be unreachable.<br>It is not possible to get the list of available stations.")), action = NULL, duration = 10, closeButton = T, id = "no_answer", type = "warning", session = getDefaultReactiveDomain())
            }
            return(NULL)
          })
        }
      } else {
        showNotification(paste0("Unknown product ",product,". No file was downloaded."), action = NULL, duration = 10, closeButton = T, id = "bad_url", type = "error", session = getDefaultReactiveDomain())
        return(NULL)
      }
    ## PSMSL ####
    } else if (server == "PSMSL") {
      format <- 4
      pattern <- ".rlrdata"
      if (isTruthy(station)) {
        url <- "https://psmsl.org/data/obtaining/rlr.monthly.data/"
        if (grepl(":", station, fixed = T)) {
          stationId <- trimws(unlist(strsplit(station, split = ":")))[1]
          station <- trimws(unlist(strsplit(station, split = ":")))[2]
        } else {
          stationId <- station
          stationsFromPSMSL <- try(read.table(file = "www/PSMSL_database.txt", sep = ";"), silent = T)
          station <- stationsFromPSMSL[stationsFromPSMSL$V1 == station,2]
        }
        name <- paste0(stationId,pattern)
        filepath <- paste0(url,name)
        updateCheckboxInput(session, inputId = "sigmas", value = F)
        disable("sigmas")
        if (series == 1) {
          updateSelectInput(session, inputId = "separator", selected = 3)
        } else if (series == 2) {
          updateSelectInput(session, inputId = "separator2", selected = 3)
        }
      } else {
        withBusyIndicatorServer(variable, {
          if (file.exists("www/PSMSL_database.txt")) {
            table <- read.table("www/PSMSL_database.txt", sep = ";", quote = "@")[,c(1,2)]
            stations_available <- do.call(paste, c(table[order(table$V1),], sep = ": "))
            if (series == 1) {
              output$showStation1 <- renderUI({
                suppressWarnings(selectInput(inputId = "station1", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
              })
            } else if (series == 2) {
              output$showStation2 <- renderUI({
                suppressWarnings(selectInput(inputId = "station2", label = "Station", choices = c("Available stations" = "", stations_available), selected = "", selectize = T))
              })
            }
          } else {
            showNotification(HTML("The list of PSMSL stations is not found.<br>It is not possible to get the list of available stations."), action = NULL, duration = 10, closeButton = T, id = "no_answer", type = "warning", session = getDefaultReactiveDomain())
          }
          return(NULL)
        })
      }
    ## LOCAL ####
    } else if (server == "LOCAL") {
      if (product == "NEU" || product == "ENU" || product == "SPOTGINS") {
        format <- 1
      } else if (product == "PBO") {
        format <- 2
      } else if (product == "NGL") {
        format <- 3
      } else if (product == "1D") {
        format <- 4
      } else {
        showNotification(paste0("Unknown product ",product,". No file was downloaded."), action = NULL, duration = 10, closeButton = T, id = "bad_url", type = "error", session = getDefaultReactiveDomain())
        return(NULL)
      }
      name <- basename(station)
      filepath <- station
      removes <- "^SPOTGINS_|^UGA_|^IGS_|^ENS_"
      station <- strsplit(gsub(pattern = removes, replacement = "", x = name, ignore.case = T, perl = T, fixed = F), "\\.|_|\\s|-|\\(")[[1]][1]
      #
    } else {
      showNotification(paste0("Unknown server ",server,". No file was downloaded."), action = NULL, duration = 10, closeButton = T, id = "bad_url", type = "error", session = getDefaultReactiveDomain())
      return(NULL)
    }
    return(list(station,filepath,name,format,logfile))
  }
  #
  deg2m <- function(lat,lon,h,dlat,dlon) {
    #lat, lon, dlat, dlon in radians; h in m
    a <- 6378137
    b <- 6356752.314140347
    e2 <- (a^2 - b^2) / a^2
    N <- a / sqrt( 1 - e2 * sin(lat)^2) + h
    n <- N * dlat
    e <- N * dlon * cos(lat)
    return(n,e)
  }
  #
  cov_powerlaw <- function(k,n,deriv,gaps,sampling) {
    a <- Delta <- numeric(n)
    a[1] <- 0
    Delta[1] <- 1
    for (i in 2:n) {
      a[i] <- (-k/2 + i - 1 - 1)/(i - 1)
      Delta[i] <- Delta[i - 1] * a[i]
    }
    Z <- toeplitz(Delta[gaps])
    Z[upper.tri(Z)] <- 0
    # Z <- Z * sampling^(-k/2) # variance scaling from Gobron 2020
    Z <- Z * sampling^(-k/4) # Variance scaling from Williams 2003
    if (exists("tcrossprod_cpp", mode = "function")) {
      ZZt <- tcrossprod_cpp(Z,Z)
    } else {
      ZZt <- tcrossprod(Z)
    }
    if (deriv) {
      u <- numeric(n)
      u[1] <- 0
      for (i in 2:n) {
        u[i] <- -1/(2*(i - 1))*Delta[i - 1] + a[i]*u[i - 1]
        # u[i] <- -1/(2*i)*Delta[i - 1] + a[i]*u[i - 1]
      }
      U <- toeplitz(u[gaps])
      U[upper.tri(U)] <- 0
      if (exists("tcrossprod_cpp", mode = "function")) {
        UZt <- tcrossprod_cpp(U,Z)
      } else {
        UZt <- tcrossprod(U,Z)
      }
      derivZ <- sampling^(-k/2)*(-0.5*log(sampling)*ZZt + UZt + t(UZt)) # from Gobron 2020
      derivZ <- derivZ * sampling^(-k/4) # Variance scaling from Williams 2003
      return(list(ZZt, derivZ))
    } else {
      return(list(ZZt))
    }
  }
  #
  loglikelihood <- function(series,M,r) {
    if (r > 0) {
      return(-0.5*(length(series)*log(2*pi*r) + determinant(M)$modulus[[1]] + length(series)))
    } else {
      Qinv <- matInv(M, log.det = T, silent = T) # this is the slowest step in the whole MLE process when the spectral index is not estimated
      logDet <- attr(Qinv, "log.det")
      QinvR <- Qinv %*% series
      ll <- (-0.5*(length(series)*log(2*pi) + logDet + crossprod(series, QinvR)))[1]
      return(list(ll,Qinv,QinvR))
    }
  }
  #
  pl_trend_unc <- function(amp,index,sampling,points) {
    v <- -0.0237*index^9 - 0.3881*index^8 - 2.6610*index^7 - 9.8529*index^6 - 21.0922*index^5 - 25.1638*index^4 - 11.4275*index^3 + 10.7839*index^2 + 20.3377*index^1 + 11.9942*index^0
    beta <- (-1*index)/2 - 2
    if (index > -1.5 && index < -0.5) {
      gamma <- -3 - index + 7.7435*exp(-10)*index^17 - (0.0144/(0.27*sqrt(2*pi)))*exp(-0.5*((index + 1.025)/0.27)^2)
    } else if (index < -2.5) {
      gamma <- -3 - index - 0.52 * index^2 - 2.67 * index - 3.43
    } else {
      gamma <- -3 - index
    }
    return(sqrt(amp^2 * v * sampling^beta * points^gamma))
  }
  #
  noise_var <- function(std,k) {
    if (input$tunits == 1) { #days
      f_scale <- 24*60*60
    } else if (input$tunits == 2) { #weeks
      f_scale <- 7*24*60*60
    } else if (input$tunits == 3) { #years
      f_scale <- 365.25*24*60*60
    }
    fs_hz <- 1/(info$sampling*f_scale)

    Dk <- 2*(2*pi)^k * f_scale^(k/2)
    return(std^2 * Dk / (fs_hz^(1 + (k/2)))) #from Williams 2003 (Eq. 10)
  }
  #
  download <- function(server,remote,local) {
    removeNotification("no_cmd")
    # download series using curl or wget
    if (isTruthy(Sys.which("curl"))) {
      method <- "curl"
    } else if (isTruthy(Sys.which("wget"))) {
      method <- "wget"
    } else {
      showNotification("Neither curl nor wget are available on the system.", action = NULL, duration = 10, closeButton = T, id = "no_cmd", type = "error", session = getDefaultReactiveDomain())
      return(1)
    }
    down <- suppressWarnings(try(download.file(remote, destfile = local, method = method, quiet = T, mode = "w", cacheOK = T), silent = T))
    return(down)
  }
  #
  mjd2week <- function(x) {
    offset <- 0
    if (all(x < 35000)) {
      offset <- 33282
    }
    decimals <- decimalplaces(x, 0) + 3
    decimals <- ifelse(decimals > 0, decimals, 0)
    return(as.numeric(sprintf("%.*f", decimals, (x + offset - 44244)/7)))
  }
  #
  week2mjd <- function(x) {
    decimals <- decimalplaces(x, 0) - 2
    decimals <- ifelse(decimals > 0, decimals, 0)
    return(as.numeric(sprintf("%.*f", decimals, x * 7 + 44244)))
  }
  #
  mjd2year <- function(x) {
    offset <- 0
    if (all(x < 35000)) {
      offset <- 33282
    }
    decimals <- decimalplaces(diff(x), 0) + 4
    decimals <- ifelse(decimals > 0, decimals, 0)
    return(as.numeric(sprintf("%.*f", decimals, decimal_date(as.Date(x + offset, origin = as.Date("1858-11-17"))))))
  }
  #
  year2mjd <- function(x) {
    decimals <- decimalplaces(x, 0) - 3
    decimals <- ifelse(decimals > 0, decimals, 0)
    return(as.numeric(sprintf("%.*f", decimals, difftime(date_decimal(x), strptime(paste(sprintf("%08d",18581117),sprintf("%06d",000000)),format = '%Y%m%d %H%M%S', tz = "GMT"), units = "days"))))
  }
  #
  week2year <- function(x) {
    decimals <- decimalplaces(diff(x), 0) + 2
    decimals <- ifelse(decimals > 0, decimals, 0)
    return(as.numeric(sprintf("%.*f", decimals, decimal_date(as.Date("1980-01-06") + x * 7))))
  }
  #
  year2week <- function(x) {
    decimals <- decimalplaces(x, 0) - 0
    decimals <- ifelse(decimals > 0, decimals, 0)
    return(as.numeric(sprintf("%.*f", decimals, difftime(date_decimal(x), strptime(paste(sprintf("%08d",19800106),sprintf("%06d",000000)),format = '%Y%m%d %H%M%S', tz = "GMT"), units = "weeks"))))
  }
  #
  printInfo <- function(label) {
    if (isTruthy(file$sitelog) || isTruthy(file$primary$logfile) || isTruthy(file$secondary$logfile)) {
      sitelog <- T
    } else {
      sitelog <- F
    }
    if (isTruthy(file$soln)) {
      soln <- T
    } else {
      soln <- F
    }
    if (isTruthy(file$sinfo)) {
      sinfo <- T
    } else {
      sinfo <- F
    }
    if (isTruthy(file$custom)) {
      custom <- T
    } else {
      custom <- F
    }
    if (isTruthy(file$secondary$name)) {
      secondary <- T
    } else {
      secondary <- F
    }
    if (messages > 0) cat(file = stderr(), mySession, label,
                          "   Format:",info$format,
                          "   Component:", input$tab,
                          "   T.units:", input$tunits,
                          "   S.units:", input$sunits,
                          "   Sigmas:",input$sigmas,
                          "   Average1:", inputs$step,
                          "   Separator:", input$separator,
                          "   Epoch:", input$epoch,
                          "   Variable:", input$variable,
                          "   ErrorBar:", input$errorBar,
                          "   Sitelog:", sitelog,
                          "   station.info:", sinfo,
                          "   soln:", soln,
                          "   custom:", custom,
                          "   Secondary:", secondary,
                          "   Format2:", input$format2,
                          "   Option:", input$optionSecondary,
                          "   Scale:", inputs$scaleFactor,
                          "   Average2:", inputs$step2,
                          "   Separator2:", input$separator2,
                          "   Full series:", input$fullSeries,
                          "   Same scale:", input$sameScale,
                          "   Same axis:", input$same_axis,
                          "   N/E:", input$ne,
                          "   Epoch2:", input$epoch2,
                          "   Variable2:", input$variable2,
                          "   ErrorBar2:", input$errorBar2,
                          "\n")
  }
  #
  compute_entropy <- function(vel) {
    # based on the entropy.estimate function from the vsgoftest package but in log2
    H <- 0
    breaks <- unique(sort(c(trans$x[1],trans$offsetEpochs,trans$offsetEpoch.entropy,trans$x[length(trans$x)])))
    detrended <- trans$y - trans$x * vel
    ntot <- length(unique(detrended))
    for (i in seq_len(length(breaks) - 1)) {
      segment <- trans$x >= breaks[i] & trans$x < breaks[i + 1]
      series <- unique(detrended[segment])
      w <- max(table(series)) + 1
      n <- length(series)
      if (n < 2*w) {
        next
      }
      p <- n/ntot
      xord <- sort(series)
      S <- numeric(n)
      S[1:w] <- log2(n*(xord[1:w + w] - xord[1])/(2*w))
      S[(w + 1):(n - w - 1)] <- log2(n*(xord[(w + 1):(n - w - 1) + w] - xord[(w + 1):(n - w - 1) - w])/(2*w))
      S[(n - w):n] <- log2(n*(xord[n] - xord[(n - w):n - w])/(2*w))
      h <- p * mean(S)
      H <- H + h
    }
    return(H)
  }
  #
  interpolateGIA <- function(x,y,series) {
    z <- NULL
    if (series == 1) {
      variable <- "giaTrend"
      secondary <- ""
    } else if (series == 2) {
      variable <- "giaTrend2"
      secondary <- "secondary"
    } else {
      req(info$stop)
    }
    if (!(x >= 0 & x <= 360) || !(y >= -90 & y <= 90)) {
      showNotification(HTML(paste("The", secondary, "station coordinates are out of bounds.<br>Check the input values.")), action = NULL, duration = 15, closeButton = T, id = "bad_coordinates", type = "error", session = getDefaultReactiveDomain())
      req(info$stop)
    }
    withProgress(message = 'Interpolating GIA grid',
                 detail = paste("from", input$giaModel), value = 0, {
                   withBusyIndicatorServer(variable, {
                     if (input$giaModel == "ICE-6G-VM5a") {
                       gia <- read.table("www/drad.12mgrid_512.txt", comment.char = "#")
                     } else if (input$giaModel == "ICE-6G-ANU") {
                       gia <- read.table("www/ICE6G_ANU.txt")
                       names(gia) <- c("V2","V1","V3")
                     } else if (input$giaModel == "Caron & Ivins") {
                       gia <- read.table("www/GIA_maps_Caron_Ivins_2019.txt", comment.char = "%")[,c(1,2,3)]
                       y <- 90 - y
                     } else {
                       return(z)
                     }
                     setProgress(0.9)
                     lat <- unique(gia$V1)
                     lon <- unique(gia$V2)
                     xs <- lon[abs(lon - x) %in% sort(abs(lon - x), partial = 1:2)[1:2]]
                     ys <- lat[abs(lat - y) %in% sort(abs(lat - y), partial = 1:2)[1:2]]
                     q11 <- gia$V3[gia$V1 == ys[1] & gia$V2 == xs[1]]
                     q12 <- gia$V3[gia$V1 == ys[2] & gia$V2 == xs[1]]
                     q21 <- gia$V3[gia$V1 == ys[1] & gia$V2 == xs[2]]
                     q22 <- gia$V3[gia$V1 == ys[2] & gia$V2 == xs[2]]
                     if ( abs(diff(xs)) > 0 && abs(diff(ys)) > 0 ) {
                       z <- (1/((xs[2] - xs[1])*(ys[2] - ys[1]))) * matrix(c(xs[2] - x, x - xs[1]), nrow = 1, ncol = 2) %*% matrix(c(q11,q21,q12,q22), nrow = 2, ncol = 2) %*% matrix(c(ys[2] - y, y - ys[1]), nrow = 2, ncol = 1)
                     } else if ( abs(diff(ys)) > 0 ) {
                       z <- q11*(ys[2] - y)/(ys[2] - ys[1]) + q12*(y - ys[1])/(ys[2] - ys[1])
                     } else if ( abs(diff(xs)) > 0 ) {
                       z <- q11*(xs[2] - x)/(xs[2] - xs[1]) + q21*(x - xs[1])/(xs[2] - xs[1])
                     } else {
                       z <- gia$V3[gia$V1 == ys[1] & gia$V2 == xs[1]]
                     }
                   })
                 })
    return(z)
  }
  #
  formatting <- function(x, extra_dec) {
    width <- NULL
    if (extra_dec == "x") {
      extra_dec <- 0
      decimals <- info$decimalsx
      scientific <- F
    } else {
      decimals <- info$decimalsy
      scientific <- info$scientific
    }
    if (isTruthy(scientific)) {
      info$digits <- decimals
      info$nsmall <- 0
    } else {
      info$digits <- 2
      info$nsmall <- decimals
    }
    if (is.list(x)) {
      formatted <- format(x, digits = info$digits + extra_dec, nsmall = info$nsmall + extra_dec, scientific = scientific, trim = F, width = width)
    } else if (is.matrix(x) || is.vector(x)) {
      formatted <- format(x, digits = info$digits + extra_dec, nsmall = info$nsmall + extra_dec, scientific = scientific, trim = F, width = width)
      if (!scientific) {
        while (all(grepl("0$", formatted))) {
          formatted <- sub("0$", "", formatted)
        }
        formatted <- sub("\\.$", "", formatted)
      }
    } else {
      x <- as.numeric(x)
      intgr <- as.integer(x)
      x <- x - intgr
      if (length(x) > 1) {
        extra_dig <- 0
        # formatted <- format(intgr + as.numeric(format(x, nsmall = info$nsmall + extra_dec, digits = info$digits + extra_dig, scientific = info$scientific, trim = F, width = width)), nsmall = info$nsmall + extra_dec, scientific = info$scientific, trim = F, width = width)
        formatted <- format(intgr + as.numeric(format(x, digits = 2, scientific = scientific, trim = F, width = width)), nsmall = ifelse(is.null(info$nsmall), 0, info$nsmall) + extra_dec, scientific = scientific, trim = F, width = width)
      } else {
        formatted <- intgr + as.numeric(format(x, nsmall = ifelse(is.null(info$nsmall), 0, info$nsmall) + extra_dec, digits = info$digits + extra_dec, scientific = scientific, trim = F, width = width))
      }
    }
    return(formatted)
  }
  #
  debugMem <- function() {
    output$debug <- renderTable({
      data.frame(
        object = database,
        size = unlist(lapply(database, function(x) {
          total <- 0
          for (i in 1:length(names(get(x)))) {
            name <- names(get(x))[i]
            total <- total + object.size(get(x)[[name]])
          }
          format(total, unit = 'Mb')
        }))
      )
    })
  }
  #
  seriesInfo <- function(x) {
    removeNotification("bad_gaps")
    info$points <- length(x)
    info$sampling <- info$samplingRaw[as.numeric(input$tunits)]
    if (!isTruthy(info$step)) {
      info$sampling0 <- info$sampling
    }
    info$sampling_regular <- median(diff(x), na.rm = T)
    info$tol <- ifelse(info$sampling_regular - info$sampling < info$sampling * 0.25, info$sampling * 0.25, info$sampling_regular - info$sampling)
    info$rangex <- x[length(x)] - x[1]
    times <- round(diff(x)/info$sampling)
    if (isTruthy(times) && length(times) > 1 && all(!is.na(times)) && all(times > 0) && all(!is.infinite(times))) {
      trans$gaps <- c(T, unlist(lapply(1:length(times), function(i) ifelse(times[i] == 1, T, list(unlist(list(rep(F, times[i] - 1),T)))))))
    } else {
      showNotification(HTML("Unable to assess data gaps in the series.<br>Something may be wrong with the expected series format."), action = NULL, duration = 10, closeButton = T, id = "bad_gaps", type = "error", session = getDefaultReactiveDomain())
      trans$gaps <- rep(T, length(x))
    }
    info$decimalsx <- decimalplaces(x,0)
    if (!isTruthy(input$tunits) || input$tunits == 3) {
      info$tunits.label <- "years"
    } else if (input$tunits == 1) {
      info$tunits.label <- "days"
    } else if (input$tunits == 2) {
      info$tunits.label <- "weeks"
    }
  }
  #
  updateOverview <- function() {
    js$checkPopup()
    shinyjs::delay(100, {
      if (isTruthy(info$overview) && isTRUE(isolate(input$overview))) {
        shinyjs::click("plotAll")
      }
    })
  }
  #
  # based on the pd.solve function of the mnormt package but using a different check for symmetry
  matInv <- function(x, silent = FALSE, log.det = FALSE) {
    if (is.null(x)) {
      return(NULL)
    }
    if (any(is.na(x))) {
      if (silent) {
        return(NULL)
      } else {
        stop("NA's in x")
      }
    }
    if (length(x) == 1) {
      x <- as.matrix(x)
    }
    if (!(inherits(x, "matrix"))) {
      if (silent) {
        return(NULL)
      } else {
        stop("x is not a matrix")
      }
    }
    if (!isSymmetric(x)) {
    # if (max(abs(x - t(x))) > .Machine$double.eps) {
      if (silent) {
        return(NULL)
      } else {
        stop("x appears to be not symmetric")
      }
    }
    x <- (x + t(x))/2
    u <- try(chol(x, pivot = FALSE), silent = silent)
    if (inherits(u, "try-error")) {
      if (silent) {
        return(NULL)
      } else {
        stop("x appears to be not positive definite")
      }
    }
    inv <- chol2inv(u)
    if (log.det) {
      attr(inv, "log.det") <- 2 * sum(log(diag(u)))
    }
    dimnames(inv) <- rev(dimnames(x))
    return(inv)
  }
  #
  # based on https://forum.posit.co/t/print-colored-correlation-values-from-print-summary-lm-in-a-shiny-app/196994/
  customPrint <- function(x) {
    # limit to print red probabilities
    prRed <- 0.05
    # limit to print red correlations
    correlRed <- 0.8
    # replacing lower than machine precision by zero and adding space at the end
    summary_output <- as.list(paste(sub(pattern = "< *2e-16", replacement = "      0", x = capture.output(x)), ""))
    # adding html tag to each line
    summary_output <- lapply(summary_output, function(x) {
      span(x)
    })
    if (input$fitType == 1) {
      # changing lm & nls summary output
      if (!grepl("L1",trans$equation) && !grepl("E1",trans$equation)) { # lm model
        id_call <- grep("Call: ", summary_output)
        summary_output <- summary_output[-id_call]
        summary_output <- summary_output[-id_call]
        # summary_output <- append(summary_output, "", after = id_call + sentence_out + 1)
        id_residuals <- grep("Residuals: ", summary_output)
        for (i in seq(4)) { summary_output <- summary_output[-id_residuals] }
        summary_output <- summary_output[-grep("Multiple R-squared: ", summary_output)]
        summary_output <- summary_output[-grep("F-statistic: ", summary_output)]
      } else { # nls model
        id_call <- grep("Formula:", summary_output)
        summary_output <- summary_output[-id_call]
      }
      # split the equation formula into several lines
      id_call <- id_call - 1
      sentences <- unlist(strsplit(paste("Formula:",trans$equation), " \\+ "))
      max_width <- round(info$width/8.125)
      result <- character()
      current_string <- ""
      sentence_out <- 0
      for (sentence in sentences) {
        sentence <- gsub("\\s+", "", sentence, perl = T)
        sentence <- sub("Formula:Model=", "Formula: Model = ", sentence)
        if (nchar(current_string) + nchar(sentence) <= max_width) {
          # adding to current line
          current_string <- paste(current_string, sentence, sep = " + ")
          current_string <- sub("^ \\+ ", "", current_string, perl = T)
        } else {
          # new line
          if (sentence_out == 0) {
            summary_output <- append(summary_output, list(span(paste(current_string, "+"))), after = id_call + sentence_out)
          } else {
            summary_output <- append(summary_output, list(span(paste("                ",current_string,"+"))), after = id_call + sentence_out) 
          }
          sentence_out <- sentence_out + 1
          current_string <- sentence
        }
      }
      # last or unique line
      if (isTruthy(sentence_out) && sentence_out > 0) {
        summary_output <- append(summary_output, list(span(paste("                ",current_string))), after = id_call + sentence_out)
      } else {
        summary_output <- append(summary_output, list(span(current_string)), after = id_call)
      }
      # changing high probabilities into red color and zero if necessary
      found1 <- grepl(pattern = "Parameters:|Coefficients:", x = summary_output, ignore.case = F, fixed = F)
      found2 <- grepl(pattern = "Signif. codes:", x = summary_output, ignore.case = F, fixed = T)
      if (any(found1) && any(found2)) {
        for (i in (which(found1)[1] + 2):(which(found2)[1] - 2)) {
          fit_values <- unlist(strsplit(as.character(summary_output[[i]]), "((?<=\\S)(?=\\s)|(?<=\\s)(?=\\S))", perl = T))
          if (!is.na(suppressWarnings(as.numeric(fit_values[9]))) && as.numeric(fit_values[9]) > prRed) {
            fit_values[9] <- HTML(as.character(span(fit_values[9], style = "color: red;")))
          } else if (!is.na(suppressWarnings(as.numeric(fit_values[9]))) && as.numeric(fit_values[9]) >= 0 & as.numeric(fit_values[9]) < 1e-4) {
            fit_values[9] <- sprintf(fmt = "%*d", nchar(fit_values[9]), 0)
          # } else {
          #   if (messages > 0) cat(file = stderr(), mySession, "Error with the probability of the fit values = ", fit_values[9], "\n")
          }
          summary_output[[i]] <- HTML(paste(fit_values, collapse = ""))
        }
      }
      # changing high correlations into red color
      found1 <- grepl(pattern = "Correlation of ", x = summary_output, ignore.case = F, fixed = T)
      found2 <- grepl(pattern = "Number of iterations to convergence:", x = summary_output, ignore.case = F, fixed = T)
      if (any(found2)) {
        found2 <- which(found2) - 2
      } else {
        found2 <- length(summary_output)
      }
      if (any(found1)) {
        columnsId <- which(found1) + 1
        for (i in (which(found1) + 2):found2) {
          correl_values <- strsplit(as.character(summary_output[[i]]), "(?<=\\s)|(?=\\s)", perl = T)[[1]]
          for (j in which(abs(suppressWarnings(as.numeric(correl_values))) > correlRed)) {
            correl_values[j] <- HTML(as.character(span(correl_values[j], style = "color: red;")))
          }
          summary_output[[i]] <- HTML(paste(correl_values, collapse = ""))
        }
        # recalling the column names below the correlation matrix
        if (found2 - which(found1) > 6) {
          if (!grepl("L1",trans$equation) && !grepl("E1",trans$equation)) {
           summary_output <- summary_output[-found2]
          }
          summary_output <- append(summary_output, list(summary_output[[columnsId]]), after = i)
          summary_output <- c(summary_output, "")
        }
      }
      # adding the break/offset information
      if (isTruthy(trans$breakEpochs) && (input$trendType == 1 || input$sinusoidType == 1)) {
        summary_output <- append(summary_output, paste("Breakpoints at:", paste(trans$breakEpochs, collapse = ", ")))
        summary_output <- c(summary_output, "")
      }
      if (isTruthy(trans$offsetEpochs)) {
        summary_output <- append(summary_output, paste("Offset estimates at:", paste(trans$offsetEpochs, collapse = ", ")))
        summary_output <- c(summary_output, "")
      }
      # adding the sinusoidal information
      if (isTruthy(trans$results$sinusoidales)) {
        summary_output <- append(summary_output, "Sinusoidal estimates:")
        sinusoidals <- as.list(sub('\"', '  ', sub('\"', '', sub('\"', '  ', sub('\"', '', sub('\"', '  ', sub('\"', '', sub('\"', '  ', sub('\"', '', capture.output(print(trans$results$sinusoidales)))))))))))
        sinusoidals <- lapply(sinusoidals, function(x) {
          span(x)
        })
        summary_output <- c(summary_output, sinusoidals)
      }
    }
    tagList(summary_output)
  }
  #
  extractEpochList <- function(x, list, type, list2 = NULL, type2 = NULL) {
    removeNotification("not_numeric_offset")
    removeNotification("duplicated_offset1")
    removeNotification("duplicated_offset2")
    removeNotification("no_valid_soln1")
    removeNotification("no_valid_soln2")
    list_all <- list
    # check for valid numeric values
    not_numeric <- suppressWarnings(which(is.na(as.numeric(list))))
    if (length(not_numeric) > 0) {
      list <- list[-not_numeric]
      showNotification(HTML(paste0("The epoch given for ",type,"(s) ", paste0("#",not_numeric, collapse = " "), " is not numeric.<br>Skipped.")), action = NULL, duration = 10, closeButton = T, id = "not_numeric_offset", type = "warning", session = getDefaultReactiveDomain())
    }
    list <- as.numeric(list)
    if (length(list) > 0) {
      # check for duplicated epochs
      while (anyDuplicated(list) > 0) {
        list_duplicated <- anyDuplicated(list)
        uselessList_id <- which.min(abs(suppressWarnings(as.numeric(list_all) - list[list_duplicated])))
        showNotification(HTML(paste0("The epoch given for ",type," #", uselessList_id, " is duplicated.<br>Skipped.")), action = NULL, duration = 10, closeButton = T, id = "duplicated_offset1", type = "warning", session = getDefaultReactiveDomain())
        list <- list[-list_duplicated]
      }
      # check for duplicated epochs between both lists and remove duplicates from first list
      if (isTruthy(list2)) {
        while (anyDuplicated(c(list2,list)) > 0) {
          list_duplicated <- anyDuplicated(c(list2,list))
          uselessList_id <- which.min(abs(suppressWarnings(as.numeric(list_all) - c(list2,list)[list_duplicated])))
          showNotification(HTML(paste0("The epoch given for ",type," #", uselessList_id, " is duplicated with the ",type2," epochs.<br>Skipped.")), action = NULL, duration = 10, closeButton = T, id = "duplicated_offset2", type = "warning", session = getDefaultReactiveDomain())
          uselessList_id <- which.min(abs(suppressWarnings(as.numeric(list) - c(list2,list)[list_duplicated])))
          list <- list[-uselessList_id]
        }
      }
      # check for soln without observations
      list_sorted <- suppressWarnings(sort(list, na.last = NA))
      if (length(list_sorted) > 1) {
        invalidSegment <- sapply(seq(length(list_sorted) - 1), function(i) length(x[x > list_sorted[i] & x < list_sorted[i + 1]]) ) == 0
        for (soln in which(invalidSegment)) {
          uselessList_id <- which.min(abs(list - list_sorted[soln]))
          uselessList_id1 <- which.min(abs(suppressWarnings(as.numeric(list_all) - list_sorted[soln])))
          uselessList_id2 <- which.min(abs(suppressWarnings(as.numeric(list_all) - list_sorted[soln + 1])))
          list <- list[-uselessList_id]
          showNotification(HTML(paste0("There are no observations between ",type,"s #", uselessList_id1, " and #", uselessList_id2,".<br>The first ",type," was skipped")), action = NULL, duration = 10, closeButton = T, id = "no_valid_soln1", type = "warning", session = getDefaultReactiveDomain())
        }
      }
      # check for soln without observations between both lists and remove duplicates from the first list
      if (isTruthy(list) && isTruthy(list2)) {
        list_sorted <- suppressWarnings(sort(c(list,list2), na.last = NA))
        if (length(list_sorted) > 1) {
          invalidSegment <- sapply(seq(length(list_sorted) - 1), function(i) length(x[x > list_sorted[i] & x < list_sorted[i + 1]]) ) == 0
          for (soln in which(invalidSegment)) {
            uselessList_id <- which.min(abs(list - list_sorted[soln]))
            uselessList_id1 <- which.min(abs(suppressWarnings(as.numeric(list_all) - list_sorted[soln])))
            uselessList_id2 <- which.min(abs(suppressWarnings(as.numeric(list_all) - list_sorted[soln + 1])))
            list <- list[-uselessList_id]
            showNotification(HTML(paste0("There are no observations between ",type," #", uselessList_id1, " and ",type2," #", uselessList_id2,".<br>This ",type," was skipped")), action = NULL, duration = 10, closeButton = T, id = "no_valid_soln2", type = "warning", session = getDefaultReactiveDomain())
          }
        }
      }
      # check for epochs outside data limits
      toremove <- 999999
      for (i in seq_len(length(list))) {
        if (list[i] > x[length(x)] || list[i] < x[1]) {
          uselessList_id <- which.min(abs(suppressWarnings(as.numeric(list_all) - list[i])))
          toremove <- c(toremove, i)
          showNotification(HTML(paste0("There are no observations before and after ",type," #", uselessList_id,".<br>Skipped.")), action = NULL, duration = 10, closeButton = T, id = NULL, type = "warning", session = getDefaultReactiveDomain())
        }
      }
      list <- list[-toremove]
    }
    list
  }
  #
  computeTimeShift <- function(series1,series2) {
    delta <- NULL
    if (any(!is.numeric(series1)) || any(!is.numeric(series2)) || length(series1) == 0 || length(series2) == 0) {
      return(delta)
    }
    if (length(series1) < length(series2)) {
      closest_values <- sapply(series1, function(x) { series2[which.min(abs(series2 - x))] })
      deltas <- series1 - closest_values
    } else {
      closest_values <- sapply(series2, function(x) { series1[which.min(abs(series1 - x))] })
      deltas <- closest_values - series2
    }
    if (isTruthy(deltas) && any(is.numeric(deltas)) && length(deltas) > 0) {
      delta <- median(deltas, na.rm = T)
    }
    return(delta)
  }
}

shinyApp(ui = ui, server = server)
